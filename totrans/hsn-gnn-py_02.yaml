- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph Theory for Graph Neural Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Graph theory** is a fundamental branch of mathematics that deals with the
    study of graphs and networks. A graph is a visual representation of complex data
    structures that helps us understand the relationships between different entities.
    Graph theory provides us with tools to model and analyze a vast array of real-world
    problems, such as transportation systems, social networks, and internet connectivity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will delve into the essentials of graph theory, covering
    three main topics: graph properties, graph concepts, and graph algorithms. We
    will begin by defining graphs and their components. We will then introduce the
    different types of graphs and explain their properties and applications. Next,
    we will cover fundamental graph concepts, objects, and measures, including the
    adjacency matrix. Finally, we will dive into graph algorithms, focusing on the
    two fundamental algorithms, **breadth-first search** (**BFS**) and **depth-first**
    **search** (**DFS**).'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid foundation in graph theory,
    allowing you to tackle more advanced topics and design graph neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing graph properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering graph concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring graph algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples from this chapter can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Graph-Neural-Networks-Using-Python/tree/main/Chapter02](https://github.com/PacktPublishing/Hands-On-Graph-Neural-Networks-Using-Python/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: The installation steps required to run the code on your local machine can be
    found in the *Preface* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing graph properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In graph theory, a graph is a mathematical structure consisting of a set of
    objects, called **vertices** or **nodes**, and a set of connections, called **edges**,
    which link pairs of vertices. The notation ![](img/Formula_B19153_02_001.png)
    is used to represent a graph, where ![](img/Formula_B19153_02_002.png) is the
    graph, ![](img/Formula_B19153_02_003.png) is the set of vertices, and ![](img/Formula_B19153_02_0031.png)
    is the set of edges.
  prefs: []
  type: TYPE_NORMAL
- en: The nodes of a graph can represent any objects, such as cities, people, web
    pages, or molecules, and the edges represent the relationships or connections
    between them, such as physical roads, social relationships, hyperlinks, or chemical
    bonds.
  prefs: []
  type: TYPE_NORMAL
- en: This section provides an overview of fundamental graph properties that will
    be used extensively in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Directed graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most basic properties of a graph is whether it is directed or undirected.
    In a **directed graph**, also called a **digraph**, each edge has a direction
    or orientation. This means that the edge connects two nodes in a particular direction,
    where one node is the source and the other is the destination. In contrast, an
    undirected graph has undirected edges, where the edges have no direction. This
    means that the edge between two vertices can be traversed in either direction,
    and the order in which we visit the nodes does not matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we can use the `networkx` library to define an undirected graph
    as follows with `nx.Graph()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `G` graph corresponds to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Example of an undirected graph](img/B19153_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Example of an undirected graph
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to create a directed graph is similar; we simply replace `nx.Graph()`
    with `nx.DiGraph()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DG` graph corresponds to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Example of a directed graph](img/B19153_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Example of a directed graph
  prefs: []
  type: TYPE_NORMAL
- en: In directed graphs, edges are typically represented using arrows to denote their
    orientation, as in *Figure 2**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Weighted graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important property of graphs is whether the edges are weighted or unweighted.
    In a **weighted graph**, each edge has a weight or cost associated with it. These
    weights can represent various factors, such as distance, travel time, or cost.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a transportation network, the weights of edges might represent
    the distances between different cities or the time it takes to travel between
    them. In contrast, unweighted graphs have no weight associated with their edges.
    These types of graphs are commonly used in situations where the relationships
    between nodes are binary, and the edges simply indicate the presence or absence
    of a connection between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify the previous undirected graph to add weights to our edges. In
    `networkx`, the edges of the graph are defined with a tuple containing the start
    and end nodes and a dictionary specifying the edge’s weight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WG` graph corresponds to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Example of a weighted graph](img/B19153_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Example of a weighted graph
  prefs: []
  type: TYPE_NORMAL
- en: Connected graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graph connectivity is a fundamental concept in graph theory that is closely
    related to the graph’s structure and function.
  prefs: []
  type: TYPE_NORMAL
- en: In a **connected graph**, there is a path between any two vertices in the graph.
    Formally, a ![](img/Formula_B19153_02_005.png) graph is connected if, and only
    if, for every pair of ![](img/Formula_B19153_02_006.png) and ![](img/Formula_B19153_02_007.png)
    vertices in ![](img/Formula_B19153_02_008.png), there exists a path from ![](img/Formula_B19153_02_009.png)
    to ![](img/Formula_B19153_02_010.png). In contrast, a graph is disconnected if
    it is not connected, which means that at least two vertices are not connected
    by a path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `networkx` library provides a built-in function for verifying whether a
    graph is connected or not. In the following example, the first graph contains
    isolated nodes (`4` and `5`), unlike the second graph. This is visualized in *Figure
    2**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first graph is disconnected because of nodes `4` and `5`. On the other
    hand, the second graph is connected. This property is easy to visualize with small
    graphs, as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Left: graph 1 with isolated nodes (disconnected graph); right:
    graph 2 where each node is connected to at least another one (connected graph)](img/B19153_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4 – Left: graph 1 with isolated nodes (disconnected graph); right:
    graph 2 where each node is connected to at least another one (connected graph)'
  prefs: []
  type: TYPE_NORMAL
- en: Connected graphs have several interesting properties and applications. For example,
    in a communication network, a connected graph ensures that any two nodes can communicate
    with each other through a path. In contrast, disconnected graphs can have isolated
    nodes that cannot communicate with other nodes in the network, making it challenging
    to design efficient routing algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways to measure the connectivity of a graph. One of the
    most common measures is the minimum number of edges that need to be removed to
    disconnect the graph, which is known as the graph’s minimum cut. The minimum cut
    problem has several applications in network flow optimization, clustering, and
    community detection.
  prefs: []
  type: TYPE_NORMAL
- en: Types of graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the commonly used graph types, there are some special types
    of graphs that have unique properties and characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: A **tree** is a connected, undirected graph with no cycles (like the graph in
    *Figure 2**.1*). Since there is only one path between any two nodes in a tree,
    a tree is a special case of a graph. Trees are often used to model hierarchical
    structures, such as family trees, organizational structures, or classification
    trees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **rooted tree** is a tree in which one node is designated as the root, and
    all other vertices are connected to it by a unique path. Rooted trees are often
    used in computer science to represent hierarchical data structures, such as filesystems
    or the structure of XML documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **directed acyclic graph** (**DAG**) is a directed graph that has no cycles
    (like the graph in *Figure 2**.2*). This means that the edges can only be traversed
    in a particular direction, and there are no loops or cycles. DAGs are often used
    to model dependencies between tasks or events – for example, in project management
    or in computing the critical path of a job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **bipartite graph** is a graph in which the vertices can be divided into two
    disjoint sets, such that all edges connect vertices in different sets. Bipartite
    graphs are often used in mathematics and computer science to model relationships
    between two different types of objects, such as buyers and sellers, or employees
    and projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **complete graph** is a graph in which every pair of vertices is connected
    by an edge. Complete graphs are often used in combinatorics to model problems
    involving all possible pairwise connections, and in computer networks to model
    fully connected networks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 2**.5* illustrates these different types of graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Common types of graphs](img/B19153_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Common types of graphs
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have reviewed essential types of graphs, let’s move on to exploring
    some of the most important graph objects. Understanding these concepts will help
    us analyze and manipulate graphs effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering graph concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore some of the essential concepts in graph theory,
    including graph objects (such as degree and neighbors), graph measures (such as
    centrality and density), and the adjacency matrix representation.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the key concepts in graph theory is the **degree** of a node, which
    is the number of edges **incident** to this node. An edge is said to be incident
    on a node if that node is one of the edge’s endpoints. The degree of a node ![](img/Formula_B19153_02_011.png)
    is often denoted by ![](img/Formula_B19153_02_012.png). It can be defined for
    both directed and undirected graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: In an undirected graph, the degree of a vertex is the number of edges that are
    connected to it. Note that if the node is connected to itself (called a **loop**,
    or **self-loop**), it adds two to the degree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a directed graph, the degree is divided into two types: **indegree** and
    **outdegree**. The indegree (denoted by ![](img/Formula_B19153_02_013.png)) of
    a node represents the number of edges that point towards that node, while the
    outdegree (denoted by ![](img/Formula_B19153_02_014.png)) represents the number
    of edges that start from that node. In this case, a self-loop adds one to the
    indegree and to the outdegree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indegree and outdegree are essential for analyzing and understanding directed
    graphs, as they provide insight into how information or resources are distributed
    within the graph. For example, nodes with high indegree are likely to be important
    sources of information or resources. In contrast, nodes with high outdegree are
    likely to be important destinations or consumers of information or resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `networkx`, we can simply calculate the node degree, indegree, or outdegree
    using built-in methods. Let’s do it for the undirected graph from *Figure 2**.1*
    and the directed graph from *Figure 2**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compare it to the graphs from *Figures 2.1* and *2.2*: node ![](img/Formula_B19153_02_015.png)
    is connected to two edges (![](img/Formula_B19153_02_016.png)), but is not the
    destination of any of them (![](img/Formula_B19153_02_017.png)).'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of node degree is related to that of **neighbors**. Neighbors refer
    to the nodes directly connected to a particular node through an edge. Moreover,
    two nodes are said to be **adjacent** if they share at least one common neighbor.
    The concepts of neighbors and adjacency are fundamental to many graph algorithms
    and applications, such as searching for a **path** between two nodes or identifying
    clusters in a network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In graph theory, a path is a sequence of edges that connect two nodes (or more)
    in a graph. The length of a path is the number of edges that are traversed along
    the path. There are different types of paths, but two of them are particularly
    important:'
  prefs: []
  type: TYPE_NORMAL
- en: A **simple path** is a path that does not visit any node more than once, except
    for the start and end vertices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **cycle** is a path in which the first and last vertices are the same. A graph
    is said to be acyclic if it contains no cycles (such as trees and DAGs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Degrees and paths can be used to determine the importance of a node in a network.
    This measure is referred to as **centrality**.
  prefs: []
  type: TYPE_NORMAL
- en: Graph measures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Centrality quantifies the importance of a vertex or node in a network. It helps
    us to identify key nodes in a graph based on their connectivity and influence
    on the flow of information or interactions within the network. There are several
    measures of centrality, each providing a different perspective on the importance
    of a node:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Degree centrality** is one of the simplest and most commonly used measures
    of centrality. It is simply defined as the degree of the node. A high degree centrality
    indicates that a vertex is highly connected to other vertices in the graph, and
    thus significantly influences the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closeness centrality** measures how close a node is to all other nodes in
    the graph. It corresponds to the average length of the shortest path between the
    target node and all other nodes in the graph. A node with high closeness centrality
    can quickly reach all other vertices in the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Betweenness centrality** measures the number of times a node lies on the
    shortest path between pairs of other nodes in the graph. A node with high betweenness
    centrality acts as a bottleneck or bridge between different parts of the graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s calculate these measures on our previous graphs using the built-in functions
    of `networkx` and analyze the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code prints the dictionaries, containing a score for each node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The importance of nodes ![](img/Formula_B19153_02_018.png), ![](img/Formula_B19153_02_019.png),
    and ![](img/Formula_B19153_02_020.png) in a graph depends on the type of centrality
    used. Degree centrality considers nodes ![](img/Formula_B19153_02_021.png) and
    ![](img/Formula_B19153_02_022.png) to be more important because they have more
    neighbors than node ![](img/Formula_B19153_02_023.png). However, in closeness
    centrality, node ![](img/Formula_B19153_02_024.png) is the most important as it
    can reach any other node in the graph in the shortest possible path. On the other
    hand, nodes ![](img/Formula_B19153_02_025.png), ![](img/Formula_B19153_02_026.png)
    and ![](img/Formula_B19153_02_027.png) have equal betweenness centrality, as they
    all lie on a large number of shortest paths between other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these measures, we will see how to calculate the importance of
    a node using machine learning techniques in the next chapters. However, it is
    not the only measure we will cover.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, **density** is another important measure, indicating how connected a
    graph is. It is a ratio between the actual number of edges and the maximum possible
    number of edges in the graph. A graph with high density is considered more connected
    and has more information flow compared to a graph with low density.
  prefs: []
  type: TYPE_NORMAL
- en: The formula to calculate density depends on whether the graph is directed or
    undirected. For an undirected graph with ![](img/Formula_B19153_02_028.png) nodes,
    the maximum possible number of edges is ![](img/Formula_B19153_02_029.png). For
    a directed graph with ![](img/Formula_B19153_02_030.png) nodes, the maximum number
    of edges is ![](img/Formula_B19153_02_031.png).
  prefs: []
  type: TYPE_NORMAL
- en: The density of a graph is calculated as the number of edges divided by the maximum
    number of edges. For example, the graph in *Figure 2**.1* has ![](img/Formula_B19153_02_032.png)
    edges and the maximum possible number of ![](img/Formula_B19153_02_033.png) edges.
    Therefore, it has a density of ![](img/Formula_B19153_02_034.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'A dense graph has a density closer to 1, while a sparse graph has a density
    closer to 0\. There is no strict rule for what constitutes a dense or sparse graph,
    but generally, a graph is considered dense if its density is greater than 0.5
    and sparse if its density is less than 0.1\. This measure is directly connected
    to a fundamental problem with graphs: how to represent the **adjacency matrix**.'
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrix representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An adjacency matrix is a matrix that represents the edges in a graph, where
    each cell indicates whether there is an edge between two nodes. The matrix is
    a square matrix of size ![](img/Formula_B19153_02_035.png), where ![](img/Formula_B19153_02_036.png)
    is the number of nodes in the graph. A value of ![](img/Formula_B19153_02_037.png)
    in the cell ![](img/Formula_B19153_02_038.png) indicates that there is an edge
    between node ![](img/Formula_B19153_02_039.png) and node ![](img/Formula_B19153_02_040.png),
    while a value of ![](img/Formula_B19153_02_041.png) indicates that there is no
    edge. For an undirected graph, the matrix is symmetric, while for a directed graph,
    the matrix is not necessarily symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure indicates the adjacency matrix associated with the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Example of the adjacency matrix](img/B19153_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Example of the adjacency matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, it can be implemented as a list of lists, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The adjacency matrix is a straightforward representation that can be easily
    visualized as a 2D array. One of the key advantages of using an adjacency matrix
    is that checking whether two nodes are connected is a constant time operation.
    This makes it an efficient way to test the existence of an edge in the graph.
    Moreover, it is used to perform matrix operations, which are useful for certain
    graph algorithms, such as calculating the shortest path between two nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, adding or removing nodes can be costly, as the matrix needs to be
    resized or shifted. One of the main drawbacks of using an adjacency matrix is
    its space complexity: as the number of nodes in the graph grows, the space required
    to store the adjacency matrix increases exponentially. Formally, we say that the
    adjacency matrix has a space complexity of ![](img/Formula_B19153_02_042.png),
    where ![](img/Formula_B19153_02_043.png) represents the number of nodes in the
    graph.'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, while the adjacency matrix is a useful data structure for representing
    small graphs, it may not be practical for larger ones due to its space complexity.
    Additionally, the overhead of adding or removing nodes can make it inefficient
    for dynamically changing graphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why other representations can be helpful. For example, another popular
    way to store graphs is the `networkx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When we compare both data structures applied to our graph, it is clear that
    the edge list is less verbose. This is the case because our graph is fairly sparse.
    On the other hand, if our graph was complete, we would require 21 tuples instead
    of 6\. This is explained by a space complexity of ![](img/Formula_B19153_02_044.png),
    where ![](img/Formula_B19153_02_045.png) is the number of edges. Edge lists are
    more efficient for storing sparse graphs, where the number of edges is much smaller
    than the number of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: However, checking whether two vertices are connected in an edge list requires
    iterating through the entire list, which can be time-consuming for large graphs
    with many edges. Therefore, edge lists are more commonly used in applications
    where space is a concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'A third and popular representation is the **adjacency list**. It consists of
    a list of pairs, where each pair represents a node in the graph and its adjacent
    nodes. The pairs can be stored in a linked list, dictionary, or other data structures,
    depending on the implementation. For example, an adjacency list for our graph
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: An adjacency list has several advantages over an adjacency matrix or an edge
    list. First, the space complexity is ![](img/Formula_B19153_02_046.png), where
    ![](img/Formula_B19153_02_047.png) is the number of nodes and ![](img/Formula_B19153_02_048.png)
    is the number of edges. This is more efficient than the ![](img/Formula_B19153_02_049.png)
    space complexity of an adjacency matrix for sparse graphs. Second, it allows for
    efficient iteration through the adjacent vertices of a node, which is useful in
    many graph algorithms. Finally, adding a node or an edge can be done in constant
    time.
  prefs: []
  type: TYPE_NORMAL
- en: However, checking whether two vertices are connected can be slower than with
    an adjacency matrix. This is because it requires iterating through the adjacency
    list of one of the vertices, which can be time-consuming for large graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Each data structure has its own advantages and disadvantages that depend on
    the specific application and requirements. In the next section, we will process
    graphs and introduce the two most fundamental graph algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring graph algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graph algorithms are critical in solving problems related to graphs, such as
    finding the shortest path between two nodes or detecting cycles. This section
    will discuss two graph traversal algorithms: BFS and DFS.'
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-first search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BFS is a graph traversal algorithm that starts at the root node and explores
    all the neighboring nodes at a particular level before moving to the next level
    of nodes. It works by maintaining a queue of nodes to visit and marking each visited
    node as it is added to the queue. The algorithm then dequeues the next node in
    the queue and explores all its neighbors, adding them to the queue if they haven’t
    been visited yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of a BFS is illustrated in *Figure 2**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Example of graph traversal made by a breadth-first search](img/B19153_02_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Example of graph traversal made by a breadth-first search
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now see how we can implement it in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create an empty graph and add edges with the `add_edges_from()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a function called `bfs()` that implements the BFS algorithm on a
    graph. The function takes two arguments: the `graph` object and the starting node
    for the search:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We initialize two lists (`visited` and `queue`) and add the starting node.
    The `visited` list keeps track of the nodes that have been visited during the
    search, while the `queue` list stores the nodes that need to be visited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We enter a `while` loop that continues until the `queue` list is empty. Inside
    the loop, we remove the first node in the `queue` list using the `pop(0)` method
    and store the result in the `node` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We iterate through the neighbors of the node using a `for` loop. For each neighbor
    that has not been visited yet, we add it to the `visited` list and to the end
    of the `queue` list using the `append()` method. When it’s complete, we return
    the `visited` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We call the `bfs()` function with the `G` argument and the `''A''` starting
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function returns the list of visited nodes in the order in which they were
    visited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The order we obtained is the one we anticipated in *Figure 2**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: BFS is particularly useful in finding the shortest path between two nodes in
    an unweighted graph. This is because the algorithm visits nodes in order of their
    distance from the starting node, so the first time the target node is visited,
    it must be along the shortest path from the starting node.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to finding the shortest path, BFS can also be used to check whether
    a graph is connected or to find all connected components of a graph. It is also
    used in applications such as web crawlers, social network analysis, and shortest
    path routing in networks.
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of BFS is ![](img/Formula_B19153_02_050.png), where ![](img/Formula_B19153_02_051.png)
    is the number of nodes and ![](img/Formula_B19153_02_052.png) is the number of
    edges in the graph. This can be a significant issue for graphs with a high degree
    of connectivity or for graphs that are sparse. Several variants of BFS have been
    developed to mitigate this issue, such as **bidirectional BFS** and **A*** search,
    which use heuristics to reduce the number of nodes that need to be explored.
  prefs: []
  type: TYPE_NORMAL
- en: Depth-first search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DFS is a recursive algorithm that starts at the root node and explores as far
    as possible along each branch before backtracking.
  prefs: []
  type: TYPE_NORMAL
- en: It chooses a node and explores all of its unvisited neighbors, visiting the
    first neighbor that has not been explored and backtracking only when all the neighbors
    have been visited. By doing so, it explores the graph by following as deep a path
    from the starting node as possible before backtracking to explore other branches.
    This continues until all nodes have been explored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of a DFS is illustrated in *Figure 2**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Example of graph traversal made by a depth-first search](img/B19153_02_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Example of graph traversal made by a depth-first search
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement DFS in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first initialize an empty list called `visited`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a function called `dfs()` that takes in `visited`, `graph`, and `node`
    as arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the current `node` is not in the `visited` list, we append it to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then iterate through each neighbor of the current `node`. For each neighbor,
    we recursively call the `dfs()` function passing in `visited`, `graph`, and the
    neighbor as arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `dfs()` function continues to explore the graph depth-first, visiting all
    the neighbors of each node until there are no more unvisited neighbors. Finally,
    the `visited` list is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We call the `dfs()` function with `visited` set to an empty list, `G` as the
    graph, and `''A''` as the starting node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function returns the list of visited nodes in the order in which they were
    visited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once again, the order we obtained is the one we anticipated in *Figure 2**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: DFS is useful in solving various problems, such as finding connected components,
    topological sorting, and solving maze problems. It is particularly useful in finding
    cycles in a graph since it traverses the graph in a depth-first order, and a cycle
    exists if, and only if, a node is visited twice during the traversal.
  prefs: []
  type: TYPE_NORMAL
- en: Like BFS, it has a time complexity of ![](img/Formula_B19153_02_053.png), where
    ![](img/Formula_B19153_02_054.png) is the number of nodes and ![](img/Formula_B19153_02_055.png)
    is the number of edges in the graph. It requires less memory but doesn’t guarantee
    the shallowest path solution. Finally, unlike BFS, you can be trapped in infinite
    loops using DFS.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, many other algorithms in graph theory build upon BFS and DFS,
    such as Dijkstra’s shortest path algorithm, Kruskal’s minimum spanning tree algorithm,
    and Tarjan’s strongly connected components algorithm. Therefore, a solid understanding
    of BFS and DFS is essential for anyone who wants to work with graphs and develop
    more advanced graph algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the essentials of graph theory, a branch of mathematics
    that studies graphs and networks. We began by defining what a graph is and explained
    the different types of graphs, such as directed, weighted, and connected graphs.
    We then introduced fundamental graph objects (including neighbors) and measures
    (such as centrality and density), which are used to understand and analyze graph
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we discussed the adjacency matrix and its different representations.
    Finally, we explored the two fundamental graph algorithms, BFS and DFS, which
    form the foundation for developing more complex graph algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B19153_03.xhtml#_idTextAnchor041), *Creating Node Representations
    with DeepWalk*, we will explore the DeepWalk architecture and its two components:
    Word2Vec and random walks. We will start by understanding the Word2Vec architecture
    and then implement it using a specialized library. Then, we will delve into the
    DeepWalk algorithm and implement random walks on a graph.'
  prefs: []
  type: TYPE_NORMAL
