- en: Deploying Models to Web and Mobile
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For companies that depend on machine learning, it is very important to deploy
    their models in a scalable fashion. The models should work in the same manner
    that they were working in when the model was created. Deploying fastText models,
    both supervised and unsupervised, can be done in a variety of ways. The choice
    of methodology would depend on your individual needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on how to deploy fastText models in web and
    mobile scenarios. The topics are the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to the web
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FastText functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask endpoints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to smaller devices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites – Completing the Google tutorial
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App considerations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the fastText model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FastText in Java
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding library dependencies to Android
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using library dependencies in Android
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the app
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to the web
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have the ways and means to create your own fastText models, you
    will probably need to deploy them to production so that those models can be utilized
    to create applications and endpoints to use. There are a lot of frameworks in
    Python that can be used to create such web apps. Flask, Django, and Pyramid are
    some popular Python web frameworks. In this section, we will take the example
    of flask and build a simple web nearest neighbor search application in flask.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Flask
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask is a popular web framework, and it is classified as a microframework as
    it does not require any external tools or libraries. There are no database abstraction
    layers, or form validation, or other components built into flask. The advantage
    of this is that you can build a simple web app in flask with minimal lines of
    code. This helps fast prototyping and helps you to focus on the application code
    itself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: For code that is discussed in this section, take a look at the `chapter 7` folder
    in the repository. You will find two files, `ft_server.py` and `ft_utils.py`.
    The `ft_utils.py` module has the code related to the fastText server, and `ft_server.py`
    has the code related to the flask endpoints.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The fastText functions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you take a look at the code, we are loading the fastText module from the
    `FT_MODEL` environment variable. This model is loaded as a global variable so
    that it can be utilized in the functions as well. Another advantage is that when
    the flask app is initialized, the model will also be loaded into memory. Loading
    the model into memory is computationally expensive and hence if we defer that
    operation to the initialization phase, that will improve the response timings:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we will also get the most common words in the vocabulary, based on a threshold,
    and keep it in memory. We will keep the word vectors, again as a global variable,
    so that the computation of the word vectors is done during the initiation of the
    app, similar to before:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The next two functions are basically how to get the nearest words, based on
    the distances between the word vector for the question word and the word vectors
    of the other words as well. These functions have also been discussed in [Chapter
    5](part0115.html#3DLGM0-05950c18a75943d0a581d9ddc51f2755), *FastText in Python*
    as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to run the module by itself. Also, notice the time required
    to run the whole module.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Running the whole code takes around 10 seconds on my laptop.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The flask endpoints
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For reasons of brevity, there is only one endpoint that is discussed in this
    app. Basically, it is used to take the incoming question word, get the answers
    from the `nn` function defined in the `ft_utils.py` file, and then serve the answers
    in JSON format:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, run the app in development mode and so that you can debug it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open a new terminal and send a curl request; you should be able to see the
    response in the Terminal. You can see that the response is also fast:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are able to have very fast responses as part of the Flask app as we tried
    to shift the computationally expensive portions of the code to the app initiation
    phase as much as possible. This is generally a good idea. As part of the web app,
    only do what is absolutely necessary and keep the amount of computation as part
    of serving the request to the minimum. This will ensure that you are building
    effective and useful web apps to for deploying fastText models and machine learning
    apps in general.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to smaller devices
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you saw in [Chapter 2](part0036.html#12AK80-05950c18a75943d0a581d9ddc51f2755), *Creating
    Models Using FastText Command Line*, you can create a compressed fastText model
    from a whole model using a command similar to this one:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In [Chapter 4](part0098.html#2TEN40-05950c18a75943d0a581d9ddc51f2755), *Sentence
    Classification in FastText*, we also revisited the concept of having compressed
    models and how compression was achieved without much loss in performance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: This enables you to deploy machines in smaller devices as well. One of the first
    things that comes to mind is whether the files can be packaged with an Android
    app and deployed in an Android application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I will put into place all the requirements and dependencies
    that should enable you to deploy an Android fastText application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites – Completing the Google tutorial
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the best examples to consider is the example Android app in the Google
    tutorial. In case you are new to Android, go to [https://developer.android.com/training/basics/firstapp/](https://developer.android.com/training/basics/firstapp/)
    and complete the tutorial there. We will not go into the details here, so in summary,
    the steps are:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Install Android Studio
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create some simple user interfaces
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the activities and define the intents
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and create the APK files
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our app, we will be working along similar lines. The name of the project
    in our case is `Fasttext application`. So, download the latest Android Studio
    and fire it up:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: 'Keep on clicking Next, select empty activity, and click Finish. You should
    be taken to a new project window, which has a lot of boilerplate code for Android
    already done for you. Now, open up the Google tutorial and follow all the steps
    in the tutorial. If you are already an experienced Android developer, then you
    can open the project from the GitHub repository. First, do a `git fetch` and check
    out the `android_starting` branch:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, if you compile the app and create an APK, you should be able to get the
    following screen. Or if you have ADB set up, you can just select Run and see the
    app in your emulator.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'To build an APK, you can click the Build APK(s) button in your Android Studio:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'Please go through the steps written in Build a simple User interface in the
    Google Android tutorial so that you finally get a simple app running, similar
    to this one:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: 'Now, go through the Start another activity tutorial and complete the creation
    of another activity. The aim of this tutorial is so that you can have a separate
    activity triggered from the first activity:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)           =>              ![](img/00094.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: App considerations
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have two activities, you might have guessed the aim of our fastText
    application. We will input our text label in the first activity, and it should
    give us the labels in the second activity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve that, you will need to do two things:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Add a prebuilt fastText model to the Android app
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a library that will parse the fastText model and give us the predictions
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are some points that I would like to mention here. We are going to use
    the fastText FTZ models here. You can argue as we had seen, fastText models are
    built using product quantization using methods such as nearest neighbor centroid
    estimations, pruning of vocabularies and hashing. This results in loss of information,
    although it is argued that there is no significant loss in performance. But if
    you are not convinced, you have the option of creating the web app as discussed
    in the previous section and accessing the results from your Android app, which
    means having the Android app as a view-only, and deferring all the computation
    to the server. That is a fair course to take, but is more of an engineering challenge
    and not within the scope of this book. In this section, we are more interested
    in finding out whether we can leverage the capabilities of fastText to create
    really small models, deploy them in mobile devices, and use them in our applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Now before we go ahead, build the APK and take note of the present size of the
    application, since size is an important matter for users if you want users to
    download and use the application. You probably don't want your users to uninstall
    the application because the memory is full, or the user is in a place where the
    internet is really slow and it will take a long time to download the application.
    So, keep the application size always in mind when designing applications for smaller
    devices.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, the build is taking up only 1.5 MB of memory:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding the fastText model
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving ahead, now you will need to add a fastText model to the application.
    Android has an asset management system which can be used for this.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: First of all, download or create an FTZ model. I downloaded the `dbpedia.ftz`
    file from the supervised models section of the fastText website. The file is around
    1.6 MB in size and hence should not bump up the APK size in the final build.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Android has a resource management system and you can use that for this purpose.
    Create an assets folder under the main folder and copy/paste your FTZ file there:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: 'You should be able to see the file, as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Once done, add the code to access the file using the resource manager. Since
    we are making the predictions in the second activity, let's access this file in
    the `DisplayMessageActivity.java` file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `onCreate` method, create an `AssetManager` instance to access the asset
    files, and create an `InputStream` instance so that the file can be converted
    to a stream. The data will be read and manipulated from this stream, shown as
    follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Press *Alt* + *Enter* (or *Option* + *Enter* on a Mac) to import missing classes.
    Your imports should end up as the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: FastText in Java
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have the fastText model deployed in the Android app, you will need
    a way to access the file and serve the predictions. One way that you can do this
    is that you can write Java custom code using the fastText GitHub repository as
    a reference. The advantage of this approach is that you have more control over
    the code, and that might be the only option if you are writing an enterprise application,
    since the code of fastText is given under the BSD license. Another option is to
    take the fastText code and compile the code as part of the Android library, but
    there are a lot of issues with serving native code and it may not work on all
    devices. The best approach for me when adding external dependencies is if you
    can find core Java libraries that do the work for you.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately in this case, we have one that fits the bill. `fastText4j` is an
    excellent Java library by `linkfluence` on GitHub that has all the code in Java
    and is able to load and parse Java libraries as well. Apart from the ability to
    read bin and FTZ files, we also have the ability read and create Java memory mapped
    files, although we will not be using it here. Use the following repository to
    clone the repository that is a clone of the original `linkfluence` one:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also compile the package to an app as we will need that for testing and compilation
    purposes. Unzip the file that is created as a result:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should copy a `lib/` folder and `fasttext-mmap.sh` file to your present
    directory. The last copy stage is not really necessary now, but this is just to
    show you this step is needed when you make changes to this repository and recompile
    the JAR again. For now, the file will have a slightly different command line.
    Change the `main` method in `src/main/java/fasttext/FastText.java`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output args are removed and we are giving a model as input and getting
    the parameters. Compile this and also copy the path to the FTZ model that we downloaded.
    We will test the library now:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There will be a lot of logs as part of the output commands. We are not showing
    them here for now. Just check whether there are any error messages in the logs,
    which will probably mark the missing dependency libraries. Also, as you can see,
    loading and serving predictions from the FTZ file is quite fast on my local machine.
    The assumption is that it will be performant in a low-performing Android app as
    well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have established that the library works and is able to give predictions,
    remove the `main` method as we won''t be needing it in the Android app itself.
    Compile the JAR and place it in the `lib` folder:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding the library dependencies to Android
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check in the `lib` folder. There will be placed all the libraries that are the
    dependencies for this project. We will need to add these dependencies to our Android
    application if we want to use this library.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Open File | New | New Module...:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: 'Import the JAR/AAR package:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'Now, add all the libraries in the `lib` folder to as dependencies. Now, your
    project structure should list the libraries as dependencies. Now, click on app
    | dependencies and add them as dependencies for the app as well. Add the library
    files as module dependencies:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Now that the dependencies are there, we can start using the library in our activity.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Using library dependencies in Android
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use the library in Android, change `DisplayMessageActivity.java` and write
    the same code that you saw in the library testing phase.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Before compiling, add the `guava` dependency in your `gradle.build` file as
    the `UnsignedLong` dependencies in the `guava` library:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Also, add the compile version so that it''s able to compile the Java code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally the app
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, compile the app and run it on your phone. You should be able to get the
    changes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译应用并在你的手机上运行。你应该能够看到这些变化：
- en: '![](img/00100.jpeg)     =>    ![](img/00101.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)     =>    ![](img/00101.jpeg)'
- en: 'Lets also take a look at the APK that was created. On my machine, the app size
    has changed to 4.6 MB. Small enough? I will leave it to you to be the judge of
    that:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也来看一下创建的APK文件。在我的机器上，应用的大小已变为4.6 MB。够小了吗？我将把这个问题留给你自己判断：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at the methodologies to implement fastText in
    a web and mobile context, focusing specifically on Android. We also took a look
    at the different considerations that you need to bear in mind, depending on whether
    you need to deploy on web or mobile. This should help you to create good applications
    and integrate fastText into your mobile applications.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了如何在网页和移动环境中实现fastText的方法，特别是针对Android平台。我们还探讨了在部署到网页或移动设备时需要考虑的不同因素。这将帮助你创建出色的应用，并将fastText集成到你的移动应用中。
