<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Maths for Neural Networks</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">Neural network users need to have a fair understanding of neural network concepts, algorithms, and the underlying mathematics. Good mathematical intuition and understanding of many techniques is necessary for a solid grasp of the inner functioning of the algorithms and for getting good results. The amount of maths required and the level of maths needed to understand these techniques is multidimensional and also depends on interest. In this chapter, you will learn neural networks by understanding the maths used to solve complex computational problems. This chapter covers the basics of linear algebra, calculus, and optimization for neural networks.</p>
<p class="calibre4">The main purpose of this chapter is to set up the fundamentals of mathematics for the upcoming chapters.</p>
<p class="calibre4">Following topics will be covered in the chapter:</p>
<ul class="calibre20">
<li class="calibre21">Understanding linear algebra</li>
<li class="calibre21">Understanding Calculus</li>
<li class="calibre21">Optimization</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Understanding linear algebra</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">Linear algebra is a key branch of mathematics. An understanding of linear algebra is crucial for <strong class="calibre7">deep learning</strong>, that is, neural networks. Throughout this chapter, we will go through the key and fundamental linear algebra prerequisites. Linear Algebra deals with linear systems of equations. Instead of working with scalars, we start working with matrices and vectors. Using linear algebra, we can describe complicated operations in deep learning.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Environment setup</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">Before we jump into the field of mathematics and its properties, it's essential for us to set up the development environment as it will provide us settings to execute the concepts we learn, meaning installing the compiler, dependencies, and <strong class="calibre7">IDE</strong> (<strong class="calibre7">Integrated Development Environment</strong>) to run our code base.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Setting up the Python environment in Pycharm</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">It is best to use an IDE like Pycharm to edit Python code as it provides development tools and built-in coding assistance. Code inspection makes coding and debugging faster and simpler, ensuring that you focus on the end goal of learning maths for neural networks.</p>
<p class="calibre4">The following steps show you how to set up local Python environment in Pycharm:</p>
<ol class="calibre23">
<li class="chapter">Go to <span class="calibre5">Preferences</span> and verify that the TensorFlow library is installed. If not, follow the instructions at <a href="https://www.tensorflow.org/install/" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2">https://www.tensorflow.org/install/</a> to install TensorFlow:</li>
</ol>
<div class="mce-root"><img src="Images/80d45f03-9991-4b89-a3f8-78695a3e62f6.png" class="calibre27"/></div>
<ol start="2" class="calibre23">
<li class="chapter">Keep the default options of TensorFlow and click on <span class="calibre5">OK</span>.</li>
<li class="chapter">Finally, right-click on the source file and click on <span class="calibre5">Run 'matrices'</span>:</li>
</ol>
<div class="mce-root"><img src="Images/adef8686-9dd0-4c7c-93a1-38bdbb9f497e.png" class="calibre28"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Linear algebra structures</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">In the following section, we will describe the fundamental structures of linear algebra.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Scalars, vectors, and matrices</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">Scalars, vectors, and matrices are the fundamental objects of mathematics. Basic definitions are listed as follows:</p>
<ul class="calibre20">
<li class="calibre21">Scalar is represented by a single number or numerical value called <strong class="calibre3">magnitude</strong>.</li>
<li class="calibre21">Vector is an array of numbers assembled in order. A unique index identifies each number. Vector represents a point in space, with each element giving the coordinate along a different axis.</li>
<li class="calibre21">Matrices is a two-dimensional array of numbers where each number is identified using two indices (<em class="calibre29">i</em>, <em class="calibre29">j</em>).</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Tensors</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">An array of numbers with a variable number of axes is known as a <strong class="calibre7">tensor</strong>. For example, for three axes, it is identified using three indices (<em class="calibre17">i</em>, <em class="calibre17">j</em>, <em class="calibre17">k</em>). </p>
<p class="calibre4">The following image summaries a tensor, it describes a second-order tensor object. In a three-dimensional Cartesian coordinate system, tensor components will form the matrix:</p>
<div class="mce-root">      <img src="Images/713cf813-f618-4301-bcf0-94bb9d530429.png" width="1200" height="1094" class="calibre30"/></div>
<div class="packt_infobox">Image reference is taken from tensor wiki <a href="https://en.wikipedia.org/wiki/Tensor" target="_blank" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre31">https://en.wikipedia.org/wiki/Tensor</a></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Operations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">The following topics will describe the various operations of linear algebra.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Vectors</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">The <kbd class="calibre18">Norm</kbd> function is used to get the size of the vector; the norm of a vector <em class="calibre17">x</em> measures the distance from the origin to the point <em class="calibre17">x</em>. It is also known as the <img src="Images/c656e3fe-f16d-4703-b95d-18dd3dc02fca.jpg" width="63" height="63" class="calibre32"/>norm, where <em class="calibre17">p=2</em> is known as the <strong class="calibre7">Euclidean norm</strong>.</p>
<p class="calibre4">The following example shows you how to calculate the <img src="Images/c656e3fe-f16d-4703-b95d-18dd3dc02fca.jpg" width="63" height="63" class="calibre33"/>norm of a given vector:</p>
<pre class="calibre26"><span class="calibre5">import </span>tensorflow <span class="calibre5">as </span>tf<br class="calibre2"/><br class="calibre2"/>vector = tf.constant([[<span class="calibre5">4</span>,<span class="calibre5">5</span>,<span class="calibre5">6</span>]], <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/>eucNorm = tf.norm(vector, <span class="calibre5">ord</span>=<span class="calibre5">"euclidean"</span>)<br class="calibre2"/><br class="calibre2"/><span class="calibre5">with </span>tf.Session() <span class="calibre5">as </span>sess:<br class="calibre2"/><span class="calibre5">print</span>(sess.run(eucNorm))</pre>
<p class="calibre34">The output of the listing is 8.77496.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Matrices</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">A matrix is a two-<span class="calibre14">dimensional</span> array of numbers where each element is identified by two indices instead of just one. If a real matrix <em class="calibre17">X</em> has a height of <em class="calibre17">m</em> and a width of <em class="calibre17">n</em>, then we say that <em class="calibre17">X ∈ Rm × n</em>. Here, <em class="calibre17">R</em> is a set of real numbers.</p>
<p class="calibre4">The following example shows how different matrices are converted to tensor objects:</p>
<pre class="calibre26"><span class="calibre5"># convert matrices to tensor objects<br class="calibre2"/></span><span class="calibre5">import </span>numpy <span class="calibre5">as </span>np<br class="calibre2"/><span class="calibre5">import </span>tensorflow <span class="calibre5">as </span>tf<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># create a 2x2 matrix in various forms<br class="calibre2"/></span>matrix1 = [[<span class="calibre5">1.0</span>, <span class="calibre5">2.0</span>], [<span class="calibre5">3.0</span>, <span class="calibre5">40</span>]]<br class="calibre2"/>matrix2 = np.array([[<span class="calibre5">1.0</span>, <span class="calibre5">2.0</span>], [<span class="calibre5">3.0</span>, <span class="calibre5">40</span>]], <span class="calibre5">dtype</span>=np.float32)<br class="calibre2"/>matrix3 = tf.constant([[<span class="calibre5">1.0</span>, <span class="calibre5">2.0</span>], [<span class="calibre5">3.0</span>, <span class="calibre5">40</span>]])<br class="calibre2"/><br class="calibre2"/><span class="calibre5">print</span>(<span class="calibre5">type</span>(matrix1))<br class="calibre2"/><span class="calibre5">print</span>(<span class="calibre5">type</span>(matrix2))<br class="calibre2"/><span class="calibre5">print</span>(<span class="calibre5">type</span>(matrix3))<br class="calibre2"/><br class="calibre2"/>tensorForM1 = tf.convert_to_tensor(matrix1, <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/>tensorForM2 = tf.convert_to_tensor(matrix2, <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/>tensorForM3 = tf.convert_to_tensor(matrix3, <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/><br class="calibre2"/><span class="calibre5">print</span>(<span class="calibre5">type</span>(tensorForM1))<br class="calibre2"/><span class="calibre5">print</span>(<span class="calibre5">type</span>(tensorForM2))<br class="calibre2"/><span class="calibre5">print</span>(<span class="calibre5">type</span>(tensorForM3))</pre>
<p class="calibre34"><span class="calibre14">The output of the listing is shown in the following code:</span></p>
<pre class="calibre26">&lt;class 'list'&gt;<br class="calibre2"/>&lt;class 'numpy.ndarray'&gt;<br class="calibre2"/>&lt;class 'tensorflow.python.framework.ops.Tensor'&gt;<br class="calibre2"/>&lt;class 'tensorflow.python.framework.ops.Tensor'&gt;<br class="calibre2"/>&lt;class 'tensorflow.python.framework.ops.Tensor'&gt;<br class="calibre2"/>&lt;class 'tensorflow.python.framework.ops.Tensor'&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Matrix multiplication</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">Matrix multiplication of matrices <em class="calibre17">A</em> and <em class="calibre17">B</em> is a third matrix, <em class="calibre17">C</em>:</p>
<p class="calibre35"><em class="calibre17">C = AB</em></p>
<p class="calibre4">The element-wise product of matrices is called a <strong class="calibre7">Hadamard</strong> product and is denoted as <em class="calibre17">A.B</em>.</p>
<p class="calibre4">The dot product of two vectors <em class="calibre17">x</em> and <em class="calibre17">y</em> of the same dimensionality is the matrix product <em class="calibre17">x</em> transposing <em class="calibre17">y</em>. Matrix product <em class="calibre17">C = AB</em> is like computing <em class="calibre17">C<sub class="calibre36">i,j</sub></em> as the dot product between row <em class="calibre17">i</em> of matrix <em class="calibre17">A</em> and column <em class="calibre17">j</em> of matrix <em class="calibre17">B</em>:</p>
<div class="mce-root1"><img src="Images/39075617-fcce-4cf3-aa3f-33fd65df9288.jpg" width="338" height="113" class="calibre37"/></div>
<p class="calibre4">The following example shows the Hadamard product and dot product using tensor objects:</p>
<pre class="calibre26"><strong class="calibre3">import </strong>tensorflow <strong class="calibre3">as </strong>tf<br class="calibre2"/> <br class="calibre2"/>mat1 = tf.constant([[4, 5, 6],[3,2,1]])<br class="calibre2"/>mat2 = tf.constant([[7, 8, 9],[10, 11, 12]])<br class="calibre2"/> <br class="calibre2"/><em class="calibre29"># hadamard product (element wise)<br class="calibre2"/></em>mult = tf.multiply(mat1, mat2)<br class="calibre2"/> <br class="calibre2"/><em class="calibre29"># dot product (no. of rows = no. of columns)<br class="calibre2"/></em>dotprod = tf.matmul(mat1, tf.transpose(mat2))<br class="calibre2"/> <br class="calibre2"/><strong class="calibre3">with </strong>tf.Session() <strong class="calibre3">as </strong>sess:<br class="calibre2"/>    print(sess.run(mult))<br class="calibre2"/>    print(sess.run(dotprod))</pre>
<p class="calibre34"><span class="calibre14">The output of the listing is shown as follows:</span></p>
<pre class="calibre26">[[28 40 54][30 22 12]]<br class="calibre2"/> [[122 167][ 46 64]]</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Trace operator</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">The trace operator <em class="calibre17">Tr(A)</em> of matrix <em class="calibre17">A</em> gives the sum of all of the diagonal entries of a matrix. The following example shows how to use a trace operator on tensor objects:</p>
<pre class="calibre26"><strong class="calibre3">import </strong>tensorflow <strong class="calibre3">as </strong>tf<br class="calibre2"/><br class="calibre2"/>mat = tf.constant([<br class="calibre2"/> [0, 1, 2],<br class="calibre2"/> [3, 4, 5],<br class="calibre2"/> [6, 7, 8]<br class="calibre2"/>], dtype=tf.float32)<br class="calibre2"/> <br class="calibre2"/> <em class="calibre29"># get trace ('sum of diagonal elements') of the matrix<br class="calibre2"/> </em>mat = tf.trace(mat)<br class="calibre2"/> <br class="calibre2"/> <strong class="calibre3">with </strong>tf.Session() <strong class="calibre3">as </strong>sess:<br class="calibre2"/>    print(sess.run(mat))</pre>
<p class="calibre4">The output of the listing is <em class="calibre17">12.0</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Matrix transpose</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">Transposition of the matrix is the mirror image of the matrix across the main diagonal. A symmetric matrix is any matrix that is equal to its own transpose:</p>
<div class="mce-root2"><img src="Images/8ab26f97-c7f1-4046-9494-9aba9b6d4ac7.jpg" width="476" height="311" class="calibre38"/></div>
<p class="calibre4">The following example shows how to use a transpose operator on tensor objects:</p>
<pre class="calibre26"><strong class="calibre3">import </strong>tensorflow <strong class="calibre3">as </strong>tf<br class="calibre2"/> <br class="calibre2"/>x = [[1,2,3],[4,5,6]]<br class="calibre2"/>x = tf.convert_to_tensor(x)<br class="calibre2"/>xtrans = tf.transpose(x)<br class="calibre2"/> <br class="calibre2"/>y=([[[1,2,3],[6,5,4]],[[4,5,6],[3,6,3]]])<br class="calibre2"/>y = tf.convert_to_tensor(y)<br class="calibre2"/>ytrans = tf.transpose(y, perm=[0, 2, 1])<br class="calibre2"/> <br class="calibre2"/><strong class="calibre3">with </strong>tf.Session() <strong class="calibre3">as </strong>sess:<br class="calibre2"/>   print(sess.run(xtrans))<br class="calibre2"/>   print(sess.run(ytrans))</pre>
<p class="calibre4">The output of the listing is shown as follows:</p>
<pre class="calibre26">[[1 4] [2 5] [3 6]]</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Matrix diagonals</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">Matrices that are diagonal in nature consist mostly of zeros and have non-zero entries only along the main diagonal. Not all diagonal matrices need to be square.</p>
<p class="calibre4">Using the diagonal part operation, we can get the diagonal of a given matrix, and to create a matrix with a given diagonal, we use the <kbd class="calibre18">diag</kbd> operation from <kbd class="calibre18">tensorflow</kbd>. The following e<span class="calibre14">xample shows how to use diagonal operators on tensor objects:</span></p>
<pre class="calibre26"><strong class="calibre3">import </strong>tensorflow <strong class="calibre3">as </strong>tf<br class="calibre2"/> <br class="calibre2"/>mat = tf.constant([<br class="calibre2"/> [0, 1, 2],<br class="calibre2"/> [3, 4, 5],<br class="calibre2"/> [6, 7, 8]<br class="calibre2"/>], dtype=tf.float32)<br class="calibre2"/> <br class="calibre2"/><em class="calibre29"># get diagonal of the matrix<br class="calibre2"/></em>diag_mat = tf.diag_part(mat)<br class="calibre2"/> <br class="calibre2"/><em class="calibre29"># create matrix with given diagonal<br class="calibre2"/></em>mat = tf.diag([1,2,3,4])<br class="calibre2"/> <br class="calibre2"/><strong class="calibre3">with </strong>tf.Session() <strong class="calibre3">as </strong>sess:<br class="calibre2"/>   print(sess.run(diag_mat))<br class="calibre2"/>   print(sess.run(mat))</pre>
<p class="calibre4">The output of this is shown as follows:</p>
<pre class="calibre26"><strong class="calibre3"> </strong>[ 0.  4.  8.]<br class="calibre2"/>[[1 0 0 0][0 2 0 0] [0 0 3 0] [0 0 0 4]]</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Identity matrix</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">An identity matrix is a matrix <em class="calibre17">I</em> that does not change any vector, like <em class="calibre17">V</em>, when multiplied by <em class="calibre17">I</em>.</p>
<p class="calibre4">The following example shows how to get the identity matrix for a given size:</p>
<pre class="calibre26"><strong class="calibre3">import </strong>tensorflow <strong class="calibre3">as </strong>tf<br class="calibre2"/> <br class="calibre2"/>identity = tf.eye(3, 3)<br class="calibre2"/> <br class="calibre2"/><strong class="calibre3">with </strong>tf.Session() <strong class="calibre3">as </strong>sess:<br class="calibre2"/>   print(sess.run(identity))  </pre>
<p class="calibre4">The output of this is shown as follows:</p>
<pre class="calibre26">[[ 1.  0.  0.] [ 0.  1.  0.] [ 0.  0.  1.]]</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Inverse matrix</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">The matrix inverse of <em class="calibre17">I</em> is denoted as <img src="Images/9ce156ad-e34e-4287-bbbf-4fa1480b7702.jpg" width="71" height="63" class="calibre39"/>. Consider the following equation; to solve it using inverse and different values of <em class="calibre17">b</em>, there can be multiple solutions for <em class="calibre17">x</em>. Note the property:</p>
<p class="calibre40"><img src="Images/4264ad0b-4dd1-4598-a383-b37799179877.jpg" width="179" height="63" class="calibre41"/></p>
<p class="calibre40"><strong class="calibre7"><img src="Images/80ef6668-7388-44e3-9008-cb946ffc07b4.jpg" width="271" height="292" class="calibre42"/></strong></p>
<p class="calibre4">The following example shows how to calculate the inverse of a matrix using the <kbd class="calibre18">matrix_inverse</kbd> operation:</p>
<pre class="calibre26"><strong class="calibre3">import </strong>tensorflow <strong class="calibre3">as </strong>tf<br class="calibre2"/> <br class="calibre2"/>mat = tf.constant([[2, 3, 4], [5, 6, 7], [8, 9, 10]], dtype=tf.float32)<br class="calibre2"/>print(mat)<br class="calibre2"/> <br class="calibre2"/>inv_mat = tf.matrix_inverse(tf.transpose(mat))<br class="calibre2"/> <br class="calibre2"/><strong class="calibre3">with </strong>tf.Session() <strong class="calibre3">as </strong>sess:<br class="calibre2"/>print(sess.run(inv_mat))</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Solving linear equations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">TensorFlow can solve a series of linear equations using the <kbd class="calibre18">solve</kbd> operation. Let's first explain this without using the library and later use the <kbd class="calibre18">solve</kbd> function.</p>
<p class="calibre4">A linear equation is represented as follows:</p>
<p class="calibre40"><em class="calibre17">ax + b = yy - ax = b</em></p>
<p class="calibre43"><em class="calibre17">y - ax = b</em></p>
<p class="calibre40"><em class="calibre17">y/b - a/b(x) = 1</em></p>
<p class="calibre4">Our job is to find the values for <em class="calibre17">a</em> and <em class="calibre17">b</em> in the preceding equation, given our observed points. First, create the matrix points. The first column represents <em class="calibre17">x</em> values, while the second column represents <em class="calibre17">y</em> values.<br class="calibre25"/>
Consider that <em class="calibre17">X</em> is the input matrix and <em class="calibre17">A</em> is the parameters that we need to learn; we set up a system like <em class="calibre17">AX=B</em>, therefore, <img src="Images/a545637a-63f7-46c5-b731-43b1fcae9fab.png" width="94" height="33" class="calibre44"/>.<br class="calibre25"/>
The following example, with code, shows how to solve the linear equation:</p>
<p class="calibre43"><em class="calibre17">3x+2y = 15</em><br class="calibre25"/>
<em class="calibre17">4x−y = 10</em></p>
<pre class="calibre26"><span class="calibre5"><strong class="calibre3">import </strong>tensorflow <strong class="calibre3">as </strong>tf<br class="calibre2"/><br class="calibre2"/># equation 1<br class="calibre2"/></span>x1 = tf.constant(<span class="calibre5">3</span>, <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/>y1 = tf.constant(<span class="calibre5">2</span>, <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/>point1 = tf.stack([x1, y1])<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># equation 2<br class="calibre2"/></span>x2 = tf.constant(<span class="calibre5">4</span>, <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/>y2 = tf.constant(-<span class="calibre5">1</span>, <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/>point2 = tf.stack([x2, y2])<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># solve for AX=C<br class="calibre2"/></span>X = tf.transpose(tf.stack([point1, point2]))<br class="calibre2"/>C = tf.ones((<span class="calibre5">1</span>,<span class="calibre5">2</span>), <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/><br class="calibre2"/>A = tf.matmul(C, tf.matrix_inverse(X))<br class="calibre2"/><br class="calibre2"/><span class="calibre5">with </span>tf.Session() <span class="calibre5">as </span>sess:<br class="calibre2"/>    X = sess.run(X)<br class="calibre2"/>    <span class="calibre5">print</span>(X)<br class="calibre2"/><br class="calibre2"/>    A = sess.run(A)<br class="calibre2"/>    <span class="calibre5">print</span>(A)<br class="calibre2"/><br class="calibre2"/>b = <span class="calibre5">1 </span>/ A[<span class="calibre5">0</span>][<span class="calibre5">1</span>]<br class="calibre2"/>a = -b * A[<span class="calibre5">0</span>][<span class="calibre5">0</span>]<br class="calibre2"/><span class="calibre5">print</span>(<span class="calibre5">"Hence Linear Equation is: y = {a}x + {b}"</span>.format(<span class="calibre5">a</span>=a, <span class="calibre5">b</span>=b))</pre>
<p class="calibre4">The output of the listing is shown as follows:</p>
<pre class="calibre26">[[ 3. 4.][ 2. -1.]]<br class="calibre2"/> [[ 0.27272728 0.09090909]]<br class="calibre2"/>Hence Linear Equation is: y = -2.9999999999999996x + 10.999999672174463</pre>
<p class="calibre4">The canonical equation for a circle is <em class="calibre17">x2+y2+dx+ey+f=0</em>; to solve this for the parameters <em class="calibre17">d</em>, <em class="calibre17">e</em>, and <em class="calibre17">f</em>, we use TensorFlow's solve operation as follows:</p>
<pre class="calibre26"><span class="calibre5"># canonical circle equation<br class="calibre2"/></span><span class="calibre5"># x2+y2+dx+ey+f = 0<br class="calibre2"/></span><span class="calibre5"># dx+ey+f=−(x2+y2) ==&gt; AX = B<br class="calibre2"/></span><span class="calibre5"># we have to solve for d, e, f<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span>points = tf.constant([[<span class="calibre5">2</span>,<span class="calibre5">1</span>], [<span class="calibre5">0</span>,<span class="calibre5">5</span>], [-<span class="calibre5">1</span>,<span class="calibre5">2</span>]], <span class="calibre5">dtype</span>=tf.float64)<br class="calibre2"/>X = tf.constant([[<span class="calibre5">2</span>,<span class="calibre5">1</span>,<span class="calibre5">1</span>], [<span class="calibre5">0</span>,<span class="calibre5">5</span>,<span class="calibre5">1</span>], [-<span class="calibre5">1</span>,<span class="calibre5">2</span>,<span class="calibre5">1</span>]], <span class="calibre5">dtype</span>=tf.float64)<br class="calibre2"/>B = -tf.constant([[<span class="calibre5">5</span>], [<span class="calibre5">25</span>], [<span class="calibre5">5</span>]], <span class="calibre5">dtype</span>=tf.float64)<br class="calibre2"/><br class="calibre2"/>A = tf.matrix_solve(X,B)<br class="calibre2"/><br class="calibre2"/><span class="calibre5">with </span>tf.Session() <span class="calibre5">as </span>sess:<br class="calibre2"/>    result = sess.run(A)<br class="calibre2"/>    D, E, F = result.flatten()<br class="calibre2"/>    <span class="calibre5">print</span>(<span class="calibre5">"Hence Circle Equation is: x**2 + y**2 + {D}x + {E}y + {F} = 0"</span>.format(**<span class="calibre5">locals</span>()))</pre>
<p class="calibre4">The output of the listing is shown in the following code:</p>
<pre class="calibre26">Hence Circle Equation is: x**2 + y**2 + -2.0x + -6.0y + 5.0 = 0</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Singular value decomposition</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">When we decompose an integer into its prime factors, we can understand useful properties about the integer. Similarly, when we decompose a matrix, we can understand many functional properties that are not directly evident. There are two types of decomposition, namely eigenvalue decomposition and singular value decomposition.</p>
<p class="calibre4">All real matrices have singular value decomposition, but the same is not true for Eigenvalue decomposition. For example, if a matrix is not square, the Eigen decomposition is not defined and we must use singular value decomposition instead.</p>
<p class="calibre4"><strong class="calibre7">Singular Value Decomposition</strong> (<strong class="calibre7">SVD</strong>) in mathematical form is the product of three matrices <em class="calibre17">U</em>, <em class="calibre17">S</em>, and <em class="calibre17">V</em>, where <em class="calibre17">U</em> is <em class="calibre17">m*r</em>, <em class="calibre17">S</em> is <em class="calibre17">r*r</em> and <em class="calibre17">V</em> is <em class="calibre17">r*n</em>:</p>
<p class="calibre45"><img src="Images/301bd7b9-1332-435f-96c7-96a7d51f1373.jpg" width="279" height="79" class="calibre46"/></p>
<p class="calibre4">The following example shows SVD using a TensorFlow <kbd class="calibre18">svd</kbd> operation on textual data:</p>
<pre class="calibre26"><span class="calibre5">import </span>numpy <span class="calibre5">as </span>np<br class="calibre2"/><span class="calibre5">import </span>tensorflow <span class="calibre5">as </span>tf<br class="calibre2"/><span class="calibre5">import </span>matplotlib.pyplot <span class="calibre5">as </span>plts<br class="calibre2"/><br class="calibre2"/>path = <span class="calibre5">"/neuralnetwork-programming/ch01/plots"<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span>text = [<span class="calibre5">"I"</span>, <span class="calibre5">"like"</span>, <span class="calibre5">"enjoy"</span>,<br class="calibre2"/>         <span class="calibre5">"deep"</span>, <span class="calibre5">"learning"</span>, <span class="calibre5">"NLP"</span>, <span class="calibre5">"flying"</span>, <span class="calibre5">"."</span>]<br class="calibre2"/>xMatrix = np.array([[<span class="calibre5">0</span>,<span class="calibre5">2</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>],<br class="calibre2"/>              [<span class="calibre5">2</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>],<br class="calibre2"/>              [<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>],<br class="calibre2"/>              [<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>],<br class="calibre2"/>              [<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>],<br class="calibre2"/>              [<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>],<br class="calibre2"/>              [<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>],<br class="calibre2"/>              [<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">1</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>]], <span class="calibre5">dtype</span>=np.float32)<br class="calibre2"/><br class="calibre2"/>X_tensor = tf.convert_to_tensor(xMatrix, <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># tensorflow svd<br class="calibre2"/></span><span class="calibre5">with </span>tf.Session() <span class="calibre5">as </span>sess:<br class="calibre2"/>    s, U, Vh = sess.run(tf.svd(X_tensor, <span class="calibre5">full_matrices</span>=<span class="calibre5">False</span>))<br class="calibre2"/><br class="calibre2"/><span class="calibre5">for </span>i <span class="calibre5">in </span><span class="calibre5">range</span>(<span class="calibre5">len</span>(text)):<br class="calibre2"/>    plts.text(U[i,<span class="calibre5">0</span>], U[i,<span class="calibre5">1</span>], text[i])<br class="calibre2"/><br class="calibre2"/>plts.ylim(-<span class="calibre5">0.8</span>,<span class="calibre5">0.8</span>)<br class="calibre2"/>plts.xlim(-<span class="calibre5">0.8</span>,<span class="calibre5">2.0</span>)<br class="calibre2"/>plts.savefig(path + <span class="calibre5">'/svd_tf.png'</span>)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># numpy svd<br class="calibre2"/></span>la = np.<span class="calibre5">linalg</span><br class="calibre2"/>U, s, Vh = la.svd(xMatrix, <span class="calibre5">full_matrices</span>=<span class="calibre5">False</span>)<br class="calibre2"/><br class="calibre2"/><span class="calibre5">print</span>(U)<br class="calibre2"/><span class="calibre5">print</span>(s)<br class="calibre2"/><span class="calibre5">print</span>(Vh)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># write matrices to file (understand concepts)<br class="calibre2"/></span>file = <span class="calibre5">open</span>(path + <span class="calibre5">"/matx.txt"</span>, <span class="calibre5">'w'</span>)<br class="calibre2"/>file.write(<span class="calibre5">str</span>(U))<br class="calibre2"/>file.write(<span class="calibre5">"</span><span class="calibre5">\n</span><span class="calibre5">"</span>)<br class="calibre2"/>file.write(<span class="calibre5">"============="</span>)<br class="calibre2"/>file.write(<span class="calibre5">"</span><span class="calibre5">\n</span><span class="calibre5">"</span>)<br class="calibre2"/>file.write(<span class="calibre5">str</span>(s))<br class="calibre2"/>file.close()<br class="calibre2"/><br class="calibre2"/><span class="calibre5">for </span>i <span class="calibre5">in </span><span class="calibre5">range</span>(<span class="calibre5">len</span>(text)):<br class="calibre2"/>    plts.text(U[i,<span class="calibre5">0</span>], U[i,<span class="calibre5">1</span>], text[i])<br class="calibre2"/><br class="calibre2"/>plts.ylim(-<span class="calibre5">0.8</span>,<span class="calibre5">0.8</span>)<br class="calibre2"/>plts.xlim(-<span class="calibre5">0.8</span>,<span class="calibre5">2.0</span>)<br class="calibre2"/>plts.savefig(path + <span class="calibre5">'/svd_np.png'</span>)</pre>
<p class="calibre4">The output of this is shown as follows:</p>
<pre class="calibre26">[[ -5.24124920e-01  -5.72859168e-01   9.54463035e-02   3.83228481e-01   -1.76963374e-01  -1.76092178e-01  -4.19185609e-01  -5.57702743e-02]<br class="calibre2"/>[ -5.94438076e-01   6.30120635e-01  -1.70207784e-01   3.10038358e-0<br class="calibre2"/> 1.84062332e-01  -2.34777853e-01   1.29535481e-01   1.36813134e-01]<br class="calibre2"/>[ -2.56274015e-01   2.74017543e-01   1.59810841e-01   3.73903001e-16<br class="calibre2"/>  -5.78984618e-01   6.36550903e-01  -3.32297325e-16  -3.05414885e-01]<br class="calibre2"/>[ -2.85637408e-01  -2.47912124e-01   3.54610324e-01  -7.31901303e-02<br class="calibre2"/>  4.45784479e-01   8.36141407e-02   5.48721075e-01  -4.68012422e-01]<br class="calibre2"/>[ -1.93139315e-01   3.38495038e-02  -5.00790417e-01  -4.28462476e-01<br class="calibre2"/> 3.47110212e-01   1.55483231e-01  -4.68663752e-01  -4.03576553e-01]<br class="calibre2"/>[ -3.05134684e-01  -2.93989003e-01  -2.23433599e-01  -1.91614240e-01<br class="calibre2"/> 1.27460942e-01   4.91219401e-01   2.09592804e-01   6.57535374e-01]<br class="calibre2"/>[ -1.82489842e-01  -1.61027774e-01  -3.97842437e-01  -3.83228481e-01<br class="calibre2"/> -5.12923241e-01  -4.27574426e-01   4.19185609e-01  -1.18313827e-01]<br class="calibre2"/>[ -2.46898428e-01   1.57254755e-01   5.92991650e-01  -6.20076716e-01<br class="calibre2"/> -3.21868137e-02  -2.31065080e-01  -2.59070963e-01   2.37976909e-01]]<br class="calibre2"/>[ 2.75726271  2.67824793  1.89221275  1.61803401  1.19154561  0.94833982<br class="calibre2"/> 0.61803401  0.56999218]<br class="calibre2"/>[[ -5.24124920e-01  -5.94438076e-01  -2.56274015e-01  -2.85637408e-01<br class="calibre2"/> -1.93139315e-01  -3.05134684e-01  -1.82489842e-01  -2.46898428e-01]<br class="calibre2"/>[  5.72859168e-01  -6.30120635e-01  -2.74017543e-01   2.47912124e-01<br class="calibre2"/> -3.38495038e-02   2.93989003e-01   1.61027774e-01  -1.57254755e-01]<br class="calibre2"/>[ -9.54463035e-02   1.70207784e-01  -1.59810841e-01  -3.54610324e-01<br class="calibre2"/> 5.00790417e-01   2.23433599e-01   3.97842437e-01  -5.92991650e-01]<br class="calibre2"/>[  3.83228481e-01   3.10038358e-01  -2.22044605e-16  -7.31901303e-02<br class="calibre2"/> -4.28462476e-01  -1.91614240e-01  -3.83228481e-01  -6.20076716e-01]<br class="calibre2"/>[ -1.76963374e-01   1.84062332e-01  -5.78984618e-01   4.45784479e-01<br class="calibre2"/> 3.47110212e-01   1.27460942e-01  -5.12923241e-01  -3.21868137e-02]<br class="calibre2"/>[  1.76092178e-01   2.34777853e-01  -6.36550903e-01  -8.36141407e-02<br class="calibre2"/> -1.55483231e-01  -4.91219401e-01   4.27574426e-01   2.31065080e-01]<br class="calibre2"/>[  4.19185609e-01  -1.29535481e-01  -3.33066907e-16  -5.48721075e-01<br class="calibre2"/>  4.68663752e-01  -2.09592804e-01  -4.19185609e-01   2.59070963e-01]<br class="calibre2"/>[ -5.57702743e-02   1.36813134e-01  -3.05414885e-01  -4.68012422e-01<br class="calibre2"/> -4.03576553e-01   6.57535374e-01  -1.18313827e-01   2.37976909e-01]]</pre>
<p class="calibre4">Here is the plot for the SVD of the preceding dataset:</p>
<div class="mce-root"><img src="Images/f312b60a-53ca-4019-b53b-800ec1019c19.png" width="726" height="544" class="calibre47"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Eigenvalue decomposition</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">Eigen decomposition is one of the most famous decomposition techniques in which we decompose a matrix into a set of eigenvectors and eigenvalues.</p>
<p class="calibre4">For a square matrix, Eigenvector is a vector <em class="calibre17">v</em> such that multiplication by <em class="calibre17">A</em> alters only the scale of <em class="calibre17">v</em>:</p>
<p class="calibre43"><em class="calibre17">Av = λv</em></p>
<p class="calibre4">The scalar <em class="calibre17">λ</em> is known as the eigenvalue corresponding to this eigenvector.</p>
<p class="calibre4">Eigen decomposition of <em class="calibre17">A</em> is then given as follows:</p>
<p class="calibre48"><img src="Images/9fb009f4-4519-4f74-af40-922704ca0d3d.jpg" width="363" height="83" class="calibre49"/></p>
<p class="calibre4">Eigen decomposition of a matrix describes many useful details about the matrix. For example, the matrix is singular if, and only if, any of the eigenvalues are zero.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Principal Component Analysis</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4"><strong class="calibre7">Principal Component Analysis</strong> (<strong class="calibre7">PCA</strong>) projects the given dataset onto a lower dimensional linear space so that the variance of the projected data is maximized. PCA requires the eigenvalues and eigenvectors of the covariance matrix, which is the product where <em class="calibre17">X</em> is the data matrix.</p>
<p class="calibre4">SVD on the data matrix <em class="calibre17">X</em> is given as follows:</p>
<p class="calibre48"><img src="Images/6384841b-c4e6-4684-8e8d-bd4f8848d008.jpg" width="567" height="508" class="calibre50"/></p>
<p class="calibre4">The following example shows PCA using SVD:</p>
<pre class="calibre26"><span class="calibre5">import </span>numpy <span class="calibre5">as </span>np<br class="calibre2"/><span class="calibre5">import </span>tensorflow <span class="calibre5">as </span>tf<br class="calibre2"/><span class="calibre5">import </span>matplotlib.pyplot <span class="calibre5">as </span>plt<br class="calibre2"/><span class="calibre5">import </span>plotly.plotly <span class="calibre5">as </span>py<br class="calibre2"/><span class="calibre5">import </span>plotly.graph_objs <span class="calibre5">as </span>go<br class="calibre2"/><span class="calibre5">import </span>plotly.figure_factory <span class="calibre5">as </span>FF<br class="calibre2"/><span class="calibre5">import </span>pandas <span class="calibre5">as </span>pd<br class="calibre2"/><br class="calibre2"/>path = <span class="calibre5">"/neuralnetwork-programming/ch01/plots"<br class="calibre2"/></span>logs = <span class="calibre5">"/neuralnetwork-programming/ch01/logs"<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span>xMatrix = np.array([[<span class="calibre5">0</span>,<span class="calibre5">2</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>],<br class="calibre2"/>              [<span class="calibre5">2</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>],<br class="calibre2"/>              [<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>],<br class="calibre2"/>              [<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>],<br class="calibre2"/>              [<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>],<br class="calibre2"/>              [<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>],<br class="calibre2"/>              [<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>],<br class="calibre2"/>              [<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">0</span>,<span class="calibre5">1</span>,<span class="calibre5">1</span>,<span class="calibre5">1</span>,<span class="calibre5">0</span>]], <span class="calibre5">dtype</span>=np.float32)<br class="calibre2"/><br class="calibre2"/><span class="calibre5">def </span>pca(mat):<br class="calibre2"/>    mat = tf.constant(mat, <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/>    mean = tf.reduce_mean(mat, <span class="calibre5">0</span>)<br class="calibre2"/>    less = mat - mean<br class="calibre2"/>    s, u, v = tf.svd(less, <span class="calibre5">full_matrices</span>=<span class="calibre5">True</span>, <span class="calibre5">compute_uv</span>=<span class="calibre5">True</span>)<br class="calibre2"/><br class="calibre2"/>    s2 = s ** <span class="calibre5">2<br class="calibre2"/></span><span class="calibre5">    </span>variance_ratio = s2 / tf.reduce_sum(s2)<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">with </span>tf.Session() <span class="calibre5">as </span>session:<br class="calibre2"/>        run = session.run([variance_ratio])<br class="calibre2"/>    <span class="calibre5">return </span>run<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/><span class="calibre5">if </span>__name__ == <span class="calibre5">'__main__'</span>:<br class="calibre2"/>    <span class="calibre5">print</span>(pca(xMatrix))</pre>
<p class="calibre4">The output of the listing is shown as follows:</p>
<pre class="calibre26">[array([  4.15949494e-01,   2.08390564e-01,   1.90929279e-01,<br class="calibre2"/>         8.36438537e-02,   5.55494241e-02,   2.46047471e-02,<br class="calibre2"/>         2.09326427e-02,   3.57540098e-16], dtype=float32)]</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Calculus</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">Topics in the previous sections are covered as part of standard linear algebra; something that wasn't covered is basic calculus. Despite the fact that the calculus that we use is relatively simple, the mathematical form of it may look very complex. In this section, we present some basic forms of matrix calculus with a few examples.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Gradient</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">Gradient for functions with respect to a real-valued matrix <em class="calibre17">A</em> is defined as the matrix of partial derivatives of <em class="calibre17">A</em> and is denoted as follows:</p>
<p class="calibre51"><img src="Images/d459ff93-d4b1-45a4-98ec-09be902ff273.jpg" width="1013" height="542" class="calibre52"/></p>
<p class="calibre53"><img src="Images/57cf3a28-13d4-4e38-9564-c0625d794ef5.jpg" width="446" height="154" class="calibre54"/></p>
<p class="calibre4">TensorFlow does not do numerical differentiation; rather, it supports automatic differentiation. By specifying operations in a TensorFlow graph, it can automatically run the chain rule through the graph and, as it knows the derivatives of each operation we specify, it can combine them automatically.</p>
<p class="calibre4">The following example shows training a network using MNIST data, the MNIST database consists of handwritten digits. It has a training set of 60,000 examples and a test set of 10,000 samples. The digits are size-normalized.</p>
<p class="calibre4">Here backpropagation is performed without any API usage and derivatives are calculated manually. We get 913 correct out of 1,000 tests. This concept will be introduced in the next chapter.</p>
<p class="calibre4">The following code snippet describes how to get the <kbd class="calibre18">mnist</kbd> dataset and initialize weights and biases:</p>
<pre class="calibre26"><span class="calibre5">import </span>tensorflow <span class="calibre5">as </span>tf<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># get mnist dataset<br class="calibre2"/></span><span class="calibre5">from </span>tensorflow.examples.tutorials.mnist <span class="calibre5">import </span>input_data<br class="calibre2"/>data = input_data.read_data_sets(<span class="calibre5">"MNIST_data/"</span>, <span class="calibre5">one_hot</span>=<span class="calibre5">True</span>)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># x represents image with 784 values as columns (28*28), y represents output digit<br class="calibre2"/></span>x = tf.placeholder(tf.float32, [<span class="calibre5">None</span>, <span class="calibre5">784</span>])<br class="calibre2"/>y = tf.placeholder(tf.float32, [<span class="calibre5">None</span>, <span class="calibre5">10</span>])<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># initialize weights and biases [w1,b1][w2,b2]<br class="calibre2"/></span>numNeuronsInDeepLayer = <span class="calibre5">30<br class="calibre2"/></span>w1 = tf.Variable(tf.truncated_normal([<span class="calibre5">784</span>, numNeuronsInDeepLayer]))<br class="calibre2"/>b1 = tf.Variable(tf.truncated_normal([<span class="calibre5">1</span>, numNeuronsInDeepLayer]))<br class="calibre2"/>w2 = tf.Variable(tf.truncated_normal([numNeuronsInDeepLayer, <span class="calibre5">10</span>]))<br class="calibre2"/>b2 = tf.Variable(tf.truncated_normal([<span class="calibre5">1</span>, <span class="calibre5">10</span>]))</pre>
<p class="calibre4">We now define a two-layered network with a nonlinear <kbd class="calibre18">sigmoid</kbd> function; a squared loss function is applied and optimized using a backward propagation algorithm, as shown in the following snippet:</p>
<pre class="calibre26"><span class="calibre5"># non-linear sigmoid function at each neuron<br class="calibre2"/></span><span class="calibre5">def </span>sigmoid(x):<br class="calibre2"/>    sigma = tf.div(tf.constant(<span class="calibre5">1.0</span>), tf.add(tf.constant(<span class="calibre5">1.0</span>), tf.exp(tf.negative(x))))<br class="calibre2"/>    <span class="calibre5">return </span>sigma<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># starting from first layer with wx+b, then apply sigmoid to add non-linearity<br class="calibre2"/></span>z1 = tf.add(tf.matmul(x, w1), b1)<br class="calibre2"/>a1 = sigmoid(z1)<br class="calibre2"/>z2 = tf.add(tf.matmul(a1, w2), b2)<br class="calibre2"/>a2 = sigmoid(z2)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># calculate the loss (delta)<br class="calibre2"/></span>loss = tf.subtract(a2, y)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># derivative of the sigmoid function der(sigmoid)=sigmoid*(1-sigmoid)<br class="calibre2"/></span><span class="calibre5">def </span>sigmaprime(x):<br class="calibre2"/>    <span class="calibre5">return </span>tf.multiply(sigmoid(x), tf.subtract(tf.constant(<span class="calibre5">1.0</span>), sigmoid(x)))<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># backward propagation<br class="calibre2"/></span>dz2 = tf.multiply(loss, sigmaprime(z2))<br class="calibre2"/>db2 = dz2<br class="calibre2"/>dw2 = tf.matmul(tf.transpose(a1), dz2)<br class="calibre2"/><br class="calibre2"/>da1 = tf.matmul(dz2, tf.transpose(w2))<br class="calibre2"/>dz1 = tf.multiply(da1, sigmaprime(z1))<br class="calibre2"/>db1 = dz1<br class="calibre2"/>dw1 = tf.matmul(tf.transpose(x), dz1)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># finally update the network<br class="calibre2"/></span>eta = tf.constant(<span class="calibre5">0.5</span>)<br class="calibre2"/>step = [<br class="calibre2"/>    tf.assign(w1,<br class="calibre2"/>              tf.subtract(w1, tf.multiply(eta, dw1)))<br class="calibre2"/>    , tf.assign(b1,<br class="calibre2"/>                tf.subtract(b1, tf.multiply(eta,<br class="calibre2"/>                                             tf.reduce_mean(db1, <span class="calibre5">axis</span>=[<span class="calibre5">0</span>]))))<br class="calibre2"/>    , tf.assign(w2,<br class="calibre2"/>                tf.subtract(w2, tf.multiply(eta, dw2)))<br class="calibre2"/>    , tf.assign(b2,<br class="calibre2"/>                tf.subtract(b2, tf.multiply(eta,<br class="calibre2"/>                                             tf.reduce_mean(db2, <span class="calibre5">axis</span>=[<span class="calibre5">0</span>]))))<br class="calibre2"/>]<br class="calibre2"/><br class="calibre2"/>acct_mat = tf.equal(tf.argmax(a2, <span class="calibre5">1</span>), tf.argmax(y, <span class="calibre5">1</span>))<br class="calibre2"/>acct_res = tf.reduce_sum(tf.cast(acct_mat, tf.float32))<br class="calibre2"/><br class="calibre2"/>sess = tf.InteractiveSession()<br class="calibre2"/>sess.run(tf.global_variables_initializer())<br class="calibre2"/><br class="calibre2"/><span class="calibre5">for </span>i <span class="calibre5">in </span><span class="calibre5">range</span>(<span class="calibre5">10000</span>):<br class="calibre2"/>    batch_xs, batch_ys = data.train.next_batch(<span class="calibre5">10</span>)<br class="calibre2"/>    sess.run(step, <span class="calibre5">feed_dict</span>={x: batch_xs,<br class="calibre2"/>                              y: batch_ys})<br class="calibre2"/>    <span class="calibre5">if </span>i % <span class="calibre5">1000 </span>== <span class="calibre5">0</span>:<br class="calibre2"/>        res = sess.run(acct_res, <span class="calibre5">feed_dict</span>=<br class="calibre2"/>        {x: data.test.images[:<span class="calibre5">1000</span>],<br class="calibre2"/>         y: data.test.labels[:<span class="calibre5">1000</span>]})<br class="calibre2"/>        <span class="calibre5">print</span>(res)</pre>
<p class="calibre4">The output of this is shown as follows:</p>
<pre class="calibre26">Extracting MNIST_data<br class="calibre2"/>125.0<br class="calibre2"/>814.0<br class="calibre2"/>870.0<br class="calibre2"/>874.0<br class="calibre2"/>889.0<br class="calibre2"/>897.0<br class="calibre2"/>906.0<br class="calibre2"/>903.0<br class="calibre2"/>922.0<br class="calibre2"/>913.0</pre>
<p class="calibre4">Now, let's use automatic differentiation with TensorFlow. The following example demonstrates the use of <span class="calibre14"><kbd class="calibre18">GradientDescentOptimizer</kbd>.</span> We get 924 correct out of 1,000 tests.</p>
<pre class="calibre26"><span class="calibre5">import </span><span class="calibre5">tensorflow</span> <span class="calibre5">as </span>tf<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># get mnist dataset<br class="calibre2"/></span><span class="calibre5">from </span><span class="calibre5">tensorflow</span>.examples.tutorials.mnist <span class="calibre5">import </span>input_data<br class="calibre2"/>data = input_data.read_data_sets(<span class="calibre5">"MNIST_data/"</span>, <span class="calibre5">one_hot</span>=<span class="calibre5">True</span>)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># x represents image with 784 values as columns (28*28), y represents output digit<br class="calibre2"/></span>x = tf.placeholder(tf.float32, [<span class="calibre5">None</span>, <span class="calibre5">784</span>])<br class="calibre2"/>y = tf.placeholder(tf.float32, [<span class="calibre5">None</span>, <span class="calibre5">10</span>])<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># initialize weights and biases [w1,b1][w2,b2]<br class="calibre2"/></span>numNeuronsInDeepLayer = <span class="calibre5">30<br class="calibre2"/></span>w1 = tf.Variable(tf.truncated_normal([<span class="calibre5">784</span>, numNeuronsInDeepLayer]))<br class="calibre2"/>b1 = tf.Variable(tf.truncated_normal([<span class="calibre5">1</span>, numNeuronsInDeepLayer]))<br class="calibre2"/>w2 = tf.Variable(tf.truncated_normal([numNeuronsInDeepLayer, <span class="calibre5">10</span>]))<br class="calibre2"/>b2 = tf.Variable(tf.truncated_normal([<span class="calibre5">1</span>, <span class="calibre5">10</span>]))<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># non-linear sigmoid function at each neuron<br class="calibre2"/></span><span class="calibre5">def </span>sigmoid(x):<br class="calibre2"/>    sigma = tf.div(tf.constant(<span class="calibre5">1.0</span>), tf.add(tf.constant(<span class="calibre5">1.0</span>), tf.exp(tf.negative(x))))<br class="calibre2"/>    <span class="calibre5">return </span>sigma<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># starting from first layer with wx+b, then apply sigmoid to add non-linearity<br class="calibre2"/></span>z1 = tf.add(tf.matmul(x, w1), b1)<br class="calibre2"/>a1 = sigmoid(z1)<br class="calibre2"/>z2 = tf.add(tf.matmul(a1, w2), b2)<br class="calibre2"/>a2 = sigmoid(z2)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># calculate the loss (delta)<br class="calibre2"/></span>loss = tf.subtract(a2, y)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># derivative of the sigmoid function der(sigmoid)=sigmoid*(1-sigmoid)<br class="calibre2"/></span><span class="calibre5">def </span>sigmaprime(x):<br class="calibre2"/>    <span class="calibre5">return </span>tf.multiply(sigmoid(x), tf.subtract(tf.constant(<span class="calibre5">1.0</span>), sigmoid(x)))<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># automatic differentiation<br class="calibre2"/></span>cost = tf.multiply(loss, loss)<br class="calibre2"/>step = tf.train.GradientDescentOptimizer(<span class="calibre5">0.1</span>).minimize(cost)<br class="calibre2"/><br class="calibre2"/>acct_mat = tf.equal(tf.argmax(a2, <span class="calibre5">1</span>), tf.argmax(y, <span class="calibre5">1</span>))<br class="calibre2"/>acct_res = tf.reduce_sum(tf.cast(acct_mat, tf.float32))<br class="calibre2"/><br class="calibre2"/>sess = tf.InteractiveSession()<br class="calibre2"/>sess.run(tf.global_variables_initializer())<br class="calibre2"/><br class="calibre2"/><span class="calibre5">for </span>i <span class="calibre5">in </span><span class="calibre5">range</span>(<span class="calibre5">10000</span>):<br class="calibre2"/>    batch_xs, batch_ys = data.train.next_batch(<span class="calibre5">10</span>)<br class="calibre2"/>    sess.run(step, <span class="calibre5">feed_dict</span>={x: batch_xs,<br class="calibre2"/>                              y: batch_ys})<br class="calibre2"/>    <span class="calibre5">if </span>i % <span class="calibre5">1000 </span>== <span class="calibre5">0</span>:<br class="calibre2"/>        res = sess.run(acct_res, <span class="calibre5">feed_dict</span>=<br class="calibre2"/>        {x: data.test.images[:<span class="calibre5">1000</span>],<br class="calibre2"/>         y: data.test.labels[:<span class="calibre5">1000</span>]})<br class="calibre2"/>        <span class="calibre5">print</span>(res)</pre>
<p class="calibre4">The output of this is shown as follows:</p>
<pre class="calibre26">96.0<br class="calibre2"/> 777.0<br class="calibre2"/> 862.0<br class="calibre2"/> 870.0<br class="calibre2"/> 889.0<br class="calibre2"/> 901.0<br class="calibre2"/> 911.0<br class="calibre2"/> 905.0<br class="calibre2"/> 914.0<br class="calibre2"/> 924.0</pre>
<p class="calibre4">The following example shows linear regression using gradient descent:</p>
<pre class="calibre26"><span class="calibre5">import </span>tensorflow <span class="calibre5">as </span>tf<br class="calibre2"/><span class="calibre5">import </span><span class="calibre5">numpy</span><br class="calibre2"/><span class="calibre5">import </span>matplotlib.pyplot <span class="calibre5">as </span>plt<br class="calibre2"/>rndm = <span class="calibre5">numpy</span>.random<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># config parameters<br class="calibre2"/></span>learningRate = <span class="calibre5">0.01<br class="calibre2"/></span>trainingEpochs = <span class="calibre5">1000<br class="calibre2"/></span>displayStep = <span class="calibre5">50<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5"># create the training data<br class="calibre2"/></span>trainX = <span class="calibre5">numpy</span>.asarray([<span class="calibre5">3.3</span>,<span class="calibre5">4.4</span>,<span class="calibre5">5.5</span>,<span class="calibre5">6.71</span>,<span class="calibre5">6.93</span>,<span class="calibre5">4.168</span>,<span class="calibre5">9.779</span>,<span class="calibre5">6.182</span>,<span class="calibre5">7.59</span>,<span class="calibre5">2.167</span>,<br class="calibre2"/>                         <span class="calibre5">7.042</span>,<span class="calibre5">10.791</span>,<span class="calibre5">5.313</span>,<span class="calibre5">7.997</span>,<span class="calibre5">5.654</span>,<span class="calibre5">9.27</span>,<span class="calibre5">3.12</span>])<br class="calibre2"/>trainY = <span class="calibre5">numpy</span>.asarray([<span class="calibre5">1.7</span>,<span class="calibre5">2.76</span>,<span class="calibre5">2.09</span>,<span class="calibre5">3.19</span>,<span class="calibre5">1.694</span>,<span class="calibre5">1.573</span>,<span class="calibre5">3.366</span>,<span class="calibre5">2.596</span>,<span class="calibre5">2.53</span>,<span class="calibre5">1.221</span>,<br class="calibre2"/>                         <span class="calibre5">2.827</span>,<span class="calibre5">3.465</span>,<span class="calibre5">1.65</span>,<span class="calibre5">2.904</span>,<span class="calibre5">2.42</span>,<span class="calibre5">2.94</span>,<span class="calibre5">1.34</span>])<br class="calibre2"/>nSamples = trainX.shape[<span class="calibre5">0</span>]<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># tf inputs<br class="calibre2"/></span>X = tf.placeholder(<span class="calibre5">"float"</span>)<br class="calibre2"/>Y = tf.placeholder(<span class="calibre5">"float"</span>)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># initialize weights and bias<br class="calibre2"/></span>W = tf.Variable(rndm.randn(), <span class="calibre5">name</span>=<span class="calibre5">"weight"</span>)<br class="calibre2"/>b = tf.Variable(rndm.randn(), <span class="calibre5">name</span>=<span class="calibre5">"bias"</span>)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># linear model<br class="calibre2"/></span>linearModel = tf.add(tf.multiply(X, W), b)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># mean squared error<br class="calibre2"/></span>loss = tf.reduce_sum(tf.pow(linearModel-Y, <span class="calibre5">2</span>))/(<span class="calibre5">2</span>*nSamples)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># Gradient descent<br class="calibre2"/></span>opt = tf.train.GradientDescentOptimizer(learningRate).minimize(loss)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># initializing variables<br class="calibre2"/></span>init = tf.global_variables_initializer()<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># run<br class="calibre2"/></span><span class="calibre5">with </span>tf.Session() <span class="calibre5">as </span>sess:<br class="calibre2"/>    sess.run(init)<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5"># fitting the training data<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">for </span>epoch <span class="calibre5">in </span><span class="calibre5">range</span>(trainingEpochs):<br class="calibre2"/>        <span class="calibre5">for </span>(x, y) <span class="calibre5">in </span><span class="calibre5">zip</span>(trainX, trainY):<br class="calibre2"/>            sess.run(opt, <span class="calibre5">feed_dict</span>={X: x, Y: y})<br class="calibre2"/><br class="calibre2"/>        <span class="calibre5"># print logs<br class="calibre2"/></span><span class="calibre5">        </span><span class="calibre5">if </span>(epoch+<span class="calibre5">1</span>) % displayStep == <span class="calibre5">0</span>:<br class="calibre2"/>            c = sess.run(loss, <span class="calibre5">feed_dict</span>={X: trainX, Y:trainY})<br class="calibre2"/>            <span class="calibre5">print</span>(<span class="calibre5">"Epoch is:"</span>, <span class="calibre5">'%04d' </span>% (epoch+<span class="calibre5">1</span>), <span class="calibre5">"loss="</span>, <span class="calibre5">"{:.9f}"</span>.format(c), <span class="calibre5">"W="</span>, sess.run(W), <span class="calibre5">"b="</span>, sess.run(b))<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">print</span>(<span class="calibre5">"optimization done..."</span>)<br class="calibre2"/>    trainingLoss = sess.run(loss, <span class="calibre5">feed_dict</span>={X: trainX, Y: trainY})<br class="calibre2"/>    <span class="calibre5">print</span>(<span class="calibre5">"Training loss="</span>, trainingLoss, <span class="calibre5">"W="</span>, sess.run(W), <span class="calibre5">"b="</span>, sess.run(b), <span class="calibre5">'</span><span class="calibre5">\n</span><span class="calibre5">'</span>)<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5"># display the plot<br class="calibre2"/></span><span class="calibre5">    </span>plt.plot(trainX, trainY, <span class="calibre5">'ro'</span>, <span class="calibre5">label</span>=<span class="calibre5">'Original data'</span>)<br class="calibre2"/>    plt.plot(trainX, sess.run(W) * trainX + sess.run(b), <span class="calibre5">label</span>=<span class="calibre5">'Fitted line'</span>)<br class="calibre2"/>    plt.legend()<br class="calibre2"/>    plt.show()<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5"># Testing example, as requested (Issue #2)<br class="calibre2"/></span><span class="calibre5">    </span>testX = <span class="calibre5">numpy</span>.asarray([<span class="calibre5">6.83</span>, <span class="calibre5">4.668</span>, <span class="calibre5">8.9</span>, <span class="calibre5">7.91</span>, <span class="calibre5">5.7</span>, <span class="calibre5">8.7</span>, <span class="calibre5">3.1</span>, <span class="calibre5">2.1</span>])<br class="calibre2"/>    testY = <span class="calibre5">numpy</span>.asarray([<span class="calibre5">1.84</span>, <span class="calibre5">2.273</span>, <span class="calibre5">3.2</span>, <span class="calibre5">2.831</span>, <span class="calibre5">2.92</span>, <span class="calibre5">3.24</span>, <span class="calibre5">1.35</span>, <span class="calibre5">1.03</span>])<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5">print</span>(<span class="calibre5">"Testing... (Mean square loss Comparison)"</span>)<br class="calibre2"/>    testing_cost = sess.run(<br class="calibre2"/>        tf.reduce_sum(tf.pow(linearModel - Y, <span class="calibre5">2</span>)) / (<span class="calibre5">2 </span>* testX.shape[<span class="calibre5">0</span>]),<br class="calibre2"/>        <span class="calibre5">feed_dict</span>={X: testX, Y: testY})<br class="calibre2"/>    <span class="calibre5">print</span>(<span class="calibre5">"Testing cost="</span>, testing_cost)<br class="calibre2"/>    <span class="calibre5">print</span>(<span class="calibre5">"Absolute mean square loss difference:"</span>, <span class="calibre5">abs</span>(trainingLoss - testing_cost))<br class="calibre2"/><br class="calibre2"/>    plt.plot(testX, testY, <span class="calibre5">'bo'</span>, <span class="calibre5">label</span>=<span class="calibre5">'Testing data'</span>)<br class="calibre2"/>    plt.plot(trainX, sess.run(W) * trainX + sess.run(b), <span class="calibre5">label</span>=<span class="calibre5">'Fitted line'</span>)<br class="calibre2"/>    plt.legend()<br class="calibre2"/>    plt.show()</pre>
<p class="calibre4">The output of this is shown as follows:</p>
<pre class="calibre26">Epoch is: 0050 loss= 0.141912043 W= 0.10565 b= 1.8382<br class="calibre2"/> Epoch is: 0100 loss= 0.134377643 W= 0.11413 b= 1.7772<br class="calibre2"/> Epoch is: 0150 loss= 0.127711013 W= 0.122106 b= 1.71982<br class="calibre2"/> Epoch is: 0200 loss= 0.121811897 W= 0.129609 b= 1.66585<br class="calibre2"/> Epoch is: 0250 loss= 0.116592340 W= 0.136666 b= 1.61508<br class="calibre2"/> Epoch is: 0300 loss= 0.111973859 W= 0.143304 b= 1.56733<br class="calibre2"/> Epoch is: 0350 loss= 0.107887231 W= 0.149547 b= 1.52241<br class="calibre2"/> Epoch is: 0400 loss= 0.104270980 W= 0.15542 b= 1.48017<br class="calibre2"/> Epoch is: 0450 loss= 0.101070963 W= 0.160945 b= 1.44043<br class="calibre2"/> Epoch is: 0500 loss= 0.098239250 W= 0.166141 b= 1.40305<br class="calibre2"/> Epoch is: 0550 loss= 0.095733419 W= 0.171029 b= 1.36789<br class="calibre2"/> Epoch is: 0600 loss= 0.093516059 W= 0.175626 b= 1.33481<br class="calibre2"/> Epoch is: 0650 loss= 0.091553882 W= 0.179951 b= 1.3037<br class="calibre2"/> Epoch is: 0700 loss= 0.089817807 W= 0.184018 b= 1.27445<br class="calibre2"/> Epoch is: 0750 loss= 0.088281371 W= 0.187843 b= 1.24692<br class="calibre2"/> Epoch is: 0800 loss= 0.086921677 W= 0.191442 b= 1.22104<br class="calibre2"/> Epoch is: 0850 loss= 0.085718453 W= 0.194827 b= 1.19669<br class="calibre2"/> Epoch is: 0900 loss= 0.084653646 W= 0.198011 b= 1.17378<br class="calibre2"/> Epoch is: 0950 loss= 0.083711281 W= 0.201005 b= 1.15224<br class="calibre2"/> Epoch is: 1000 loss= 0.082877308 W= 0.203822 b= 1.13198<br class="calibre2"/> optimization done...<br class="calibre2"/> Training loss= 0.0828773 W= 0.203822 b= 1.13198<br class="calibre2"/>Testing... (Mean square loss Comparison)<br class="calibre2"/> Testing cost= 0.0957726<br class="calibre2"/> Absolute mean square loss difference: 0.0128952</pre>
<p class="calibre4">The plots are as follows:</p>
<div class="mce-root"><img src="Images/733b0660-6367-48b9-bf7d-b597645e9649.png" width="820" height="621" class="calibre55"/></div>
<p class="calibre4">The following image shows the fitted line on testing data using the model:</p>
<div class="mce-root"><img src="Images/e6782be0-fb03-4c47-9af1-2e5769266908.png" width="819" height="615" class="calibre56"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Hessian</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">Gradient is the first derivative for functions of vectors, whereas hessian is the second derivative. We will go through the notation now:</p>
<div class="mce-root2"><img src="Images/98c65983-8474-4932-8848-2cb3d21ea642.jpg" width="1067" height="550" class="calibre57"/></div>
<p class="calibre4">Similar to the gradient, the hessian is defined only when <em class="calibre17">f(x)</em> is real-valued.</p>
<div class="packt_infobox">The algebraic function used is <img src="Images/21afe5dc-d4ba-4fbb-87c8-6d7819dfd8cb.jpg" width="763" height="83" class="calibre58"/>.</div>
<p class="calibre4"><span class="calibre14">The following example shows the hessian implementation using TensorFlow:</span></p>
<pre class="calibre26"><span class="calibre5">import </span>tensorflow <span class="calibre5">as </span>tf<br class="calibre2"/><span class="calibre5">import </span>numpy <span class="calibre5">as </span>np<br class="calibre2"/><br class="calibre2"/>X = tf.Variable(np.random.random_sample(), <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/>y = tf.Variable(np.random.random_sample(), <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/><br class="calibre2"/><span class="calibre5">def </span>createCons(x):<br class="calibre2"/>    <span class="calibre5">return </span>tf.constant(x, <span class="calibre5">dtype</span>=tf.float32)<br class="calibre2"/><br class="calibre2"/>function = tf.pow(X, createCons(<span class="calibre5">2</span>)) + createCons(<span class="calibre5">2</span>) * X * y + createCons(<span class="calibre5">3</span>) * tf.pow(y, createCons(<span class="calibre5">2</span>)) + createCons(<span class="calibre5">4</span>) * X + createCons(<span class="calibre5">5</span>) * y + createCons(<span class="calibre5">6</span>)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># compute hessian<br class="calibre2"/></span><span class="calibre5">def </span>hessian(func, varbles):<br class="calibre2"/>    matrix = []<br class="calibre2"/>    <span class="calibre5">for </span>v_1 <span class="calibre5">in </span>varbles:<br class="calibre2"/>        tmp = []<br class="calibre2"/>        <span class="calibre5">for </span>v_2 <span class="calibre5">in </span>varbles:<br class="calibre2"/>            <span class="calibre5"># calculate derivative twice, first w.r.t v2 and then w.r.t v1<br class="calibre2"/></span><span class="calibre5">            </span>tmp.append(tf.gradients(tf.gradients(func, v_2)[<span class="calibre5">0</span>], v_1)[<span class="calibre5">0</span>])<br class="calibre2"/>        tmp = [createCons(<span class="calibre5">0</span>) <span class="calibre5">if </span>t == <span class="calibre5">None else </span>t <span class="calibre5">for </span>t <span class="calibre5">in </span>tmp]<br class="calibre2"/>        tmp = tf.stack(tmp)<br class="calibre2"/>        matrix.append(tmp)<br class="calibre2"/>    matrix = tf.stack(matrix)<br class="calibre2"/>    <span class="calibre5">return </span>matrix<br class="calibre2"/><br class="calibre2"/>hessian = hessian(function, [X, y])<br class="calibre2"/><br class="calibre2"/>sess = tf.Session()<br class="calibre2"/>sess.run(tf.initialize_all_variables())<br class="calibre2"/><span class="calibre5">print</span>(sess.run(hessian))</pre>
<p class="calibre4">The output of this is shown as follows:</p>
<pre class="calibre26"> [[ 2.  2.] [ 2.  6.]]</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Determinant</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">Determinant shows us information about the matrix that is helpful in linear equations and also helps in finding the inverse of a matrix.</p>
<p class="calibre4">For a given matrix <em class="calibre17">X</em>, the determinant is shown as follows:</p>
<p class="calibre51"><img src="Images/04084fab-c318-4f21-960f-c326eee557b0.jpg" width="296" height="221" class="calibre59"/></p>
<p class="calibre51"><img src="Images/ce5ff6f2-7d96-45d5-ab7a-c1e956c44634.jpg" width="921" height="83" class="calibre60"/></p>
<p class="calibre4">The following example shows how to get a determinant using TensorFlow:</p>
<pre class="calibre26"><span class="calibre5">import </span>tensorflow <span class="calibre5">as </span>tf<br class="calibre2"/><span class="calibre5">import </span>numpy <span class="calibre5">as </span>np<br class="calibre2"/><br class="calibre2"/>x = np.array([[<span class="calibre5">10.0</span>, <span class="calibre5">15.0</span>, <span class="calibre5">20.0</span>], [<span class="calibre5">0.0</span>, <span class="calibre5">1.0</span>, <span class="calibre5">5.0</span>], [<span class="calibre5">3.0</span>, <span class="calibre5">5.0</span>, <span class="calibre5">7.0</span>]], <span class="calibre5">dtype</span>=np.float32)<br class="calibre2"/><br class="calibre2"/>det = tf.matrix_determinant(x)<br class="calibre2"/><br class="calibre2"/><span class="calibre5">with </span>tf.Session() <span class="calibre5">as </span>sess:<br class="calibre2"/>    <span class="calibre5">print</span>(sess.run(det))</pre>
<p class="calibre4">The output of this is shown as follows:</p>
<pre class="calibre26">-15.0</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Optimization</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">As part of deep learning, we mostly would like to optimize the value of a function that either minimizes or maximizes <em class="calibre17">f(x)</em> with respect to <em class="calibre17">x</em>. A few examples of optimization problems are least-squares, logistic regression, and support vector machines. Many of these techniques will get examined in detail in later chapters.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Optimizers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">We will study <kbd class="calibre18">AdamOptimizer</kbd> here; TensorFlow <kbd class="calibre18">AdamOptimizer</kbd> uses Kingma and Ba's Adam algorithm to manage the learning rate. Adam has many advantages over the simple <kbd class="calibre18">GradientDescentOptimizer</kbd>. The first is that it uses moving averages of the parameters, which enables Adam to use a larger step size, and it will converge to this step size without any fine-tuning.</p>
<p class="calibre4">The disadvantage of Adam is that it requires more computation to be performed for each parameter in each training step. <kbd class="calibre18">GradientDescentOptimizer</kbd> can be used as well, but it would require more hyperparameter tuning before it would converge as quickly.<br class="calibre25"/>
The following example shows how to use <kbd class="calibre18">AdamOptimizer</kbd>:</p>
<ul class="calibre20">
<li class="calibre21"><kbd class="calibre18">tf.train.Optimizer</kbd> creates an optimizer</li>
<li class="calibre21"><kbd class="calibre18">tf.train.Optimizer.minimize(loss, var_list)</kbd> adds the optimization operation to the computation graph</li>
</ul>
<p class="calibre4">Here, automatic differentiation computes gradients without user input:</p>
<pre class="calibre26"><span class="calibre5">import </span>numpy <span class="calibre5">as </span>np<br class="calibre2"/><span class="calibre5">import </span>seaborn<br class="calibre2"/><span class="calibre5">import </span>matplotlib.pyplot <span class="calibre5">as </span>plt<br class="calibre2"/><span class="calibre5">import </span>tensorflow <span class="calibre5">as </span>tf<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># input dataset<br class="calibre2"/></span>xData = np.arange(<span class="calibre5">100</span>, <span class="calibre5">step</span>=<span class="calibre5">.1</span>)<br class="calibre2"/>yData = xData + <span class="calibre5">20 </span>* np.sin(xData/<span class="calibre5">10</span>)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># scatter plot for input data<br class="calibre2"/></span>plt.scatter(xData, yData)<br class="calibre2"/>plt.show()<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># defining data size and batch size<br class="calibre2"/></span>nSamples = <span class="calibre5">1000<br class="calibre2"/></span>batchSize = <span class="calibre5">100<br class="calibre2"/></span><span class="calibre5"><br class="calibre2"/></span><span class="calibre5"># resize<br class="calibre2"/></span>xData = np.reshape(xData, (nSamples,<span class="calibre5">1</span>))<br class="calibre2"/>yData = np.reshape(yData, (nSamples,<span class="calibre5">1</span>))<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># input placeholders<br class="calibre2"/></span>x = tf.placeholder(tf.float32, <span class="calibre5">shape</span>=(batchSize, <span class="calibre5">1</span>))<br class="calibre2"/>y = tf.placeholder(tf.float32, <span class="calibre5">shape</span>=(batchSize, <span class="calibre5">1</span>))<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># init weight and bias<br class="calibre2"/></span><span class="calibre5">with </span>tf.variable_scope(<span class="calibre5">"linearRegression"</span>):<br class="calibre2"/> W = tf.get_variable(<span class="calibre5">"weights"</span>, (<span class="calibre5">1</span>, <span class="calibre5">1</span>), <span class="calibre5">initializer</span>=tf.random_normal_initializer())<br class="calibre2"/> b = tf.get_variable(<span class="calibre5">"bias"</span>, (<span class="calibre5">1</span>,), <span class="calibre5">initializer</span>=tf.constant_initializer(<span class="calibre5">0.0</span>))<br class="calibre2"/><br class="calibre2"/> y_pred = tf.matmul(x, W) + b<br class="calibre2"/> loss = tf.reduce_sum((y - y_pred)**<span class="calibre5">2</span>/nSamples)<br class="calibre2"/><br class="calibre2"/><span class="calibre5"># optimizer<br class="calibre2"/></span>opt = tf.train.AdamOptimizer().minimize(loss)<br class="calibre2"/><span class="calibre5">with </span>tf.Session() <span class="calibre5">as </span>sess:<br class="calibre2"/>    sess.run(tf.<span class="calibre5">global_variables_initializer</span>())<br class="calibre2"/><br class="calibre2"/>    <span class="calibre5"># gradient descent loop for 500 steps<br class="calibre2"/></span><span class="calibre5">    </span><span class="calibre5">for </span>_ <span class="calibre5">in </span><span class="calibre5">range</span>(<span class="calibre5">500</span>):<br class="calibre2"/>     <span class="calibre5"># random minibatch<br class="calibre2"/></span><span class="calibre5">     </span>indices = np.random.choice(nSamples, batchSize)<br class="calibre2"/><br class="calibre2"/>     X_batch, y_batch = xData[indices], yData[indices]<br class="calibre2"/><br class="calibre2"/>     <span class="calibre5"># gradient descent step<br class="calibre2"/></span><span class="calibre5">     </span>_, loss_val = sess.run([opt, loss], <span class="calibre5">feed_dict</span>={x: X_batch, y: y_batch})</pre>
<p class="calibre4">Here is the scatter plot for the dataset:</p>
<div class="mce-root"><img src="Images/fd9bc39b-f5b5-481c-8932-8765e2538d70.png" width="777" height="534" class="calibre61"/></div>
<p class="calibre4">This is the plot of the learned model on the data:</p>
<div class="mce-root"><img src="Images/c5c47a2e-cde3-4932-a685-86788ec140f0.png" width="644" height="464" class="calibre62"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre4">In this chapter, we've introduced the mathematical concepts that are key to the understanding of neural networks and reviewed some maths associated with tensors. We also demonstrated how to perform mathematical operations within TensorFlow. We will repeatedly be applying these concepts in the following chapters.</p>
<p class="calibre4"/>
<p class="calibre4"/>
<p class="calibre4"/>


            </article>

            
        </section>
    </div>



  </body></html>