["```py\npython -m autogpt --install-plugin-deps\n```", "```py\npip install -r requirements.txt\n```", "```py\n    class AutoGPTTelegram(AutoGPTPluginTemplate):\n        def __init__(self):\n            super().__init__()\n            self._name = \"AutoGPTTelegram\"\n            self._version = \"1.0.0\"\n            self._description = \"This plugin integrates Auto-GPT with a Telegram bot.\"\n            self.telegram_chat_id = \"YOUR_TELEGRAM_CHAT_ID\"\n            self.telegram_api_key = \"YOUR_TELEGRAM_API_KEY\"\n            self.telegram_utils = TelegramUtils(\n                chat_id=self.telegram_chat_id,\n                api_key=self.telegram_api_key\n    )\n    ```", "```py\n    def can_handle_user_input(self, user_input: str) -> bool:\n        return True\n    def user_input(self, user_input: str) -> str:\n        return self.telegram_utils.ask_user(prompt=user_input)\n    ```", "```py\n    def can_handle_report(self) -> bool:\n        return True\n    def report(self, message: str) -> None:\n        self.telegram_utils.send_message(message=message)\n    ```", "```py\n    def can_handle_on_response(self) -> bool:\n    return False\n    ```", "```py\n        class TelegramUtils:\n            def __init__(self, api_key: str = None, \n                chat_id: str = None):\n        # this is filled in the next step.\n        ```", "```py\n        def __init__(self, api_key: str = None, \n            chat_id: str = None):\n            self.api_key = api_key\n            self.chat_id = chat_id\n            if not api_key or not chat_id:\n                # Display instructions to the user on how to get API key and chat ID\n                print(\"Please set the TELEGRAM_API_KEY and \n                TELEGRAM_CHAT_ID environment variables.\")\n        ```", "```py\n                if not api_key:\n                    print(\"No api key provided. Please set the \n                        TELEGRAM_API_KEY environment   variable.\")\n                    print(\"You can get your api key by talking to @\n                        BotFather on Telegram.\")\n                    print( \"For more information: \n        https://core.telegram.org/bots/tutorial#6-  b  otfather\"  )\n                    return\n                if not chat_id:\n                    print( \"Please set the TELEGRAM_CHAT_ID \n                        environment variable.\")\n                    user_input = input( \"Would you like to send a test message to your bot to get the   id? (y/n): \")\n                    if user_input == \"y\":\n                        try:\n                            print(\"Please send a message to your telegram bot now.\")\n                            update = self.poll_anyMessage()\n                            print(\"Message received! \n                                Getting chat id...\")\n                            chat_id = update.message.chat.id\n                            print(\"Your chat id is: \" + \n                                str(chat_id))\n                            print(\"And the message is: \" + \n                                update.message.text)\n                            confirmation = \n                                random.randint(1000, 9999)\n                            print(\"Sending confirmation message: \" \n                                + str(confirmation))\n                            text = f\"Chat id is: {chat_id} and the \n                              confirmation code is {confirmation}\"\n                            self.chat_id = chat_id\n                            self.send_message(text)  \n        # Send confirmation message\n                            print( \"Please set the TELEGRAM_CHAT_ID \n                                environment variable to this.\")\n                      except TimedOut:\n                            print( \"Error while sending test \n                            message. Please check your Telegram \n                                bot.\")\n                            return\n            self.chat_id = chat_id\n        ```", "```py\n        def ask_user(self, prompt):\n            try:\n                return asyncio.run(\n                    self.ask_user_async(prompt=prompt))\n            except TimedOut:\n                print(\"Telegram timeout error, trying again...\")\n                return self.ask_user(prompt=prompt)\n        ```", "```py\n        def user_input(self, user_input: str) -> str:\n            user_input = remove_color_codes(user_input)\n            try:\n                return self.telegram_utils.ask_user(\n                    prompt=user_input)\n            except Exception as e:\n                print(e)\n                print(\"Error sending message to telegram\")\n                return \"s\"  # s means that auto-gpt should rethink its last step, indicating an error with the call\n        ```", "```py\n        def report(self, message: str) -> None:\n            message = remove_color_codes(message)\n            try:\n                self.telegram_utils.send_message(message=message)\n            except Exception as e:\n                print(e)\n                print(\"Error sending message to telegram\")\n        ```", "```py\n        async def get_bot(self):\n            bot_token = self.api_key\n            bot = Bot(token=bot_token)\n            commands = await bot.get_my_commands()\n            if len(commands) == 0:\n                await self.set_commands(bot)\n            commands = await bot.get_my_commands()\n            return bot\n        ```", "```py\n        def poll_anyMessage(self):\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            return loop.run_until_complete(self.poll_anyMessage_async())\n        async def poll_anyMessage_async(self):\n            bot = Bot(token=self.api_key)\n            last_update = await bot.get_updates(timeout=30)\n            if len(last_update) > 0:\n                last_update_id = last_update[-1].update_id\n            else:\n                last_update_id = -1\n            while True:\n                try:\n                    print(\"Waiting for first message...\")\n                    updates = await bot.get_updates(\n                        offset=last_update_id + 1, timeout=30)\n                    for update in updates:\n                        if update.message:\n                            return update\n                except Exception as e:\n                    print(f\"Error while polling updates: {e}\")\n                await asyncio.sleep(1)\n        ```", "```py\n        def send_message(self, message):\n            try:\n                loop = asyncio.get_running_loop()\n            except RuntimeError as e:\n                loop = None\n            try:\n                if loop and loop.is_running():\n                    print(\n                        \"Sending message async, if this fails its due to rununtil complete task\"\n                    )\n                    loop.create_task(\n                        self._send_message(message=message))\n                else:\n                    eventloop = asyncio.get_event_loop\n                    if hasattr(eventloop, \"run_until_complete\")\n                    and eventloop.is_running():\n                        print(\"Event loop is running\")\n                        eventloop.run_until_complete(\n                            self._send_message(message=message))\n                    else:\n                        asyncio.run(self._send_message(message=message))\n            except RuntimeError as e:\n                print(traceback.format_exc())\n                print(\"Error while sending message\")\n                print(e)\n        async def _send_message(self, message):\n            print(\"Sending message to Telegram.. \")\n            recipient_chat_id = self.chat_id\n            bot = await self.get_bot()\n            # properly handle messages with more than 2000 characters by chunking them\n            if len(message) > 2000:\n                message_chunks = [\n                    message[i : i + 2000] for i in range(0, \n                        len(message), 2000)\n                ]\n                message_chunks = [\n                    message[i : i + 2000] for i in range(0, \n                        len(message), 2000)\n                ]\n                for message_chunk in message_chunks:\n                    await bot.send_message(\n                        chat_id=recipient_chat_id,\n                        text=message_chunk)\n            else:\n                await bot.send_message(\n                    chat_id=recipient_chat_id, text=message)\n        ```", "```py\n            async def ask_user_async(self, prompt):\n                global response_queue\n                response_queue = \"\"\n                # await delete_old_messages()\n                print(\"Asking user: \" + question)\n                await self._send_message(message=question)\n                await self._send_message(message=question)\n                print(\"Waiting for response on Telegram chat...\")\n                await self._poll_updates()\n                response_text = response_queue\n                print(\"Response received from Telegram: \" + \n                    response_text)\n                return response_text\n        async def _poll_updates(self):\n            global response_queue\n            bot = await self.get_bot()\n            print(\"getting updates...\")\n            try:\n                last_update = await bot.get_updates(timeout=1)\n                if len(last_update) > 0:\n                    last_update_id = last_update[-1].update_id\n                else:\n                    last_update_id = -1\n                print(\"last update id: \" + str(last_update_id))\n                while True:\n                    try:\n                        print(\"Polling updates...\")\n                        updates = await bot.get_updates(\n                            offset=last_update_id + 1, timeout=30)\n                        for update in updates:\n                            if update.message and update.message.text:\n                                if self.is_authorized_user(update):\n                                    response_queue = update.message.text\n                                    return\n                            last_update_id = max(\n                                last_update_id, update.update_id)\n                    except Exception as e:\n                        print(f\"Error while polling updates: {e}\")\n                    await asyncio.sleep(1)\n            except RuntimeError:\n                print(\"Error while polling updates\")\n        def ask_user(self, prompt):\n            print(\"Asking user: \" + prompt)\n            try:\n                loop = asyncio.get_running_loop()\n            except RuntimeError:  # 'RuntimeError: There is no current event loop...'\n                loop = None\n            try:\n                if loop and loop.is_running():\n                    return loop.create_task(\n                        self.ask_user_async(prompt=prompt))\n                else:\n                    return asyncio.run(\n                        self.ask_user_async(prompt=prompt))\n            except TimedOut:\n                print(\"Telegram timeout error, trying again...\")\n                return self.ask_user(prompt=prompt)\n        ```", "```py\n        if len(message) > 2000:\n            message_chunks = [\n                message[i : i + 2000] for i in range(0, \n                    len(message), 2000)\n            ]\n            for message_chunk in message_chunks:\n                await bot.send_message(\n                    chat_id=recipient_chat_id,\n                    text=message_chunk)\n        else:\n            await bot.send_message(\n                chat_id=recipient_chat_id, text=message)\n    ```", "```py\n    except TimedOut:\n        print(\"Telegram timeout error, trying again...\")\n        return self.ask_user(prompt=prompt)\n    ```", "```py\n    async def _send_message(self, message):\n        # ...\n        await bot.send_message(chat_id=recipient_chat_id, \n            text=message)\n    ```", "```py\n    except Exception as e:\n        print(f\"Error while polling updates: {e}\")\n    ```", "```py\n        def is_authorized_user(self, update):\n            # authorization check based on user ID or username\n            return update.effective_user.id == int(self.chat_id)\n    ```", "```py\n        async def set_commands(self, bot):\n            await bot.set_my_commands(\n                [\n                    (\"start\", \"Start Auto-GPT\"),\n                    (\"stop\", \"Stop Auto-GPT\"),\n                    (\"help\", \"Show help\"),\n                    (\"yes\", \"Confirm\"),\n                    (\"no\", \"Deny\"),\n                    (\"auto\", \"Let an Agent decide\"),\n                ]\n            )\n    ```", "```py\n          async def ask_user_async(self, prompt):\n            global response_queue\n            # only display confirm if the prompt doesn't have the string \"\"Continue (y/n):\"\" inside\n            if \"Continue (y/n):\" in prompt or \"Waiting for your response...\" in prompt:\n                question = (\n                    (\n                    prompt\n                    + \" \\n Confirm: /yes     Decline: /no \\n Or type your answer. \\n or press /auto to let an Agent decide.\"\n                )\n                )\n            elif \"I want Auto-GPT to:\" in prompt:\n                question = prompt\n            else:\n                question = (\n                    (\n                    prompt + \" \\n Type your answer or press /auto to let an Agent decide.\"\n                )\n                )\n            response_queue = \"\"\n            # await delete_old_messages()\n            print(\"Asking user: \" + question)\n            await self._send_message(message=question)\n            await self._send_message(message=question)\n            print(\"Waiting for response on Telegram chat...\")\n            await self._poll_updates()\n            if response_queue == \"/start\":\n                response_queue = await self.ask_user(\n                    self,\n                    prompt=\"I am already here... \\n Please use /stop to stop me first.\",\n                )\n            if response_queue == \"/help\":\n                response_queue = await self.ask_user(\n                    self,\n                    prompt=\"You can use /stop to stop me \\n and /start to start me again.\",\n                )\n            if response_queue == \"/auto\":\n                return \"s\"\n            if response_queue == \"/stop\":\n                await self._send_message(\"Stopping Auto-GPT now!\")\n                await self._send_message(\"Stopping Auto-GPT now!\")\n                exit(0)\n            elif response_queue == \"/yes\":\n                response_text = \"yes\"\n                response_queue = \"yes\"\n            elif response_queue == \"/no\":\n                response_text = \"no\"\n                response_queue = \"no\"\n            if response_queue.capitalize() in [\n                \"Yes\",\n                \"Okay\",\n                \"Ok\",\n                \"Sure\",\n                \"Yeah\",\n                \"Yup\",\n                \"Yep\",\n            ]:\n                response_text = \"y\"\n            elif response_queue.capitalize() in [\"No\", \"Nope\", \n                \"Nah\", \"N\"]:\n                response_text = \"n\"\n            else:\n                response_text = response_queue\n            print(\"Response received from Telegram: \" \n                + response_text)\n            return response_text\n    ```", "```py\n    import logging\n    logging.basicConfig(level=logging.INFO)\n    logger = logging.getLogger(__name__)\n    ```", "```py\n    logger.info(\"Information message\")\n    logger.error(\"Error message\")\n    ```", "```py\n    import os\n    TELEGRAM_API_KEY = os.getenv(\"TELEGRAM_API_KEY\")\n    TELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\")\n    ```"]