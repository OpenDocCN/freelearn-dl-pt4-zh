["```py\n    import torch\n    from torch.nn import Linear\n    from torch_geometric.nn import MessagePassing\n    from torch_geometric.utils import add_self_loops, degree\n    ```", "```py\n    class GCNConv(MessagePassing):\n    ```", "```py\n        def __init__(self, dim_in, dim_h):\n            super().__init__(aggr='add')\n            self.linear = Linear(dim_in, dim_h, bias=False)\n    ```", "```py\n        def forward(self, x, edge_index):\n            edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(0))\n    ```", "```py\n            x = self.linear(x)\n    ```", "```py\n            row, col = edge_index\n            deg = degree(col, x.size(0), dtype=x.dtype)\n            deg_inv_sqrt = deg.pow(-0.5)\n            deg_inv_sqrt[deg_inv_sqrt == float('inf')] = 0\n            norm = deg_inv_sqrt[row] * deg_inv_sqrt[col]\n    ```", "```py\n            out = self.propagate(edge_index, x=x, norm=norm)\n            return out\n    ```", "```py\n        def message(self, x, norm):\n            return norm.view(-1, 1) * x\n    ```", "```py\n    conv = GCNConv(16, 32)\n    ```", "```py\n    from torch_geometric.data import HeteroData\n    data = HeteroData()\n    ```", "```py\n    data['user'].x = torch.Tensor([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]])\n    ```", "```py\n    data['game'].x = torch.Tensor([[1, 1], [2, 2]])\n    data['dev'].x = torch.Tensor([[1], [2]])\n    ```", "```py\n    data['user', 'follows', 'user'].edge_index = torch.Tensor([[0, 1], [1, 2]]) # [2, num_edges_follows]\n    data['user', 'plays', 'game'].edge_index = torch.Tensor([[0, 1, 1, 2], [0, 0, 1, 1]])\n    data['dev', 'develops', 'game'].edge_index = torch.Tensor([[0, 1], [0, 1]])\n    ```", "```py\n    data['user', 'plays', 'game'].edge_attr = torch.Tensor([[2], [0.5], [10], [12]])\n    ```", "```py\n    HeteroData(\n      user={ x=[3, 4] },\n      game={ x=[2, 2] },\n      dev={ x=[2, 1] },\n      (user, follows, user)={ edge_index=[2, 2] },\n      (user, plays, game)={\n        edge_index=[2, 4],\n        edge_attr=[4, 1]\n      },\n      (dev, develops, game)={ edge_index=[2, 2] }\n    )\n    ```", "```py\n    from torch import nn\n    import torch.nn.functional as F\n    import torch_geometric.transforms as T\n    from torch_geometric.datasets import DBLP\n    from torch_geometric.nn import GAT\n    ```", "```py\n    metapaths = [[('author', 'paper'), ('paper', 'author')]]\n    ```", "```py\n    transform = T.AddMetaPaths(metapaths=metapaths, drop_orig_edge_types=True)\n    ```", "```py\n    dataset = DBLP('.', transform=transform)\n    data = dataset[0]\n    print(data)\n    ```", "```py\n    HeteroData(\n      metapath_dict={ (author, metapath_0, author)=[2] },\n      author={\n        x=[4057, 334],\n        y=[4057],\n        train_mask=[4057],\n        val_mask=[4057],\n        test_mask=[4057]\n      },\n      paper={ x=[14328, 4231] },\n      term={ x=[7723, 50] },\n      conference={ num_nodes=20 },\n      (author, metapath_0, author)={ edge_index=[2, 11113] }\n    )\n    ```", "```py\n    model = GAT(in_channels=-1, hidden_channels=64, out_channels=4, num_layers=1)\n    ```", "```py\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.001, weight_decay=0.001)\n    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n    data, model = data.to(device), model.to(device)\n    ```", "```py\n    @torch.no_grad()\n    def test(mask):\n        model.eval()\n        pred = model(data.x_dict['author'], data.edge_index_dict[('author', 'metapath_0', 'author')]).argmax(dim=-1)\n        acc = (pred[mask] == data['author'].y[mask]).sum() / mask.sum()\n        return float(acc)\n    ```", "```py\n    for epoch in range(101):\n        model.train()\n        optimizer.zero_grad()\n        out = model(data.x_dict['author'], data.edge_index_dict[('author', 'metapath_0', 'author')])\n        mask = data['author'].train_mask\n        loss = F.cross_entropy(out[mask], data['author'].y[mask])\n        loss.backward()\n        optimizer.step()\n        if epoch % 20 == 0:\n            train_acc = test(data['author'].train_mask)\n            val_acc = test(data['author'].val_mask)\n            print(f'Epoch: {epoch:>3} | Train Loss: {loss:.4f} | Train Acc: {train_acc*100:.2f}% | Val Acc: {val_acc*100:.2f}%')\n    ```", "```py\n    test_acc = test(data['author'].test_mask)\n    print(f'Test accuracy: {test_acc*100:.2f}%')\n    Test accuracy: 73.29%\n    ```", "```py\n    from torch_geometric.nn import GATConv, Linear, to_hetero\n    ```", "```py\n    dataset = DBLP(root='.')\n    data = dataset[0]\n    ```", "```py\n    data['conference'].x = torch.zeros(20, 1)\n    ```", "```py\n    class GAT(torch.nn.Module):\n        def __init__(self, dim_h, dim_out):\n            super().__init__()\n            self.conv = GATConv((-1, -1), dim_h, add_self_loops=False)\n            self.linear = nn.Linear(dim_h, dim_out)\n        def forward(self, x, edge_index):\n            h = self.conv(x, edge_index).relu()\n            h = self.linear(h)\n            return h\n    ```", "```py\n    model = GAT(dim_h=64, dim_out=4)\n    model = to_hetero(model, data.metadata(), aggr='sum')\n    ```", "```py\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.001, weight_decay=0.001)\n    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n    data, model = data.to(device), model.to(device)\n    ```", "```py\n    @torch.no_grad()\n    def test(mask):\n        model.eval()\n        pred = model(data.x_dict, data.edge_index_dict)['author'].argmax(dim=-1)\n        acc = (pred[mask] == data['author'].y[mask]).sum() / mask.sum()\n        return float(acc)\n    ```", "```py\n    for epoch in range(101):\n        model.train()\n        optimizer.zero_grad()\n        out = model(data.x_dict, data.edge_index_dict)['author']\n        mask = data['author'].train_mask\n        loss = F.cross_entropy(out[mask], data['author'].y[mask])\n        loss.backward()\n        optimizer.step()\n        if epoch % 20 == 0:\n            train_acc = test(data['author'].train_mask)\n            val_acc = test(data['author'].val_mask)\n            print(f'Epoch: {epoch:>3} | Train Loss: {loss:.4f} | Train Acc: {train_acc*100:.2f}% | Val Acc: {val_acc*100:.2f}%')\n    ```", "```py\n    test_acc = test(data['author'].test_mask)\n    print(f'Test accuracy: {test_acc*100:.2f}%')\n    Test accuracy: 78.42%\n    ```", "```py\n    from torch_geometric.nn import HANConv\n    ```", "```py\n    dataset = DBLP('.')\n    data = dataset[0]\n    data['conference'].x = torch.zeros(20, 1)\n    ```", "```py\n    class HAN(nn.Module):\n        def __init__(self, dim_in, dim_out, dim_h=128, heads=8):\n            super().__init__()\n            self.han = HANConv(dim_in, dim_h, heads=heads, dropout=0.6, metadata=data.metadata())\n            self.linear = nn.Linear(dim_h, dim_out)\n    ```", "```py\n        def forward(self, x_dict, edge_index_dict):\n            out = self.han(x_dict, edge_index_dict)\n            out = self.linear(out['author'])\n            return out\n    ```", "```py\n    model = HAN(dim_in=-1, dim_out=4)\n    ```", "```py\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.001, weight_decay=0.001)\n    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n    data, model = data.to(device), model.to(device)\n    ```", "```py\n    @torch.no_grad()\n    def test(mask):\n        model.eval()\n        pred = model(data.x_dict, data.edge_index_dict).argmax(dim=-1)\n        acc = (pred[mask] == data['author'].y[mask]).sum() / mask.sum()\n        return float(acc)\n    ```", "```py\n    for epoch in range(101):\n        model.train()\n        optimizer.zero_grad()\n        out = model(data.x_dict, data.edge_index_dict)\n        mask = data['author'].train_mask\n        loss = F.cross_entropy(out[mask], data['author'].y[mask])\n        loss.backward()\n        optimizer.step()\n        if epoch % 20 == 0:\n            train_acc = test(data['author'].train_mask)\n            val_acc = test(data['author'].val_mask)\n            print(f'Epoch: {epoch:>3} | Train Loss: {loss:.4f} | Train Acc: {train_acc*100:.2f}% | Val Acc: {val_acc*100:.2f}%')\n    ```", "```py\n    Epoch:   0 | Train Loss: 1.3829 | Train Acc: 49.75% | Val Acc: 37.75%\n    Epoch:  20 | Train Loss: 1.1551 | Train Acc: 86.50% | Val Acc: 60.75%\n    Epoch:  40 | Train Loss: 0.7695 | Train Acc: 94.00% | Val Acc: 67.50%\n    Epoch:  60 | Train Loss: 0.4750 | Train Acc: 97.75% | Val Acc: 73.75%\n    Epoch:  80 | Train Loss: 0.3008 | Train Acc: 99.25% | Val Acc: 78.25%\n    Epoch: 100 | Train Loss: 0.2247 | Train Acc: 99.50% | Val Acc: 78.75%\n    ```", "```py\n    test_acc = test(data['author'].test_mask)\n    print(f'Test accuracy: {test_acc*100:.2f}%')\n    Test accuracy: 81.58%\n    ```"]