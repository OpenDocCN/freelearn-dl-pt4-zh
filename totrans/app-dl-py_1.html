<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Jupyter Fundamentals</h1>
                </header>
            
            <article>
                
<p class="mce-root">Jupyter Notebooks are one of the most important tools for data scientists using Python. This is because they're an ideal environment for developing reproducible data analysis pipelines. Data can be loaded, transformed, and modeled all inside a single Notebook, where it's quick and easy to test out code and explore ideas along the way. Furthermore, all of this can be documented "<strong>inline</strong>" using formatted text, so you can make notes for yourself or even produce a structured report. Other comparable platforms - for example, RStudio or Spyder - present the user with multiple windows, which promote arduous tasks such as copy and pasting code around and rerunning code that has already been executed. These tools also tend to involve <strong>Read Eval Prompt Loops (REPLs)</strong> where code is run in a terminal session that has saved memory. This type of development environment is bad for reproducibility and not ideal for development either. Jupyter Notebooks solve all these issues by giving the user a single window where code snippets are executed and outputs are displayed inline. This lets users develop code efficiently and allows them to look back at previous work for reference, or even to make alterations.</p>
<p class="mce-root">We'll start the chapter by explaining exactly what Jupyter Notebooks are and continue to discuss why they are so popular among data scientists. Then, we'll open a Notebook together and go through some exercises to learn how the platform is used. Finally, we'll dive into our first analysis and perform an exploratory analysis in the section <em>Basic Functionality and Features.</em></p>
<p class="mce-root"><span>By the end of this chapter, you will be able to:</span></p>
<ul>
<li class="mce-root"><span>Learn what a Jupyter Notebook is and why it's useful for data analysis</span></li>
<li class="mce-root"><span>Use Jupyter Notebook features</span></li>
<li class="mce-root"><span>Study Python data science libraries</span></li>
<li class="mce-root"><span>Perform simple exploratory data analysis<br/></span></li>
</ul>
<div class="mce-root packt_infobox"><span>All code from this book are available as chapter-specific IPython notebooks in the code bundle. All color plots from this book are also available in the code bundle.<br/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic Functionality and Features</h1>
                </header>
            
            <article>
                
<p><span>In this section, we first demonstrate the usefulness of Jupyter Notebooks with examples and through discussion. Then, in order to cover the fundamentals of Jupyter Notebooks for beginners, we'll see the basic usage of them in terms of launching and interacting with the platform. For those who have used Jupyter Notebooks before, this will be mostly a review; however, you will certainly see new things in this topic as well.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is a Jupyter Notebook and Why is it Useful?</h1>
                </header>
            
            <article>
                
<p class="mce-root">Jupyter Notebooks are locally run web applications which contain live code, equations, figures, interactive apps, and Markdown text. The standard language is Python, and that's what we'll be using for this book; however, note that a variety of alternatives are supported. This includes the other dominant data science language, R:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bd2128ae-e666-46c5-8c5a-5f7b892cac26.png" style="width:72.67em;height:40.83em;"/></p>
<p class="CDPAlignLeft CDPAlign">Those familiar with R will know about R Markdown. Markdown documents allow for Markdown-formatted text to be combined with executable code. Markdown is a simple language used for styling text on the web. For example, most GitHub repositories have a <kbd>README.md</kbd> <kbd>Markdown</kbd> file. This format is useful for basic text formatting. It's comparable to HTML but allows for much less customization.</p>
<p class="CDPAlignLeft CDPAlign">Commonly used symbols in Markdown include hashes (#) to make text into a heading, square and round brackets to insert hyperlinks, and stars to create italicized or bold text:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bb9fd5a0-5267-4233-8eae-2b8f3e37f867.png" style="width:76.75em;height:22.42em;"/></p>
<p>Having seen the basics of Markdown, let's come back to R Markdown, where Markdown text can be written alongside executable code. Jupyter Notebooks offer the equivalent functionality for Python, although, as we'll see, they function quite differently than R Markdown documents. For example, R Markdown assumes you are writing Markdown unless otherwise specified, whereas Jupyter Notebooks assume you are inputting code. This makes it more appealing to use Jupyter Notebooks for rapid development and testing.</p>
<p>From a data science perspective, there are two primary types for a Jupyter Notebook depending on how they are used: lab-style and deliverable.</p>
<p class="mce-root">Lab-style Notebooks are meant to serve as the programming analog of research journals. These should contain all the work you've done to load, process, analyze, and model the data. The idea here is to document everything you've done for future reference, so it's usually not advisable to delete or alter previous lab-style Notebooks. It's also a good idea to accumulate multiple date-stamped versions of the Notebook as you progress through the analysis, in case you want to look back at previous states.</p>
<p class="mce-root">Deliverable Notebooks are intended to be presentable and should contain only select parts of the lab-style Notebooks. For example, this could be an interesting discovery to share with your colleagues, an in-depth report of your analysis for a manager, or a summary of the key findings for stakeholders.</p>
<p class="mce-root">In either case, an important concept is reproducibility. If you've been diligent in documenting your software versions, anyone receiving the reports will be able to rerun the Notebook and compute the same results as you did. In the scientific community, where reproducibility is becoming increasingly difficult, this is a breath of fresh air.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigating the Platform</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>Now, we are going to open up a Jupyter Notebook and start to learn the interface. Here, we will assume you have no prior knowledge of the platform and go over the basic usage.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Jupyter Notebooks</h1>
                </header>
            
            <article>
                
<ol>
<li><span>Navigate to the companion material directory in the terminal.<br/></span></li>
</ol>
<div class="packt_infobox"><span>On Unix machines such as Mac or Linux, command-line navigation can be done using ls to display directory contents and <kbd>cd</kbd> to change directories. </span><span>On Windows machines, use <kbd>dir</kbd> to display directory contents and use <kbd>cd</kbd> to change directories instead. If, for example, you want to change the drive from <kbd>C:</kbd> to <kbd>D:</kbd> , you should execute <kbd>d:</kbd> to change drives.<br/></span></div>
<ol start="2">
<li><span>Start a new local Notebook server here by typing the following into the terminal: <kbd>jupyter notebook.</kbd><br/></span> <span>A new window or tab of your default browser will open the Notebook Dashboard to the working directory. Here, you will see a list of folders and files contained therein.</span></li>
<li><span>Click on a folder to navigate to that particular path and open a file by clicking on it. Although its main use is editing IPYNB Notebook files, Jupyter functions as a standard text editor as well.<br/></span></li>
<li><span>Reopen the terminal window used to launch the app. We can see the <kbd>NotebookApp</kbd> being run on a local server. In particular, you should see a line like this:<br/></span> <kbd>[I 20:03:01.045 NotebookApp] The Jupyter Notebook is running at: http:// localhost:8888/ ? oken=e915bb06866f19ce462d959a9193a94c7c088e81765f9d8a</kbd><span><br/></span> Going to that HTTP address will load the app in your browser window, as was done automatically when starting the app. Closing the window does not stop the app; this should be done from the terminal by typing <em>Ctrl + C</em><span>.</span></li>
</ol>
<ol start="5">
<li><span>Close the app by typing <em>Ctrl +</em> <em>C</em> in the terminal. You may also have to confirm by entering <kbd>y</kbd>. Close the web browser window as well.<br/></span></li>
<li><span>When loading the NotebookApp, there are various options available to you. In the terminal, see the list of available options by running the following:<br/>
<kbd>jupyter notebook –-help.</kbd></span></li>
</ol>
<ol start="7">
<li>One such option is to specify a specific port. Open a NotebookApp at <kbd>local port 9000</kbd> by running the following:<span><br/>
<kbd>jupyter notebook --port 9000</kbd></span></li>
<li><span>The primary way to create a new Jupyter Notebook is from the Jupyter Dashboard. Click <strong>New</strong> in the upper-right corner and select a kernel from the drop-down menu (that is, select something in the Notebooks section):</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d1a81c3a-8d52-4977-91e0-103c9b8c8af3.png" style="font-size: 1em;text-align: center;color: #333333;width:26.67em;height:25.50em;"/></p>
<p style="padding-left: 60px"><span>Kernels provide programming language support for the Notebook. If you have installed Python with Anaconda, that version should be the default kernel. Conda virtual environments will also be available here.<br/></span></p>
<div class="packt_infobox"><span>Virtual environments are a great tool for managing multiple projects on the same machine. Each virtual environment may contain a different version of Python and external libraries. Python has built-in virtual environments; however, the Conda virtual environment integrates better with Jupyter Notebooks and boasts other nice features. The documentation is available at <a href="https://conda.io/docs/user-guide/tasks/manage-environments.html">https://conda.io/docs/user-guide/tasks/manage-environments.html</a></span>.<span><br/></span></div>
<ol start="9">
<li>
<p>With the newly created blank Notebook, click in the top cell and type <kbd>print('hello world')</kbd> , or any other code snippet that writes to the screen. Execute it by clicking in the cell and pressing <em>Shift + Enter</em>, or by selecting <strong>Run Cell</strong> in the <strong>Cell menu</strong>.</p>
</li>
</ol>
<p style="padding-left: 60px">Any <kbd>stdout</kbd> or <kbd>stderr</kbd> output from the code will be displayed beneath as the cell runs. Furthermore, the string representation of the object written in the final line will be displayed as well. This is very handy, especially for displaying tables, but sometimes we don't want the final object to be displayed. In such cases, a semicolon (; ) can be added to the end of the line to suppress the display.</p>
<p style="padding-left: 60px"><span>New cells expect and run code input by default; however, they can be changed to render Markdown instead.<br/></span></p>
<ol start="10">
<li>Click into an empty cell and change it to accept Markdown-formatted text. This can be done from the drop-down menu icon in the toolbar or by selecting <strong>Markdown</strong> from the <strong>Cell</strong> menu. Write some text in here (any text will do), making sure to utilize Markdown formatting symbols such as #.</li>
<li><span>Focus on the toolbar at the top of the Notebook:<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8f15ecf5-0db6-4dd2-9177-a2f88eb960c8.png" style="width:47.25em;height:5.75em;"/></p>
<p style="padding-left: 60px"><span>There is a Play icon in the toolbar, which can be used to run cells. As we'll see later,however, it's handier to use the keyboard shortcut <em>Shift +</em> <em>Enter</em> to run cells. Right next to this is a Stop icon, which can be used to stop cells from running. This is useful, for example, if a cell is taking too long to run:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ed67bc3e-b989-4f56-99cf-2f4def9cfd55.png" style="width:23.83em;height:6.83em;"/></p>
<p style="padding-left: 60px"><span>New cells can be manually added from the Insert menu:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/69a5c020-9d23-479c-be44-c375dfd0c9d5.png" style="width:13.25em;height:8.33em;"/></p>
<p style="padding-left: 60px"><span>Cells can be copied, pasted, and deleted using icons or by selecting options from the Edit menu:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5b346eda-8c8d-466f-9bd4-6135b2b0a7f6.png" style="width:14.00em;height:6.50em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/36336f67-aacc-4e60-9d6d-d2a213851bd4.png" style="width:17.92em;height:16.83em;"/></p>
<p style="padding-left: 60px"><span>Cells can also be moved up and down this way:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5f74be09-9e20-48a8-a404-9e40fe551ced.png" style="width:17.58em;height:5.42em;"/></p>
<p style="padding-left: 60px"><span>There are useful options under the Cell menu to run a group of cells or the entire Notebook:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eb8230f9-c773-4415-b903-0afa60e6f1ac.png" style="width:14.42em;height:21.17em;"/></p>
<ol start="12">
<li><span>Experiment with the toolbar options to move cells up and down, insert new cells,and delete cells.<br/></span></li>
</ol>
<p style="padding-left: 60px"><span>An important thing to understand about these Notebooks is the shared memory between cells. It's quite simple: every cell existing on the sheet has access to the global set of variables. So, for example, a function defined in one cell could be called from any other, and the same applies to variables. As one would expect, anything within the scope of a function will not be a global variable and can only be accessed from within that specific function.<br/></span></p>
<ol start="13">
<li><span>Open the Kernel menu to see the selections. The Kernel menu is useful for stopping script executions and restarting the Notebook if the kernel dies. Kernels can also be swapped here at any time, but it is unadvisable to use multiple kernels for a single Notebook due to reproducibility concerns.<br/></span></li>
<li>Open the <strong>File</strong> menu to see the selections. The <strong>File</strong> menu contains options for downloading the Notebook in various formats. In particular, it's recommended to save an HTML version of your Notebook, where the content is rendered statically and can be opened and viewed "as you would expect" in web browsers.</li>
</ol>
<p style="padding-left: 60px"><span> The Notebook name will be displayed in the upper-left corner. New Notebooks will automatically be named <strong>Untitled</strong>.</span></p>
<ol start="15">
<li><span>Change the name of your IPYNB <kbd>Notebook</kbd> file by clicking on the current name in the upper-left corner and typing the new name. Then, save the file.<br/></span></li>
<li><span>Close the current tab in your web browser (exiting the Notebook) and go to the Jupyter Dashboard tab, which should still be open. (If it's not open, then reload it by copy and pasting the HTTP link from the terminal.)</span></li>
</ol>
<p style="padding-left: 60px"><span>Since we didn't shut down the Notebook, we just saved and exited, it will have a green book symbol next to its name in the Files section of the Jupyter Dashboard and will be listed as Running on the right side next to the last modified date. Notebooks can be shut down from here.<br/></span></p>
<ol start="17">
<li><span>Quit the Notebook you have been working on by selecting it (checkbox to the left of the name) and clicking the orange Shutdown button:<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fa60a534-064a-4c87-9ab3-ad6ae266a58b.png" style="width:62.25em;height:17.17em;"/></p>
<div class="packt_infobox">If you plan to spend a lot of time working with Jupyter Notebooks, it's worthwhile to learn the keyboard shortcuts. This will speed up your workflow considerably. Particularly useful commands to learn are the shortcuts for manually adding new cells and converting cells from code to Markdown formatting. Click on <strong>Keyboard Shortcuts</strong> from the <strong>Help menu</strong> to see how.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Jupyter Features</h1>
                </header>
            
            <article>
                
<p><span>Jupyter has many appealing features that make for efficient Python programming. These include an assortment of things, from methods for viewing docstrings to executing Bash commands. Let's explore some of these features together in this section.<br/></span></p>
<div class="packt_infobox">The official IPython documentation can be found here: <a href="https://ipython.readthedocs.io/en/stable/">http://ipython.readthedocs.io/en/stable/</a>. It has details on the features we will discuss here and others.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring some of Jupyter's most useful features</h1>
                </header>
            
            <article>
                
<ol>
<li><span><span>From the Jupyter Dashboard, navigate to the <kbd>chapter-1</kbd> directory and open the <kbd>chapter-1-workbook.ipynb</kbd> file by selecting it. The standard file extension for Jupyter Notebooks is <kbd>.ipynb</kbd>, which was introduced back when they were called IPython Notebooks.</span></span></li>
<li><span>Scroll down to Subtopic <kbd>Jupyter Features</kbd> in the Jupyter Notebook. We start by reviewing the basic keyboard shortcuts. These are especially helpful to avoid having to use the mouse so often, which will greatly speed up the workflow. Here are the most useful keyboard shortcuts. Learning to use these will greatly improve your experience with Jupyter Notebooks as well as your own efficiency:</span>
<ul>
<li><em>Shift <span>+</span> <span>Enter</span></em> <span>is used to run a cell</span></li>
<li>The <em><span>Esc</span></em> <span><em>key</em> is used to leave a cell</span></li>
<li>The <em><span>M</span></em> <span>key is used to change a cell to Markdown (after pressing</span> <span>Esc</span><span>)</span></li>
<li>The <em><span>Y</span></em> <span>key is used to change a cell to code (after pressing</span> <span>Esc</span><span>)</span></li>
<li><em>Arrow keys</em> move cells (after pressing <span>Esc</span><span>) </span></li>
<li>The <em><span>Enter</span></em> <span><em>key</em> is used to enter a cell</span></li>
</ul>
</li>
</ol>
<p style="padding-left: 60px">Moving on from shortcuts, the help option is useful for beginners and experienced coders alike. It can help provide guidance at each uncertain step.</p>
<p style="padding-left: 60px">Users can get help by adding a question mark to the end of any object and running the cell. Jupyter finds the docstring for that object and returns it in a pop-out window at the bottom of the app.</p>
<ol start="3">
<li>Run the <strong>Getting Help</strong> section cells and check out how Jupyter displays the docstrings at the bottom of the Notebook. Add a cell in this section and get help on the object of your choice: <span><br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0c4022a8-0948-487c-a807-8cf5cc5dc79f.png" style="width:45.25em;height:22.67em;"/></p>
<p style="padding-left: 60px"><span>Tab completion can be used to do the following:</span></p>
<ul>
<li style="list-style-type: none">
<ul>
<li>List available modules when importing external libraries</li>
<li>List available modules of imported external libraries</li>
<li>Function and variable completion</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px"><span>This can be especially useful when you need to know the available input arguments for a module, when exploring a new library, to discover new modules, or simply to speed up workflow. They will save time writing out variable names or functions and reduce bugs from typos. The tab completion works so well that you may have difficulty coding Python in other editors after today!<br/></span></p>
<ol start="4">
<li>Click into an empty code cell in the Tab Completion section and try using tab completion in the ways suggested immediately above. For example, the fist suggestion can be done by typing import (including the space after) and then pressing the Tab key:<span><br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/095220a0-0d48-43b9-9b83-edada33dea2d.png" style="width:28.58em;height:13.75em;"/></p>
<ol start="5">
<li>Last but not least of the basic Jupyter Notebook features are <strong>magic</strong> commands. These consist of one or two percent signs followed by the command. Magics starting with <kbd>%%</kbd> will apply to the entire cell, and magics starting with <kbd>%</kbd> will only apply to that line. This will make sense when seen in an example.</li>
</ol>
<p style="padding-left: 60px">Scroll to the <strong>Jupyter Magic Functions</strong> section and run the cells containing <kbd>%lsmagic and %matplotlib inline</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4a74b3cc-a816-4269-8a14-1c5eed6855c6.png" style="width:28.50em;height:16.17em;"/></p>
<p style="padding-left: 60px"><span><kbd>%lsmagic</kbd> lists the available options. We will discuss and show examples of some of the most useful ones. The most common magic command you will probably see is <kbd>%matplotlib inline</kbd>, which allows matplotlib figures to be displayed in the Notebook without having to explicitly use <kbd>plt.show()</kbd> .<br/></span></p>
<p style="padding-left: 60px"><span>The timing functions are very handy and come in two varieties: a standard timer <kbd>(%time or %%time)</kbd> and a timer that measures the average runtime of many iterations <kbd>(%timeit and %%timeit)</kbd>.<br/></span></p>
<ol start="6">
<li><span>Run the cells in the Timers section. Note the difference between using one and two percent signs.<br/></span></li>
</ol>
<p style="padding-left: 60px">Even by using a Python kernel (as you are currently doing), other languages can be invoked using magic commands. The built-in options include JavaScript, R, Pearl, Ruby, and Bash. Bash is particularly useful, as you can use Unix commands to find out where you are currently (<kbd>pwd</kbd>), what's in the directory (<kbd>ls</kbd>), make new folders <kbd>(mkdir)</kbd>, and write file contents <kbd>(cat / head / tail)</kbd>.</p>
<ol start="7">
<li>Run the fist cell in the <strong>Using bash in the notebook section</strong>. This cell writes some text to a file in the working directory, prints the directory contents, prints an empty line, and then writes back the contents of the newly created file before removing it:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1db82a4c-7baf-43f0-9bfe-eed4a3571ea2.png" style="width:36.33em;height:22.83em;"/></p>
<ol start="8">
<li>Run the following cells containing only <kbd>ls</kbd> and <kbd>pwd</kbd>. Note how we did not have to explicitly use the Bash magic command for these to work.</li>
</ol>
<p style="padding-left: 60px">There are plenty of external magic commands that can be installed. A popular one is <kbd>ipython-sql</kbd>, which allows for SQL code to be executed in cells.</p>
<ol start="9">
<li>If you've not already done so, install <kbd>ipython-sql</kbd> now. Open a new terminal window and execute the following code:</li>
</ol>
<pre style="padding-left: 60px">  pip install ipython-sql</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9f8aff1e-7c8b-44f9-a965-11a5fad0c8b9.png" style="width:27.25em;height:6.00em;"/></p>
<ol start="10">
<li><span>Run the <kbd>%load_ext sql</kbd> cell to load the external command into the Notebook:<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/409e7029-b8f6-41f7-9f1b-52c8b005cba1.png" style="width:36.33em;height:5.75em;"/></p>
<p style="padding-left: 60px"><span>This allows for connections to remote databases so that queries can be executed (and thereby documented) right inside the Notebook.<br/></span></p>
<ol start="11">
<li><span>Run the cell containing the SQL sample query:<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4144970d-a09c-4d76-a1b9-78e6b28fb506.png" style="width:27.33em;height:18.83em;"/></p>
<p style="padding-left: 60px">Here, we first connect to the local sqlite source; however, this line could instead point to a specific database on a local or remote server. Then, we execute a simple <kbd>SELECT</kbd> to show how the cell has been converted to run SQL code instead of Python.</p>
<ol start="12">
<li>Moving on to other useful magic functions, we'll briefly discuss one that helps with documentation. The command is <kbd>%version_information</kbd>, but it does not come as standard with Jupyter. Like the SQL one we just saw, it can be installed from the command line with pip.</li>
</ol>
<p style="padding-left: 60px">If not already done, install the version documentation tool now from the terminal using <kbd>pip</kbd>.<span>Open up a new window and run the following code:</span></p>
<pre style="padding-left: 60px">pip install version_information</pre>
<p style="padding-left: 60px">Once installed, it can then be imported into any Notebook using <kbd>%load_ext version_information</kbd>. Finally, once loaded, it can be used to display the versions of each piece of software in the Notebook.</p>
<ol start="13">
<li><span>Run the cell that loads and calls the version_information command:<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1078ccb9-2f8c-4ad7-9416-98dc5052755e.png" style="width:47.00em;height:27.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting a Jupyter Notebook to a Python Script</h1>
                </header>
            
            <article>
                
<p>You can convert a Jupyter Notebook to a Python script. This is equivalent to copying and pasting the contents of each code cell into a single <kbd>.py</kbd> file. The Markdown sections are also included as comments.</p>
<p><span>The conversion can be done from the <kbd>NotebookApp</kbd> or in the command line as follows:<br/></span></p>
<p style="padding-left: 60px"><span><kbd>jupyter nbconvert --to=python chapter-1-notebook.ipynb</kbd><br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d010e40c-459e-4aca-a2c1-f39f66d1ee7f.png" style="width:73.08em;height:40.08em;"/></p>
<p>This is useful, for example, when you want to determine the library requirements for a Notebook using a tool such as <kbd>pipreqs</kbd>. This tool determines the libraries used in a project and exports them into a <kbd>requirements.txt</kbd> file (and it can be installed by running <kbd>pip install pipreqs</kbd>).</p>
<p>The command is called from outside the folder containing your <kbd>.py</kbd> files. For example, if the <kbd>.py</kbd> files are inside a folder called <kbd>chapter-1</kbd>, you could do the following:</p>
<pre style="padding-left: 60px">pipreqs chapter-1/<span><br/></span></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f02a2880-0b50-4c03-87df-a78f2596315c.png" style="width:77.33em;height:41.25em;"/></p>
<p><span>The resulting <kbd>requirements.txt</kbd> file for <kbd>chapter-1-workbook.ipynb</kbd> looks like this:<br/></span></p>
<pre><span>     cat chapter-1/requirements.txt<br/>     matplotlib==2.0.2<br/>     numpy==1.13.1<br/>     pandas==0.20.3<br/>     requests==2.18.4<br/>     seaborn==0.8<br/>     beautifulsoup4==4.6.0<br/>     scikit_learn==0.19.0</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Python Libraries</h1>
                </header>
            
            <article>
                
<p>Having now seen all the basics of Jupyter Notebooks, and even some more advanced features, we'll shift our attention to the Python libraries we'll be using in this book. Libraries, in general, extend the default set of Python functions. Examples of commonly used standard libraries are <kbd>datetime</kbd>, <kbd>time</kbd>, and <kbd>os</kbd>. These are called standard libraries because they come standard with every installation of Python.</p>
<p><span>For data science with Python, the most important libraries are external, which means they do not come standard with Python.</span></p>
<p><span> </span>The external data science libraries we'll be using in this book are <kbd>NumPy</kbd>, <kbd>Pandas</kbd>, <kbd>Seaborn</kbd>, <kbd>matplotlib</kbd>, <kbd>scikit-learn</kbd>, <kbd>Requests</kbd>, and <kbd>Bokeh</kbd>. Let's briefly introduce each.</p>
<div class="packt_infobox">It's a good idea to import libraries using industry standards, for example, <kbd>import numpy</kbd> as <kbd>np</kbd>; this way, your code is more readable. Try to avoid doing things such as from <kbd>numpy import *</kbd>, as you may unwittingly overwrite functions. Furthermore, it's often nice to have modules linked to the library via a dot (. ) for code readability.</div>
<ul>
<li><strong>NumPy</strong> offers multi-dimensional data structures (arrays) on which operations can be performed far quicker than standard Python data structures (for example, lists). This is done in part by performing operations in the background using C. NumPy also offers various mathematical and data manipulation functions.</li>
<li><strong>Pandas</strong> is Python's answer to the R DataFrame. It stores data in 2-D tabular structures where columns represent different variables and rows correspond to samples. Pandas provides many handy tools for data wrangling such as filling in <kbd>NaN</kbd> entries and computing statistical descriptions of the data. Working with Pandas DataFrames will be a big focus of this book.</li>
<li><strong>Matplotlib</strong> is a plotting tool inspired by the MATLAB platform. Those familiar with R can think of it as Python's version of ggplot. It's the most popular Python library for plotting figures and allows for a high level of customization.</li>
<li><strong>Seaborn</strong> works as an extension to matplotlib, where various plotting tools useful for data science are included. Generally speaking, this allows for analysis to be done much faster than if you were to create the same things manually with libraries such as matplotlib and scikit-learn.</li>
<li><strong>Scikit-learn</strong> is the most commonly used machine learning library. It offers top-of the-line algorithms and a very elegant API where models are instantiated and then fit with data. It also provides data processing modules and other tools useful for predictive analytics.</li>
</ul>
<ul>
<li><strong>Requests</strong> is the go-to library for making HTTP requests. It makes it straightforward to get HTML from web pages and interface with APIs. For parsing the HTML, many choose <kbd>BeautifulSoup4</kbd>, which we will also cover in this book.</li>
<li><strong>Bokeh</strong> is an interactive visualization library. It functions similar to matplotlib, but allows us to add hover, zoom, click, and use other interactive tools to our plots. It also allows us to render and play with the plots inside our Jupyter Notebook.</li>
</ul>
<p>Having introduced these libraries, let's go back to our Notebook and load them, by running the import statements. This will lead us into our fist analysis, where we finally start working with a dataset.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Import the external libraries and set up the plotting environment</h1>
                </header>
            
            <article>
                
<ol>
<li>Open up the <kbd>chapter 1</kbd> Jupyter Notebook and scroll to the <kbd>Python Libraries section</kbd>.</li>
</ol>
<p style="padding-left: 60px">Just like for regular Python scripts, libraries can be imported into the Notebook at any time. It's best practice to put the majority of the packages you use at the top of the file. Sometimes it makes sense to load things midway through the Notebook and that is completely OK.</p>
<ol start="2">
<li><span>Run the cells to import the external libraries and set the plotting options:<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4df0e5af-ac74-49d4-aa62-88e8cec74570.png" style="width:27.67em;height:17.58em;"/></p>
<p style="padding-left: 60px">For a nice Notebook setup, it's often useful to set various options along with the imports at the top. For example, the following can be run to change the figure appearance to something more aesthetically pleasing than the <kbd>matplotlib</kbd> and Seaborn defaults: </p>
<pre><span>    import matplotlib.pyplot as plt<br/>    %matplotlib inline<br/>    import seaborn as sns</span><br/>    # See here for more options: <br/>    <a href="https://matplotlib.org/users/customizing.html">https://matplotlib.org/users/customizing.html<br/></a><span>    %config InlineBackend.figure_format='retina'<br/>    sns.set() # Revert to matplotlib defaults<br/>    plt.rcParams['figure.figsize'] = (9, 6)<br/>    plt.rcParams['axes.labelpad'] = 10<br/>    sns.set_style("darkgrid")</span></pre>
<p class="mce-root">So far in this book, we've gone over the basics of using Jupyter Notebooks for data science. We started by exploring the platform and finding our way around the interface. Then, we discussed the most useful features, which include tab completion and magic functions. Finally, we introduced the Python libraries we'll be using in this book.</p>
<p class="mce-root">The next section will be very interactive as we perform our fist analysis together using the Jupyter Notebook.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Our First Analysis - The Boston Housing Dataset</h1>
                </header>
            
            <article>
                
<p>So far, this chapter has focused on the features and basic usage of Jupyter. Now, we'll put this into practice and do some data exploration and analysis.</p>
<p>The dataset we'll look at in this section is the so-called <em>Boston housing dataset</em>. It contains US census data concerning houses in various areas around the city of Boston. Each sample corresponds to a unique area and has about a dozen measures. We should think of samples as rows and measures as columns. The data was fist published in 1978 and is quite small, containing only about 500 samples.</p>
<p>Now that we know something about the context of the dataset, let's decide on a rough plan for the exploration and analysis. If applicable, this plan would accommodate the relevant question(s) under study. In this case, the goal is not to answer a question but to instead show Jupyter in action and illustrate some basic data analysis methods.</p>
<p><span>Our general approach to this analysis will be to do the following:<br/></span></p>
<ul>
<li>Load the data into Jupyter using a Pandas DataFrame</li>
<li>Quantitatively understand the features</li>
<li>Look for patterns and generate questions</li>
<li>Answer the questions to the problems<span><br/></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading the Data into Jupyter Using a Pandas DataFrame</h1>
                </header>
            
            <article>
                
<p>Oftentimes, data is stored in tables, which means it can be saved as a <kbd>comma-separated variable (CSV)</kbd> file. This format, and many others, can be read into Python as a DataFrame object, using the Pandas library. Other common formats include <kbd>tab-separated variable (TSV)</kbd>, SQL tables, and JSON data structures. Indeed, Pandas has support for all of these. In this example, however, we are not going to load the data this way because the dataset is available directly through scikit-learn.</p>
<div class="packt_infobox">An important part after loading data for analysis is ensuring that it's clean. For example, we would generally need to deal with missing data and ensure that all columns have the correct datatypes. The dataset we use in this section has already been cleaned, so we will not need to worry about this. However, we'll see messier data in the second chapter and explore techniques for dealing with it.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Load the Boston housing dataset</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>In the chapter 1 Jupyter Notebook, scroll to subtopic <kbd>Loading the Data into Jupyter Using a Pandas DataFrame</kbd><em> </em><span><em> </em></span>of <kbd>Our First Analysis</kbd>: <kbd>The Boston Housing Dataset</kbd>. The Boston housing dataset can be accessed from the <kbd>sklearn.datasets</kbd> module using the <kbd>load_boston</kbd> method.</p>
</li>
<li><span>Run the first two cells in this section to load the Boston dataset and see the data structures type:<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f8abc0d1-4ae2-486b-852e-367c2eeaf03d.png" style="width:28.00em;height:9.92em;"/></p>
<p style="padding-left: 60px"><span>The output of the second cell tells us that it's a scikit-learn Bunch object. Let's get some more information about that to understand what we are dealing with.</span></p>
<ol start="3">
<li><span>Run the next cell to import the base object from scikit-learn utils and print the docstring in our Notebook:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/52761b21-8607-4edf-9a8d-50cdda5ceafc.png" style="width:39.58em;height:17.92em;"/><br/></span></p>
<p style="padding-left: 60px"><span>Reading the resulting docstring suggests that it's basically a dictionary, and can essentially be treated as such.<br/></span></p>
<ol start="4">
<li>Print the field names (that is, the keys to the dictionary) by running the next cell. We find these fields to be self-explanatory: [<kbd>'DESCR'</kbd>, <kbd>'target'</kbd>, <kbd>'data'</kbd>, <kbd>'feature_names'</kbd>] .</li>
</ol>
<ol start="5">
<li>Run the next cell to print the dataset description contained in boston[<kbd>'DESCR'</kbd>] . Note that in this call, we explicitly want to print the field value so that the Notebook renders the content in a more readable format than the string representation (that is, if we just type boston[<kbd>'DESCR'</kbd>] without wrapping it in a print statement). We then see the dataset information as we've previously summarized:</li>
</ol>
<pre style="padding-left: 90px"><span>    Boston House Prices dataset<br/>    ===========================<br/>    Notes<br/>    ------<br/>    Data Set Characteristics:<br/>    :Number of Instances: 506<br/>    :Number of Attributes: 13 numeric/categorical predictive<br/>    :Median Value (attribute 14) is usually the target<br/>    :Attribute Information (in order):<br/>    - CRIM per capita crime rate by town<br/>    …<br/>    - MEDV Median value of owner-occupied homes in $1000's<br/>    :Missing Attribute Values: None </span></pre>
<p style="padding-left: 60px"><span>Of particular importance here are the feature descriptions (under <kbd>Attribute Information</kbd>). We will use this as reference during our analysis.</span></p>
<p style="padding-left: 60px">Now, we are going to create a Pandas DataFrame that contains the data. This is beneficial for a few reasons: all of our data will be contained in one object, there are useful and computationally efficient DataFrame methods we can use, and other libraries such as Seaborn have tools that integrate nicely with DataFrames.</p>
<p style="padding-left: 60px"><span>In this case, we will create our DataFrame with the standard constructor method.<br/></span></p>
<ol start="6">
<li><span>Run the cell where Pandas is imported and the docstring is retrieved for <kbd>pd.DataFrame</kbd>:<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0ab67f16-3da3-41d0-87c6-be2fe8d1009c.png" style="width:48.17em;height:23.75em;"/></p>
<p style="padding-left: 60px"><span>The docstring reveals the DataFrame input parameters. We want to feed in boston[<kbd>'data'</kbd>] for the data and use boston[<kbd>'feature_names'</kbd>] for the headers.</span></p>
<ol start="7">
<li><span>Run the next few cells to print the data, its shape, and the feature names:<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/97e175b0-4092-4f73-93a1-90ed07264741.png" style="width:40.50em;height:30.00em;"/></p>
<p style="padding-left: 60px"><span>Looking at the output, we see that our data is in a <kbd>2D NumPy array</kbd>. Running the command boston[<kbd>'data'</kbd>].shape returns the length (number of samples) and the number of features as the first and second outputs, respectively<br/></span></p>
<ol start="8">
<li><span>Load the data into a Pandas DataFrame <kbd>df</kbd> by running the following:<br/></span></li>
</ol>
<pre style="padding-left: 90px">df = pd.DataFrame(data=boston['data'], columns=boston['feature_names'])</pre>
<p style="padding-left: 60px"><span>In machine learning, the variable that is being modeled is called the target variable; it's what you are trying to predict given the features. For this dataset, the suggested target is MEDV, the median house value in 1,000s of dollars</span></p>
<ol start="9">
<li><span>Run the next cell to see the shape of the target:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ffc414d7-7df4-4df1-aa4f-680e77eb0a19.png" style="width:28.50em;height:6.42em;"/></p>
<p style="padding-left: 60px"><span>We see that it has the same length as the features, which is what we expect. It can therefore be added as a new column to the DataFrame.<br/></span></p>
<ol start="10">
<li><span>Add the target variable to <kbd>df</kbd> by running the cell with the following:</span></li>
</ol>
<pre style="padding-left: 30px"><span>    </span>df['MEDV'] = boston['target']<span><br/></span></pre>
<ol start="11">
<li>To distinguish the target from our features, it can be helpful to store it at the front of our DataFrame.<br/>
Move the target variable to the front of df by running the cell with the following:<span><br/></span></li>
</ol>
<pre style="padding-left: 30px"><span>     y = df['MEDV'].copy()<br/>     del df['MEDV']<br/>     df = pd.concat((y, df), axis=1)</span></pre>
<p style="padding-left: 60px"><span>Here, we introduce a dummy variable y to hold a copy of the target column before removing it from the DataFrame. We then use the Pandas concatenation function to combine it with the remaining DataFrame along the 1st axis (as opposed to the 0th axis, which combines rows).<br/></span></p>
<div class="packt_infobox">You will often see dot notation used to reference DataFrame columns. For example, previously we could have done <kbd>y = df.MEDV.copy()</kbd> . This does not work for deleting columns, however; <kbd>del df.MEDV</kbd> would raise an error.</div>
<ol start="12">
<li><span>Now that the data has been loaded in its entirety, let's take a look at the DataFrame.<br/></span></li>
</ol>
<p style="padding-left: 60px">We can do <kbd>df.head()</kbd> or <kbd>df.tail()</kbd> to see a glimpse of the data and <kbd>len(df)</kbd> to make sure the number of samples is what we expect. Run the next few cells to see the head, tail, and length of <kbd>df</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3407f927-6154-49ed-9a5d-32a9e90fcad9.png" style="width:56.75em;height:20.67em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5be64859-764c-43ca-8268-1d44953c0bc7.png" style="width:57.25em;height:25.92em;"/></p>
<p style="padding-left: 60px"><span>Each row is labeled with an index value, as seen in bold on the left side of the table.By default, these are a set of integers starting at 0 and incrementing by one for each row.<br/></span></p>
<ol start="13">
<li>Printing <kbd>df.dtypes</kbd> will show the datatype contained within each column.</li>
</ol>
<p style="padding-left: 60px">Run the next cell to see the datatypes of each column.</p>
<p style="padding-left: 60px">For this dataset, we see that every field is a float and therefore most likely a continuous variable, including the target. This means that predicting the target variable is a regression problem.</p>
<ol start="14">
<li>The next thing we need to do is clean the data by dealing with any missing data, which Pandas automatically sets as <kbd>NaN</kbd> values. These can be identified by running <kbd>df.isnull()</kbd> , which returns a Boolean DataFrame of the same shape as <kbd>df.</kbd> To get the number of NaN's per column, we can do <kbd>df.isnull().sum()</kbd> . Run the next cell to calculate the number of <kbd>NaN</kbd> <span>values in each column:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9d9256fa-2766-47dc-9fc8-9298a704a2b5.png" style="width:19.00em;height:23.75em;"/></p>
<p style="padding-left: 60px">For this dataset, we see there are no NaN's, which means we have no immediate work to do in cleaning the data and can move on.</p>
<ol start="15">
<li><span>To simplify the analysis, the final thing we'll do before exploration is remove some of the columns. We won't bother looking at these, and instead focus on the remainder in more detail.</span></li>
</ol>
<p style="padding-left: 60px">  Remove some columns by running the cell that contains the following code:</p>
<pre style="padding-left: 60px"><span>  for col in ['ZN', 'NOX', 'RAD', 'PTRATIO', 'B']:<br/>     del df[col]</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data Exploration</h1>
                </header>
            
            <article>
                
<p><span>Since this is an entirely new dataset that we've never seen before, the first goal here is to understand the data. We've already seen the textual description of the data, which is important for qualitative understanding. We'll now compute a quantitative description.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Explore the Boston housing dataset</h1>
                </header>
            
            <article>
                
<ol>
<li><span>Navigate to Subtopic <em>Data exploration in the Jupyter Notebook</em> and run the cell containing <kbd>df.describe()</kbd> :<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5b92da6c-2b53-4acc-a447-113021e353da.png" style="width:63.75em;height:33.00em;"/></p>
<p style="padding-left: 60px">This computes various properties including the mean, standard deviation, minimum, and maximum for each column. This table gives a high-level idea of how everything is distributed. Note that we have taken the transform of the result by adding a .T to the output; this swaps the rows and columns. Going forward with the analysis, we will specify a set of columns to focus on.</p>
<ol start="2">
<li><span>Run the cell where these "focus columns" are defined:</span></li>
</ol>
<pre style="padding-left: 60px">    <span>cols = ['RM', 'AGE', 'TAX', 'LSTAT', 'MEDV'] </span></pre>
<ol start="3">
<li>
<p>This subset of columns can be selected from <kbd>df</kbd> using square brackets. Display this subset of the DataFrame by running <kbd>df[cols].head()</kbd> :</p>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d0f04873-7055-41ec-b6ef-4b1a0b7a2b70.png" style="width:22.67em;height:19.17em;"/></p>
<p style="padding-left: 60px"><span>As a reminder, let's recall what each of these columns is. From the dataset documentation, we have the following:</span></p>
<ul>
<li style="list-style-type: none">
<ul>
<li><span>RM average number of rooms per dwelling</span></li>
<li><span>AGE proportion of owner-occupied units built prior to 1940</span></li>
<li><span>TAX full-value property-tax rate per $10,000</span></li>
<li><span>LSTAT % lower status of the population</span></li>
<li><span>MEDV Median value of owner-occupied homes in $1000's</span></li>
</ul>
</li>
</ul>
<p style="padding-left: 60px"><span>To look for patterns in this data, we can start by calculating the pairwise correlations using <kbd>pd.DataFrame.corr</kbd>.<br/></span></p>
<ol start="4">
<li><span>Calculate the pairwise correlations for our selected columns by running the cell containing the following code:<br/></span></li>
</ol>
<pre style="padding-left: 60px">   df[cols].corr()<span><br/></span></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e79bc1bb-6cdf-4d9d-92cd-3be3db54084d.png" style="width:33.25em;height:16.08em;"/></p>
<p style="padding-left: 60px"><span>This resulting table shows the correlation score between each set of values. Large positive scores indicate a strong positive (that is, in the same direction) correlation.As expected, we see maximum values of 1 on the diagonal.<br/></span></p>
<p style="padding-left: 60px"><span>Pearson coefficient is defined as the co-variance between two variables,divided by the product of their standard deviations:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/c647c0e7-9bc6-4335-b95b-3ec6342cf11c.png" style="width:11.33em;height:4.17em;"/><br/></span></p>
<p style="padding-left: 60px"><span>The co-variance, in turn, is defined as follows:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c6309711-d7e1-4a6d-ae40-9c909ad8b76d.png" style="width:22.25em;height:4.67em;"/></p>
<p style="padding-left: 60px">Here, n is the number of samples, <em>x<sub>i</sub></em> and <em>y<sub>i</sub></em> are the individual samples being summed over, and <img class="fm-editor-equation" src="assets/1f9d23ad-d253-4355-9289-7d79761bc52c.png" style="width:1.42em;height:1.83em;"/> and <img class="fm-editor-equation" src="assets/46020eb6-e869-471d-9fa5-2e3b323b128e.png" style="width:1.42em;height:1.75em;"/>  are the means of each set.</p>
<p style="padding-left: 60px">Instead of straining our eyes to look at the preceding table, it's nicer to visualize it with a heatmap. This can be done easily with Seaborn.</p>
<ol start="5">
<li><span>Run the next cell to initialize the plotting environment, as discussed earlier in the chapter. Then, to create the heatmap, run the cell containing the following code:<br/></span></li>
</ol>
<pre><span>     import matplotlib.pyplot as plt<br/>     import seaborn as sns<br/>     %matplotlib inline <br/><br/></span><span>     ax = sns.heatmap(df[cols].corr(),<br/>     cmap=sns.cubehelix_palette(20, light=0.95, dark=0.15))<br/>     ax.xaxis.tick_top() # move labels to the top<br/>     plt.savefig('../figures/chapter-1-boston-housing-corr.png',<br/>     bbox_inches='tight', dpi=300)<br/> <br/></span></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3ec1a261-49e6-4b0f-819e-f39c15ac38a2.png" style="width:35.33em;height:25.17em;"/></p>
<p style="padding-left: 60px"><span>We call <kbd>sns.heatmap</kbd> and pass the pairwise correlation matrix as input. We use a custom color palette here to override the Seaborn default. The function returns a <kbd>matplotlib.axes</kbd> object which is referenced by the variable <kbd>ax</kbd>. The final figure is then saved as a high resolution PNG to the <kbd>figures</kbd> folder.<br/></span></p>
<ol start="6">
<li><span><span><span>For the final step in our dataset exploration exercise, we'll visualize our data using Seaborn's <kbd>pairplot</kbd> function.</span></span></span></li>
</ol>
<ol start="7">
<li>Visualize the DataFrame using Seaborn's pairplot function. Run the cell containing the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>     sns.pairplot(df[cols],<br/>     plot_kws={'alpha': 0.6},<br/>     diag_kws={'bins': 30}) </span></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c86a31f8-972a-4b13-8cbb-e07e5d4a60c5.png" style="width:49.00em;height:50.42em;"/></p>
<p style="padding-left: 60px"><span>Having previously used a heatmap to visualize a simple overview of the correlations, this plot allows us to see the relationships in far more detail.<br/></span> <span>Looking at the histograms on the diagonal, we see the following:<br/></span></p>
<ul>
<li style="list-style-type: none">
<ul>
<li><span>a: RM and MEDV have the closest shape to normal distributions.</span></li>
</ul>
<ul>
<li><span>b: AGE is skewed to the left and LSTAT is skewed to the right (this may seem counter intuitive but skew is defined in terms of where the mean is positioned in relation to the max).</span></li>
<li><span>c: For TAX, we find a large amount of the distribution is around 700. This is also<br/>
evident from the scatter plots<br/></span></li>
</ul>
</li>
</ul>
<p>Taking a closer look at the <strong>MEDV</strong> histogram in the bottom right, we actually see something similar to <strong>TAX</strong> where there is a large upper-limit bin around $50,000. Recall when we did <kbd>df.describe()</kbd> , the min and max of <strong>MDEV</strong> was 5k and 50k, respectively. This suggests that median house values in the dataset were capped at 50k.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to Predictive Analytics with Jupyter Notebooks</h1>
                </header>
            
            <article>
                
<p>Continuing our analysis of the Boston housing dataset, we can see that it presents us with a regression problem where we predict a continuous target variable given a set of features. In particular, we'll be predicting the median house value (<strong>MEDV</strong>). We'll train models that take only one feature as input to make this prediction. This way, the models will be conceptually simple to understand and we can focus more on the technical details of the scikit-learn API. Then, in the next chapter, you'll be more comfortable dealing with the relatively complicated models.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linear models with Seaborn and scikit-learn</h1>
                </header>
            
            <article>
                
<ol>
<li>Scroll to Subtopic<kbd>Introduction to predictive analytics</kbd> in the Jupyter Notebook and look just above at the pairplot we created in the previous section. In particular, look at the scatter plots in the bottom-left corner:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7eb25257-8cc2-4530-af19-ec880503a76e.png" style="width:46.58em;height:47.25em;"/></p>
<p style="padding-left: 60px">Note how the number of rooms per house (<strong>RM</strong>) and the % of the population that is lower class (<strong>LSTAT</strong>) are highly correlated with the median house value (<strong>MDEV</strong>). Let's pose the following question: how well can we predict <strong>MDEV</strong> given these variables?</p>
<p style="padding-left: 60px">To help answer this, let's first visualize the relationships using Seaborn. We will draw the scatter plots along with the line of best fit linear models.</p>
<ol start="2">
<li><span>Draw scatter plots along with the linear models by running the cell that contains the following:</span></li>
</ol>
<pre style="padding-left: 60px"><span>    fig, ax = plt.subplots(1, 2)<br/>    sns.regplot('RM', 'MEDV', df, ax=ax[0],<br/>    scatter_kws={'alpha': 0.4}))<br/>    sns.regplot('LSTAT', 'MEDV', df, ax=ax[1],<br/>    scatter_kws={'alpha': 0.4})) </span></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e880df1f-bc8e-4f12-936c-bb362791395d.png" style="width:45.25em;height:30.33em;"/></p>
<p style="padding-left: 60px">The line of best fit is calculated by minimizing the ordinary least squares error function, something Seaborn does automatically when we call the <kbd>regplot</kbd> function. Also note the shaded areas around the lines, which represent 95% confidence intervals.</p>
<div class="packt_infobox">These 95% confidence intervals are calculated by taking the standard deviation of data in bins perpendicular to the line of best fit, effectively determining the confidence intervals at each point along the line of best fit. In practice, this involves Seaborn bootstrapping the data, a process where new data is created through random sampling with replacement. The number of bootstrapped samples is automatically determined based on the size of the dataset, but can be manually set as well by passing the <kbd>n_boot</kbd> argument.</div>
<ol start="3">
<li>Seaborn can also be used to plot the residuals for these relationships. Plot the residuals by running the cell containing the following:</li>
</ol>
<pre style="padding-left: 60px"><span>    </span>fig, ax = plt.subplots(1, 2)<br/>    ax[0] = sns.residplot('RM', 'MEDV', df, ax=ax[0],<br/>                      scatter_kws={'alpha': 0.4})<br/>    ax[0].set_ylabel('MDEV residuals $(y-\hat{y})$')<br/>    ax[1] = sns.residplot('LSTAT', 'MEDV', df, ax=ax[1],<br/>                      scatter_kws={'alpha': 0.4})<br/>    ax[1].set_ylabel('')</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ca395a1c-acc4-465a-b249-23a594b7248c.png" style="width:62.58em;height:41.75em;"/></p>
<p style="padding-left: 60px"><span>Each point on these residual plots is the difference between that sample (y) and the linear model prediction ( ŷ). Residuals greater than zero are data points that would be underestimated by the model. Likewise, residuals less than zero are data points that would be overestimated by the model.<br/></span></p>
<p style="padding-left: 60px"><span>Patterns in these plots can indicate sub optimal modeling. In each preceding case,we see diagonally arranged scatter points in the positive region. These are caused by the $50,000 cap on MEDV. The RM data is clustered nicely around 0, which indicates a good fit. On the other hand, LSTAT appears to be clustered lower than 0.<br/></span></p>
<p class="mce-root"/>
<ol start="4">
<li>Moving on from visualizations, the fits can be quantified by calculating the mean squared error. We'll do this now using scikit-learn. Defile a function that calculates the line of best fit and mean squared error, by running the cell that contains the following:</li>
</ol>
<pre style="padding-left: 60px"><span>      def get_mse(df, feature, target='MEDV'):<br/>      # Get x, y to model<br/>      y = df[target].values<br/>      x = df[feature].values.reshape(-1,1)<br/>      ...<br/>      ...<br/>      error = mean_squared_error(y, y_pred)<br/>      print('mse = {:.2f}'.format(error))<br/>      print() </span></pre>
<p style="padding-left: 60px">In the <kbd>get_mse</kbd> function, we first assign the variables y and x to the target <strong>MDEV</strong> and the dependent feature, respectively. These are cast as <kbd>NumPy</kbd> arrays by calling the values attribute. The dependent features array is reshaped to the format expected by scikit-learn; this is only necessary when modeling a one-dimensional feature space. The model is then instantiated and fitted on the data. For linear regression, the fitting consists of computing the model parameters using the ordinary least squares method (minimizing the sum of squared errors for each sample). Finally, after determining the parameters, we predict the target variable and use the results to calculate the MSE.</p>
<ol start="5">
<li><span>Call the <kbd>get_mse</kbd> function for both RM and LSTAT, by running the cell containing the following:<br/></span></li>
</ol>
<pre><span>      get_mse(df, 'RM')<br/>      get_mse(df, 'LSTAT') <br/></span></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2f6eb116-2c27-4a0b-9655-bc72b31b0631.png" style="width:26.42em;height:15.17em;"/></p>
<p style="padding-left: 60px">Comparing the <strong>MSE</strong>, it turns out the error is slightly lower for <strong>LSTAT</strong>. Looking back to the scatter plots, however, it appears that we might have even better success using a polynomial model for LSTAT. In the next activity, we will test this by computing a third order polynomial model with scikit-learn.</p>
<p style="padding-left: 60px">Forgetting about our Boston housing dataset for a minute, consider another real-world situation where you might employ polynomial regression. The following example is modeling weather data. In the following plot, we see temperatures (lines) and precipitations (bars) for Vancouver, BC, Canada:</p>
<p class="CDPAlignCenter CDPAlign" style="padding-left: 60px"><img src="assets/03049e0f-c8d0-41a5-94fa-18f6412ef434.png" style="width:65.00em;height:38.42em;"/></p>
<p style="padding-left: 60px">Any of these fields are likely to be fit quite well by a fourth-order polynomial. This would be a very valuable model to have, for example, if you were interested in predicting the temperature or precipitation for a continuous range of dates.</p>
<p style="padding-left: 60px"><span>You can find the data source for this here:<br/></span></p>
<p style="padding-left: 60px"><a href="http://climate.weather.gc.ca/climate_normals/results_e.html?stnID=888.">http://climate.weather.gc.ca/climate_normals/results_e.html?stnID=888.</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activity:Building a Third-Order Polynomial Model</h1>
                </header>
            
            <article>
                
<p>Shifting our attention back to the Boston housing dataset, we would like to build a third order polynomial model to compare against the linear one. Recall the actual problem we are trying to solve: predicting the median house value, given the lower class population percentage. This model could benefit a prospective Boston house purchaser who cares about how much of their community would be lower class.</p>
<p><span>Use scikit-learn to fit a polynomial regression model to predict the median house value (MEDV), given the LSTAT values. We are hoping to build a model that has a lower meansquared error (MSE).<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linear models with Seaborn and scikit-learn</h1>
                </header>
            
            <article>
                
<ol>
<li>Scroll to the empty cells at the bottom of <kbd>Subtopic Introduction to Predictive Analysis in your Jupyter Notebook</kbd>.These will be found beneath the linear-model MSE calculation cell under the Activity heading.</li>
</ol>
<div class="packt_infobox">You should fill these empty cells in with code as we complete the activity. You may need to insert new cells as these become filled up; please do so as needed!</div>
<ol start="2">
<li>Given that our data is contained in the DataFrame <kbd>df</kbd>, we will fist pull out our dependent feature and target variable using the following:</li>
</ol>
<pre style="padding-left: 60px"><span>    y = df['MEDV'].values<br/>    x = df['LSTAT'].values.reshape(-1,1) </span></pre>
<p style="padding-left: 60px"><span>This is identical to what we did earlier for the linear model.<br/></span></p>
<ol start="3">
<li><span>Check out what x looks like by printing the fist few samples with print(x[:3]) :<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8abfeb62-7431-408c-8833-3eccf8787534.png" style="width:21.58em;height:11.08em;"/></p>
<p style="padding-left: 60px"><span>Notice how each element in the array is itself an array with length 1. This is what<kbd> reshape(-1,1)</kbd> does, and it is the form expected by scikit-learn.<br/></span></p>
<ol start="4">
<li><span>Next, we are going to transform x into "polynomial features". The rationale for this may not be immediately obvious but will be explained shortly.<br/></span> <span>Import the appropriate transformation tool from scikit-learn and instantiate the third-degree polynomial feature transformer:</span></li>
</ol>
<pre style="padding-left: 60px"><span>    from sklearn.preprocessing import PolynomialFeatures<br/>    poly = PolynomialFeatures(degree=3) </span></pre>
<ol start="5">
<li><span>At this point, we simply have an instance of our feature transformer. Now, let's use it to transform the LSTAT feature (as stored in the variable x) by running the <kbd>fit_transform</kbd> method.<br/></span></li>
</ol>
<p style="padding-left: 60px"><span>Build the polynomial feature set by running the following code:<br/></span></p>
<pre style="padding-left: 60px">     <span>x_poly = poly.fit_transform(x) </span></pre>
<ol start="6">
<li><span>Check out what <kbd>x_poly</kbd> looks like by printing the fist few samples with print(<kbd>x_poly[:3]</kbd>) .</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3f3370ee-c31c-4727-a552-c84ce7b6b512.png" style="font-size: 1em;width:35.75em;height:8.67em;"/></p>
<p style="padding-left: 60px"><span>Unlike x, the arrays in each row now have length 4, where the values have been calculated as x<sup>0</sup>, x<sup>1</sup>, x<sup>2</sup> and x<sup>3</sup>.<br/></span></p>
<p style="padding-left: 60px"><span>We are now going to use this data to fit a linear model. Labeling the features as a, b, c, and d, we will calculate the coefficients α<sub>0</sub>, α<sub>1</sub>, α<sub>2</sub>, and α<sub>3</sub> and of the linear model:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f3d84ebf-c30f-4b47-9a2b-838a2180dc86.png" style="width:16.67em;height:2.00em;"/></p>
<p style="padding-left: 60px"><span>We can plug in the definitions of a, b, c, and d, to get the following polynomial model, where the coefficients are the same as the previous ones:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c6c3cd61-d065-4a26-92df-1986f0851a40.png" style="width:16.67em;height:1.92em;"/></p>
<ol start="7">
<li><span>We'll import the Linear Regression class and build our linear classification model the same way as before, when we calculated the <strong>MSE</strong>. Run the following:<br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>    from sklearn.linear_model import LinearRegression<br/>    clf = LinearRegression()<br/>    clf.fit(x_poly, y) </span></pre>
<ol start="8">
<li><span>Extract the coefficients and print the polynomial model using the following code:<br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>    a_0 = clf.intercept_ + clf.coef_[0]   #intercept<br/>    a_1, a_2, a_3 = clf.coef_[1:]         #other coefficients<br/>    msg = 'model: y = {:.3f} + {:.3f}x + <br/>    {:.3f}x^2 + {:.3f}x^3'\.format(a_0, a_1,  a_2, a_3)<br/>    print(msg) </span></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9b204ff8-27d6-41b5-b1c9-ac4b3b250c55.png" style="width:36.83em;height:6.33em;"/></p>
<p style="padding-left: 60px"><span>To get the actual model intercept, we have to add the <kbd>intercept_ and coef_[0]</kbd>attributes. The higher-order coefficients are then given by the remaining values of <kbd>coef_.</kbd><br/></span></p>
<ol start="9">
<li><span>Determine the predicted values for each sample and calculate the residuals by running the following code:<br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>    y_pred = clf.predict(x_poly)<br/>    resid_MEDV = y - y_pred </span></pre>
<ol start="10">
<li><span>Print some of the residual values by running print(<kbd>resid_MEDV[:10]</kbd>) :<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f2de5a79-3841-4241-a9a0-b08db4d56950.png" style="width:40.50em;height:6.75em;"/></p>
<p class="mce-root" style="padding-left: 60px">We'll plot these soon to compare with the linear model residuals, but first we will calculate the <strong>MSE</strong>.</p>
<ol start="11">
<li>Run the following code to print the MSE for the third-order polynomial model:</li>
</ol>
<pre style="padding-left: 60px"><span>    from sklearn.metrics import mean_squared_error<br/>    error = mean_squared_error(y, y_pred)<br/>    print('mse = {:.2f}'.format(error)) </span></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/63360ff2-9188-47ac-9d96-324b2956b255.png" style="width:23.08em;height:5.17em;"/></p>
<p class="mce-root"/>
<p style="padding-left: 60px">As can be seen, the <strong>MSE</strong> is significantly less for the polynomial model compared to the linear model (which was 38.5). This error metric can be converted to an average error in dollars by taking the square root. Doing this for the polynomial model, we find the average error for the median house value is only $5,300.</p>
<p style="padding-left: 60px">Now, we'll visualize the model by plotting the polynomial line of best fit along with the data.</p>
<ol start="12">
<li><span>Plot the polynomial model along with the samples by running the following:<br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>    fig, ax = plt.subplots()<br/>    # Plot the samples<br/>    ax.scatter(x.flatten(), y, alpha=0.6)<br/>    # Plot the polynomial model<br/>    x_ = np.linspace(2, 38, 50).reshape(-1, 1)<br/>    x_poly = poly.fit_transform(x_)<br/>    y_ = clf.predict(x_poly)<br/>    ax.plot(x_, y_, color='red', alpha=0.8)<br/>    ax.set_xlabel('LSTAT'); ax.set_ylabel('MEDV'); </span></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cad9c13c-603c-49df-9042-deea5d0a3073.png" style="width:42.25em;height:28.67em;"/></p>
<p style="padding-left: 60px">Here, we are plotting the red curve by calculating the polynomial model predictions on an array of x values. The array of x values was created using <kbd>np.linspace</kbd>, resulting in 50 values arranged evenly between 2 and 38.</p>
<p style="padding-left: 60px">Now, we'll plot the corresponding residuals. Whereas we used Seaborn for this earlier, we'll have to do it manually to show results for a scikit-learn model. Since we already calculated the residuals earlier, as reference by the <kbd>resid_MEDV</kbd> variable, we simply need to plot this list of values on a scatter chart.</p>
<ol start="13">
<li><span>Plot the residuals by running the following:</span></li>
</ol>
<pre style="padding-left: 60px"><span>    fig, ax = plt.subplots(figsize=(5, 7))<br/>    ax.scatter(x, resid_MEDV, alpha=0.6)<br/>    ax.set_xlabel('LSTAT')<br/>    ax.set_ylabel('MEDV Residual $(y-\hat{y})$')    <br/>    plt.axhline(0, color='black', ls='dotted'); </span></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f2a0295-d952-4279-b9f0-6b3c9783d272.png" style="width:29.33em;height:37.08em;"/></p>
<p style="padding-left: 60px"><span>Compared to the linear model LSTAT residual plot, the polynomial model residuals appear to be more closely clustered around y - ŷ = 0. Note that y is the sample MEDV and ŷ is the predicted value. There are still clear patterns, such as the cluster near x = 7 and y = -7 that indicates suboptimal modeling.<br/></span></p>
<p><span>Having successfully modeled the data using a polynomial model, let's finish up this chapter by looking at categorical features. In particular, we are going to build a set of categorical features and use them to explore the dataset in more detail.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Categorical Features for Segmentation Analysis</h1>
                </header>
            
            <article>
                
<p><span>Often, we find datasets where there are a mix of continuous and categorical fields. In such cases, we can learn about our data and find patterns by segmenting the continuous variables with the categorical fields.</span></p>
<p><span> </span>As a specific example, imagine you are evaluating the return on investment from an ad campaign. The data you have access to contain measures of some calculated <strong>return on investment (ROI)</strong> metric. These values were calculated and recorded daily and you are analyzing data from the previous year. You have been tasked with finding data-driven insights on ways to improve the ad campaign. Looking at the ROI daily time series, you see a weekly oscillation in the data. Segmenting by day of the week, you find the following ROI distributions (where 0 represents the fist day of the week and 6 represents the last).</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d5d7241b-a0c9-4edc-94fa-5587503134ce.png" style="width:32.50em;height:26.50em;"/></p>
<p>As a specific example, imagine you are evaluating the return on investment from an ad campaign. The data you have access to contain measures of some calculated return on investment (<strong>ROI</strong>) metric. These values were calculated and recorded daily and you are analyzing data from the previous year. You have been tasked with finding data-driven insights on ways to improve the ad campaign. Looking at the ROI daily time series, you see a weekly oscillation in the data. Segmenting by day of the week, you find the following ROI distributions (where 0 represents the fist day of the week and 6 represents the last).</p>
<p>Since we don't have any categorical fields in the Boston housing dataset we are working with, we'll create one by effectively discretizing a continuous field. In our case, this will involve binning the data into "low", "medium", and "high" categories. It's important to note that we are not simply creating a categorical data field to illustrate the data analysis concepts in this section. As will be seen, doing this can reveal insights from the data that would otherwise be difficult to notice or altogether unavailable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Create categorical filelds from continuous variables and make segmented visualizations</h1>
                </header>
            
            <article>
                
<ol>
<li><span>Scroll up to the pair plot in the Jupyter Notebook where we compared MEDV, LSTAT, TAX, AGE, and RM:<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/23eae59d-883a-422a-a632-3517aba32418.png" style="width:45.00em;height:46.08em;"/></p>
<p style="padding-left: 60px"><span>Take a look at the panels containing AGE. As a reminder, this feature is defined as the <em>proportion of owner-occupied units built prior to 1940</em>. We are going to convert this feature to a categorical variable. Once it's been converted, we'll be able to replot this figure with each panel segmented by color according to the age category.</span></p>
<ol start="2">
<li><span>Scroll down to Subtopic <kbd>Building and exploring categorical features</kbd> and click into the first cell. Type and execute the following to plot the AGE cumulative distribution:<br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>    sns.distplot(df.AGE.values, bins=100,<br/>    hist_kws={'cumulative': True},<br/>    kde_kws={'lw': 0})<br/>    plt.xlabel('AGE')<br/>    plt.ylabel('CDF')<br/>    plt.axhline(0.33, color='red')<br/>    plt.axhline(0.66, color='red')<br/>    plt.xlim(0, df.AGE.max()); </span></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c7a01b08-8166-44f5-9c8b-f3e35f74ee26.png" style="width:53.92em;height:35.92em;"/></p>
<p style="padding-left: 60px"><span>Note that we set <kbd>kde_kws={'lw': 0}</kbd> in order to bypass plotting the kernel density estimate in the preceding figure.<br/></span></p>
<p style="padding-left: 60px">Looking at the plot, there are very few samples with low AGE, whereas there are far more with a very large AGE. This is indicated by the steepness of the distribution on the far right-hand side.</p>
<ol start="3">
<li>The red lines indicate 1/3 and 2/3 points in the distribution. Looking at the places where our distribution intercepts these horizontal lines, we can see that only about 33% of the samples have AGE less than 55 and 33% of the samples have AGE greater than 90! In other words, a third of the housing communities have less than 55% of homes built prior to 1940. These would be considered relatively new communities. On the other end of the spectrum, another third of the housing communities have over 90% of homes built prior to 1940. These would be considered very old.</li>
</ol>
<p style="padding-left: 60px"> We'll use the places where the red horizontal lines intercept the distribution as a guide to split the feature into categories: <strong>Relatively New</strong>, R<strong>elatively Old</strong>, and <strong>Very Old</strong>.</p>
<ol start="4">
<li><span>Setting the segmentation points as 50 and 85, create a new categorical feature by running the following code:</span></li>
</ol>
<pre style="padding-left: 60px">    def get_age_category(x):<br/>        if x &lt; 50:<br/>            return 'Relatively New'<br/>        elif 50 &lt;= x &lt; 85:<br/>            return 'Relatively Old'<br/>        else:<br/>            return 'Very Old'<br/>    df['AGE_category'] = df.AGE.apply(get_age_category)</pre>
<p style="padding-left: 60px">Here, we are using the very handy Pandas method apply, which applies a function to a given column or set of columns. The function being applied, in this case <kbd>get_ age_category</kbd>, should take one argument representing a row of data and return one value for the new column. In this case, the row of data being passed is just a single value, the AGE of the sample.</p>
<div class="packt_infobox">The apply method is great because it can solve a variety of problems and allows for easily readable code. Often though, vectorized methods such as <kbd>pd.Series.str</kbd> can accomplish the same thing much faster. Therefore, it's advised to avoid using it if possible, especially when working with large datasets. We'll see some examples of vectorized methods in the upcoming chapters.</div>
<ol start="5">
<li><span>Check on how many samples we've grouped into each age category by typing  <kbd>df.groupby('AGE_category').size()</kbd><br/>
 </span><span>into a new cell and running<br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4f1ec257-1b37-4971-b906-e3830e0efde2.png" style="width:19.58em;height:9.25em;"/></p>
<p style="padding-left: 60px">Looking at the result, it can be seen that two class sizes are fairly equal, and the Very Old group is about 40% larger. We are interested in keeping the classes comparable in size, so that each is well-represented and it's straightforward to make inferences from the analysis.</p>
<div class="packt_infobox">It may not always be possible to assign samples into classes evenly, and in real-world situations, it's very common to find highly imbalanced classes. In such cases, it's important to keep in mind that it will be difficult to make statistically significant claims with respect to the under-represented class. Predictive analytics with imbalanced classes can be particularly difficult. The following blog post offers an excellent summary on methods for handling imbalanced classes when doing machine learning: <a href="https://svds.com/learning-imbalanced-classes/">https://svds.com/learning-imbalanced-classes/</a>.</div>
<p style="padding-left: 60px"><span>Let's see how the target variable is distributed when segmented by our new feature <kbd>AGE_category</kbd>.</span></p>
<ol start="6">
<li>Make a violin plot by running the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>    sns.violinplot(x='MEDV', y='AGE_category', data=df,<br/>    order=['Relatively New', 'Relatively Old', 'Very Old']); </span></pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c6ed1d55-c026-4cb8-b99e-9800c8c75191.png" style="width:54.67em;height:33.75em;"/></p>
<p style="padding-left: 60px">The violin plot shows a kernel density estimate of the median house value distribution for each age category. We see that they all resemble a normal distribution. The Very Old group contains the lowest median house value samples and has a relatively large width, whereas the other groups are more tightly centered around their average. The young group is skewed to the high end, which is evident from the enlarged right half and position of the white dot in the thick black line within the body of the distribution.</p>
<p style="padding-left: 60px">This white dot represents the mean and the thick black line spans roughly 50% of the population (it fills to the first quantile on either side of the white dot). The thin black line represents boxplot whiskers and spans 95% of the population. This inner visualization can be modified to show the individual data points instead by passing <kbd>inner='point' to sns.violinplot()</kbd> . Let's do that now.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="7">
<li>Redo the violin plot adding the inner='point' argument to the sns.violinplot call:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/79627d7e-5d70-4123-bac1-dbc55c3ed7e1.png" style="font-size: 1em;text-align: center;color: #333333;width:58.08em;height:35.83em;"/></p>
<p style="padding-left: 60px">It's good to make plots like this for test purposes in order to see how the underlying data connects to the visual. We can see, for example, how there are no median house values lower than roughly $16,000 for the Relatively New segment, and therefore the distribution tail actually contains no data. Due to the small size of our dataset (only about 500 rows), we can see this is the case for each segment.</p>
<ol start="8">
<li>Re-do the pairplot from earlier, but now include color labels for each AGE category.This is done by simply passing the hue argument, as follows:</li>
</ol>
<pre style="padding-left: 60px">    cols = ['RM', 'AGE', 'TAX', 'LSTAT', 'MEDV', 'AGE_category']<br/>    sns.pairplot(df[cols], hue='AGE_category',<br/>    hue_order=['Relatively New', 'Relatively Old', 'Very Old'],<br/>    plot_kws={'alpha': 0.5}, diag_kws={'bins': 30}); </pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3387bd48-7536-44ce-b68f-5fbaeb4dd8c4.png" style="width:58.42em;height:52.00em;"/></p>
<p style="padding-left: 60px">Looking at the histograms, the underlying distributions of each segment appear similar for <strong>RM</strong> and <strong>TAX</strong>. The <strong>LSTAT</strong> distributions, on the other hand, look more distinct. We can focus on them in more detail by again using a violin plot.</p>
<ol start="9">
<li>Make a violin plot comparing the LSTAT distributions for each <kbd>AGE_category</kbd> segment:<span><br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/284438ae-9698-441c-8476-b4b918a30101.png" style="width:67.00em;height:41.00em;"/></p>
<p style="padding-left: 60px">Unlike the <strong>MEDV</strong> violin plot, where each distribution had roughly the same width, here we see the width increasing along with <strong>AGE</strong>. Communities with primarily old houses (the Very Old segment) contain anywhere from very few to many lower class residents, whereas Relatively New communities are much more likely to be predominantly higher class, with over 95% of samples having less lower class percentages than the Very Old communities. This makes sense, because Relatively New neighborhoods would be more expensive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have seen the fundamentals of data analysis in Jupyter.</p>
<p>We began with usage instructions and features of Jupyter such as magic functions and tab completion. Then, transitioning to data-science-specific material, we introduced the most important libraries for data science with Python.</p>
<p>In the latter half of the chapter, we ran an exploratory analysis in a live Jupyter Notebook. Here, we used visual assists such as scatter plots, histograms, and violin plots to deepen our understanding of the data. We also performed simple predictive modeling, a topic which will be the focus of the following chapter in this book.</p>
<p>In the next chapter, we will discuss how to approach predictive analytics, what things to consider when preparing the data for modeling, and how to implement and compare a variety of models using Jupyter Notebooks.</p>


            </article>

            
        </section>
    </body></html>