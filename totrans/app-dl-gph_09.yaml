- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Recommendation Systems Using Graph Deep Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Recommendation systems** have become an integral part of our digital landscape,
    profoundly shaping how we interact with content, products, and services across
    various industries. From e-commerce giants such as Amazon to streaming platforms
    such as Netflix, and social media networks such as Facebook, these systems play
    a crucial role in enhancing user experience, driving engagement, and boosting
    business outcomes. As we delve into the world of building recommendation systems
    using graph deep learning, it’s essential to understand the evolution of these
    systems and the transformative potential of graph-based approaches.'
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, recommendation systems have relied on techniques such as **collaborative
    filtering** ( **CF** ), content-based filtering, and hybrid approaches. While
    these methods have been successful to a certain extent, they often fall short
    in capturing the complex, interconnected nature of user-item interactions and
    the rich contextual information surrounding these interactions. This is where
    graph deep learning enters the picture, offering a paradigm shift in how we approach
    recommendation tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Graph-based methods in recommendation systems offer numerous advantages, including
    providing a rich multi-modal representation of diverse information types, the
    ability to capture higher-order relationships beyond direct user-item interactions,
    handle data sparsity effectively through information propagation, inductive learning
    capabilities for addressing cold start problems, enhanced interpretability through
    graph structure analysis, and flexibility in incorporating various types of side
    information and heterogeneous data. Collectively, these features enable graph-based
    approaches to provide more comprehensive, accurate, and adaptable recommendations
    by leveraging the complex relationships and structures inherent in user-item interaction
    data and associated contextual information.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we progress through this chapter, we’ll explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of recommendation systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph structures in recommendation systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph-based recommendation models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training graph deep learning models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explainability in graph-based recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **cold** **start problem**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fundamentals of recommendation systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommendation systems, also known as **recommender systems** , are intelligent
    algorithms that are designed to predict and suggest items or content that users
    might find interesting or relevant. These systems analyze patterns in user behavior,
    preferences, and item characteristics to generate personalized recommendations.
    The primary purpose of recommendation systems is to enhance the user experience
    by providing relevant content, increasing user engagement and retention, driving
    sales and conversions in e-commerce platforms, facilitating content discovery
    in large item catalogs, and personalizing services across various domains. Recommendation
    systems play a crucial role in addressing the information overload problem by
    filtering and prioritizing content based on user preferences and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendation systems have become an integral part of our digital experiences,
    influencing our choices in various domains, such as e-commerce, entertainment,
    social media, and more. This section delves into the core concepts, types, and
    evaluation metrics of recommendation systems, providing a solid foundation for
    understanding their role in modern applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a streaming service that’s trying to build a recommendation system
    for its users. The company has user-movie interaction data as well as metadata
    for every single movie available. We’ll look at how we can leverage this data
    to provide better recommendations and increase the net promoter scores and watch
    times of the users effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Types of recommendation systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three main types of recommendation systems, each with its unique
    approach to generating recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CF** is based on the premise that users with similar preferences in the past
    will have similar preferences in the future. It utilizes user-item interaction
    data to identify patterns and make predictions. There are two main approaches:
    user-based CF, which recommends items liked by similar users, and item-based CF,
    which recommends items similar to those the user has liked in the past. CF has
    the advantage of capturing complex user preferences and working well with sparse
    data. However, it faces challenges such as the cold start problem for new users
    or items and scalability issues with large datasets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our movie recommendation system, let’s consider a user, Alice, who has rated
    several movies highly, including *The Shawshank Redemption* (5 stars), *Pulp Fiction*
    (4 stars), and *The Godfather* (5 stars). User-based CF would find users with
    similar rating patterns to Alice, such as Bob, who has rated these same movies
    similarly and gave a high rating to *Inception* . So, the system might recommend
    *Inception* to Alice based on Bob’s high rating. Item-based CF, on the other hand,
    would find movies similar to those Alice rated highly. It might determine that
    users who liked *The Shawshank Redemption* also enjoyed *The Green Mile* , leading
    to a recommendation for Alice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Content-based filtering** recommends items based on their features and the
    user’s past preferences. It builds a profile for each user and item based on their
    characteristics and uses similarity measures between user profiles and item features
    to generate recommendations. This approach has the advantage of providing explanations
    for recommendations and working well for niche items. However, it has limitations
    in expanding a user’s interests and requires rich item metadata. In our movie
    example, we’d analyze the features of movies Alice likes, such as *The Shawshank
    Redemption* (drama, directed by Frank Darabont, starring Tim Robbins and Morgan
    Freeman, released in 1994) and *The Godfather* (crime/drama, directed by Francis
    Ford Coppola, starring Marlon Brando and Al Pacino, released in 1972). In this
    case, the system might recommend other drama movies from the 1970s or 1990s, or
    films featuring Morgan Freeman or Al Pacino.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid systems** combine multiple recommendation approaches to leverage their
    strengths and mitigate weaknesses. Common hybrid strategies include weighted approaches
    that combine scores from different recommenders, switching methods that choose
    between different recommenders based on the context, and feature combination techniques
    that use features from different sources as input to a single recommender. Hybrid
    systems often provide better performance but come with increased complexity in
    terms of their design and implementation. In our example, a hybrid approach might
    combine CF and content-based filtering. It could use CF to find similar users
    to Alice and then filter those recommendations based on content features she prefers,
    such as favoring dramas or movies from certain decades.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Table 9.1* provides a comparison of the different types, highlighting their
    key characteristics, advantages, and limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **CF** | **Content-based filtering** | **Hybrid systems** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Data required | User-item interactions | Item features and user preferences
    | Both types of data |'
  prefs: []
  type: TYPE_TB
- en: '| Strengths | - Captures user preferences well- Discovers new interests- Works
    with minimal item information | - No cold start problem for items- Can explain
    recommendations- Good for niche items | - Better accuracy- Overcomes limitations
    of individual methods- More robust |'
  prefs: []
  type: TYPE_TB
- en: '| Weaknesses | - Cold start problem- Sparsity issues- Limited for new items
    | - Limited serendipity- Requires detailed item features- Over-specialization
    | - Complex implementation- Computationally expensive- Requires more data |'
  prefs: []
  type: TYPE_TB
- en: '| Best use cases | E-commerce, social media | News articles, specialized content
    | Large-scale platforms, streaming services |'
  prefs: []
  type: TYPE_TB
- en: Table 9.1 – Comparing different recommendation system types
  prefs: []
  type: TYPE_NORMAL
- en: Key metrics and evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Evaluating the performance of recommendation systems is crucial for understanding
    their effectiveness and guiding improvements. Several metrics and evaluation techniques
    are commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: Accuracy metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is how we define these commonly used metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Precision** measures the proportion of relevant items among the recommended
    items:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Precision = (Number of relevant recommendations) / (Total number of recommendations)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recall** measures the proportion of relevant items that were successfully
    recommended:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall = (Number of relevant recommendations) / (Total number of relevant items)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**F1 score** is the harmonic mean of precision and recall, providing a balanced
    measure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F1 = 2 × (Precision × Recall) / (Precision + Recall)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **mean average precision** ( **MAP** ) calculates the mean of the average
    precision scores for each user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math  ><mml:mi>M</mml:mi><mml:mi>A</mml:mi><mml:mi>P</mml:mi><mml:mi
    mathvariant="normal"> </mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>U</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfrac><mml:mo>⋅</mml:mo><mml:mi
    mathvariant="normal"> </mml:mi><mml:mi mathvariant="normal">Σ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>A</mml:mi><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/217.png)
    , where we have the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math  ><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>U</mml:mi></mml:mrow></mml:mfenced><mml:mi> </mml:mi></mml:math>](img/218.png)
    is the number of users.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math  ><mml:mi>A</mml:mi><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/219.png)
    is the average precision of the user, ![<mml:math  ><mml:mi>u</mml:mi></mml:math>](img/220.png)
    .'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math  ><mml:mi>A</mml:mi><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Σ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>P</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/221.png)
    / number of relevant items'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math  ><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/222.png)
    is the precision at the cutoff, ![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/223.png)
    .'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math  ><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/224.png)
    is the indicator function (1 if item ![<math ><mrow><mi>k</mi></mrow></math>](img/225.png)
    is relevant, 0 otherwise).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **normalized discounted cumulative gain** ( **NDCG** ) measures the quality
    of ranking while taking into account the position of relevant items in the recommendation
    list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math ><mrow><mrow><mi>N</mi><mi>D</mi><mi>C</mi><mi>G</mi><mo>=</mo><mi>D</mi><mi>C</mi><mi>G</mi><mspace
    width="0.25em" /><mo>/</mo><mspace width="0.25em" /><mi>I</mi><mi>D</mi><mi>C</mi><mi>G</mi></mrow></mrow></math>](img/226.png)
    , where we have the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math  ><mml:mi>D</mml:mi><mml:mi>C</mml:mi><mml:mi>G</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>D</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi
    mathvariant="normal"> </mml:mi><mml:mi>C</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mi>u</mml:mi><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi
    mathvariant="normal"> </mml:mi><mml:mi>G</mml:mi><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Σ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/227.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_IMG
- en: '![<math ><mrow><mrow><mi>I</mi><mi>D</mi><mi>C</mi><mi>G</mi></mrow></mrow></math>](img/228.png)
    is the ideal ![<math ><mrow><mrow><mi>D</mi><mi>C</mi><mi>G</mi></mrow></mrow></math>](img/229.png)
    (max possible ![<mml:math  ><mml:mi>D</mml:mi><mml:mi>C</mml:mi><mml:mi>G</mml:mi></mml:math>](img/230.png)
    ).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math  ><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/231.png)
    is the relevance score of the item at position ![<mml:math  ><mml:mi>i</mml:mi><mml:mo>.</mml:mo></mml:math>](img/232.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_IMG
- en: '![<mml:math  ><mml:mi>i</mml:mi></mml:math>](img/195.png) is the position in
    the ranked list.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming we recommend five movies to Alice, and she ends up liking three of
    them, the precision would be 3/5 = 0.6 or 60%. If there were 10 movies in total
    that Alice would have liked, the recall would be 3/10 = 0.3 or 30%. The F1 score,
    which provides a balanced measure, would be approximately 0.4 or 40% in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Error metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Error metrics often measure the average difference between predicted and actual
    ratings, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **mean absolute error** ( **MAE** ) measures the average absolute difference
    between predicted and actual ratings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math ><mrow><mrow><mi>M</mi><mi>A</mi><mi>E</mi><mo>=</mo><mi mathvariant="normal">Σ</mi><mfenced
    open="|" close="|"><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">l</mi><mo>−</mo><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">c</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">d</mi></mrow></mfenced><mo>/</mo><mi>n</mi></mrow></mrow></math>](img/234.png)
    , where ![<mml:math  ><mml:mi>n</mml:mi></mml:math>](img/216.png) is the number
    of predictions'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **root mean squared error** ( **RMSE** ) is similar to MAE but penalizes
    large errors more heavily:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math  ><mml:mi>R</mml:mi><mml:mi>M</mml:mi><mml:mi>S</mml:mi><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mo>√</mml:mo><mml:mo>(</mml:mo><mml:mi
    mathvariant="normal">Σ</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="normal">a</mml:mi><mml:mi
    mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi
    mathvariant="normal">u</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi
    mathvariant="normal">l</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="normal">p</mml:mi><mml:mi
    mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi
    mathvariant="normal">d</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi
    mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi
    mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">d</mml:mi><mml:msup><mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>/</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/236.png)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_IMG
- en: For example, if we predicted ratings for five movies and the average difference
    between our predictions and Alice’s actual ratings was 0.42 stars, this would
    be our MAE. This suggests that, on average, our predictions are off by about 0.42
    stars.
  prefs: []
  type: TYPE_NORMAL
- en: Coverage, diversity, and serendipity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Coverage metrics assess the system’s ability to recommend a wide range of items.
    **Item coverage** measures the percentage of items in the catalog that the system
    can recommend, while **user coverage** indicates the percentage of users for whom
    the system can generate recommendations. In our movie system, we might measure
    what percentage of the 3,000 movies in our catalog we’re able to recommend (item
    coverage) and what percentage of our 1,000 users receive recommendations ( user
    coverage).
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, diversity metrics evaluate the variety (or dissimilarity) among
    recommended items, ensuring users receive a range of suggestions rather than similar
    ones. **Serendipity** , on the other hand, assesses the system’s ability to provide
    unexpected yet relevant recommendations, creating pleasant surprises for users.
    It combines elements of unexpectedness and relevance, often measured through unexpectedness
    scores and relevance evaluations. While related, diversity and serendipity are
    distinct: diverse recommendations may not always be serendipitous, and serendipitous
    recommendations often contribute to diversity but not vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: These metrics are essential for creating a balanced recommendation system that
    offers varied, interesting, and delightfully unexpected suggestions to users (for
    more on this topic, see [https://doi.org/10.1145/2926720](https://doi.org/10.1145/2926720)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: A/B testing and user feedback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While offline metrics provide valuable insights, real-world performance is best
    evaluated through **A/B testing** and **user feedback** . A/B testing involves
    comparing two versions of the recommendation system with real users and measuring
    key performance indicators such as click-through rate, conversion rate, or user
    engagement. User feedback, both explicit (through ratings or surveys) and implicit
    (through clicks or purchase behavior), is crucial for continuously improving and
    validating the recommendation system. Long-term user satisfaction, which is measured
    through user retention and engagement metrics, is also essential for assessing
    the impact of recommendations on user trust and platform loyalty.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating recommendation systems requires a holistic approach that considers
    both offline metrics and real-world performance. As recommendation systems become
    more sophisticated, especially with the integration of graph deep learning techniques,
    evaluation methods continue to evolve to capture the nuanced aspects of recommendation
    quality and user satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Graph structures in recommendation systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph structures have emerged as a powerful paradigm for modeling complex relationships
    in recommendation systems. By representing users, items, and their interactions
    as nodes and edges in a graph, we can capture rich, multi-dimensional information
    that traditional matrix-based approaches often miss.
  prefs: []
  type: TYPE_NORMAL
- en: User-item interaction graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The foundation of graph-based recommendation systems is the **user-item interaction
    graph** . In this structure, users and items are represented as *nodes* , while
    interactions (such as ratings, views, or purchases) form *edges* between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a movie recommendation system, the graph might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nodes** : Users (U1, U2, U3…) and movies (M1, M2, M3…)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edges** : Ratings or views (for example, U1 -> M1 with a weight of 4 stars)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This simple structure already allows for a more nuanced analysis than a traditional
    user-item matrix. For example, we can easily identify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Popular movies (nodes with many incoming edges)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active users (nodes with many outgoing edges)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar users or movies (nodes with similar edge patterns)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider user U1 who has watched and rated movies M1 (4 stars), M2 (3 stars),
    and M3 (5 stars). To recommend a new movie to U1, we can traverse the graph to
    find users with similar rating patterns and suggest movies they’ve enjoyed that
    U1 hasn’t seen yet.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating side information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Real-world recommendation systems often have access to additional information
    beyond just user-item interactions. Graph structures excel at incorporating this
    side information seamlessly. For movie recommendations, we might enhance our graph
    with the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Movie attributes** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Genres (action, comedy, drama, and so on)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Directors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Actors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Release year
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User attributes** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Age
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Gender
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Location
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Social connections** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Friend relationships between users
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These additional nodes and edges create a heterogeneous graph, where different
    types of nodes and relationships coexist. This rich structure allows for more
    sophisticated recommendation algorithms. Let’s expand on our previous example.
    Now, movie M1 has additional connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Genre** : Action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Director** : D1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actors** : A1, A2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User U1 is connected to the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Age** **group** : 25-34'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location** : New York'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By traversing this enhanced graph, we can make more nuanced recommendations.
    For instance, we might suggest an action movie directed by D1 that’s popular among
    U1’s age group in New York, even if it doesn’t have a direct connection to U1’s
    previously watched movies.
  prefs: []
  type: TYPE_NORMAL
- en: Temporal graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time is a crucial factor in recommendation systems, especially for domains such
    as movies, where preferences can change rapidly. **Temporal graphs** incorporate
    time information into the graph structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to represent time in a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time-stamped edges** : Each interaction edge includes a timestamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time-based node splitting** : Create multiple nodes for the same user or
    item at different time points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic graphs** : The graph structure itself evolves, with nodes and edges
    appearing or disappearing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For movie recommendations, a temporal graph can capture the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Changes in user preferences over time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The life cycle of movie popularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seasonal trends in viewing habits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider a user, U1, who watched mostly comedies in 2020 but shifted toward
    dramas in 2021. A temporal graph would preserve this information, allowing the
    recommendation system to prioritize recent preferences while still considering
    long-term patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might represent this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This structure enables sequential recommendation, where the system suggests
    the next movie based on the user’s recent viewing history and overall trends.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-relational graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In complex domains such as movie recommendations, different types of relationships
    often coexist. **Multi-relational graphs** allow us to represent these varied
    connections explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For movies, we might have these relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User-movie** : **"rated"** , **"watched"** , and **"added** **to wishlist"**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-user** : **"is friends with"** and **"has similar** **taste to"**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Movie-movie** : **"has same genre"** , **"has same director"** , and **"is**
    **sequel to"**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each relationship can have its own semantics and importance in the recommendation
    process. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This multi-relational structure allows for sophisticated path-based recommendations.
    For instance, we might recommend M2 to U1 because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: U1’s friend, U2, rated it highly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It shares a director with M1, which U1 loved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By leveraging these complex relationships, multi-relational graphs enable more
    contextual and explainable recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Graph structures excel at capturing complex relationships, incorporating diverse
    information sources, and modeling temporal dynamics. As we’ll see in subsequent
    sections, these rich graph structures form the foundation for sophisticated deep
    learning models that can generate highly personalized and accurate recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Graph-based recommendation models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph-based recommendation models have emerged as powerful tools for capturing
    complex relationships between users and items in recommendation systems. These
    models leverage the rich structural information inherent in user-item interaction
    graphs to generate more accurate and personalized recommendations. In this section,
    we’ll explore three major categories of graph-based recommendation models, starting
    with **matrix factorization** ( **MF** ) with graph regularization.
  prefs: []
  type: TYPE_NORMAL
- en: MF with graph regularization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MF** is a fundamental technique in CF, and its integration with graph structures
    has led to significant improvements in recommendation quality. **Graph regularization**
    in MF models helps to incorporate the structural information of the user-item
    interaction graph into the learning process.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is to add a regularization term to the traditional MF objective
    function that encourages connected nodes in the graph to have similar latent representations.
    This approach helps to capture the local structure of the user-item graph and
    can lead to more accurate recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: For movie recommendations, consider a scenario where we have a user-item graph
    with users and movies as nodes, and ratings as edges. The graph regularization
    term would encourage users who have rated similar movies to have similar latent
    factors, and movies that have been rated similarly to also have similar latent
    factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical objective function for MF with graph regularization might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math  display="block"><mrow><mrow><mi>L</mi><mspace width="0.25em" /><mo>=</mo><mspace
    width="0.25em" /><msub><mi mathvariant="normal">Σ</mi><mrow><mfenced open="("
    close=")"><mrow><mi>u</mi><mo>,</mo><mi>i</mi></mrow></mfenced><mspace width="0.25em"
    /><mi mathvariant="normal">ϵ</mi><mspace width="0.25em" /><mi>o</mi></mrow></msub><msup><mfenced
    open="(" close=")"><mrow><msub><mi>r</mi><mrow><mi>u</mi><mi>i</mi><mspace width="0.25em"
    /></mrow></msub><mo>−</mo><mspace width="0.25em" /><msubsup><mi>p</mi><mi>u</mi><mi>T</mi></msubsup><msub><mi>q</mi><mi>i</mi></msub></mrow></mfenced><mn>2</mn></msup><mspace
    width="0.25em" /><mo>+</mo><mspace width="0.25em" /><mi>λ</mi><mfenced open="("
    close=")"><mrow><mo>∥</mo><mi>P</mi><msubsup><mo>∥</mo><mi>F</mi><mn>2</mn></msubsup><mspace
    width="0.25em" /><mo>+</mo><mspace width="0.25em" /><mo>∥</mo><mi>Q</mi><msubsup><mo>∥</mo><mi>F</mi><mn>2</mn></msubsup></mrow></mfenced><mspace
    width="0.25em" /><mo>+</mo><mspace width="0.25em" /><mi>α</mi><mspace width="0.25em"
    /><msub><mi mathvariant="normal">Σ</mi><mrow><mfenced open="(" close=")"><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow></mfenced><mspace
    width="0.25em" /><mi mathvariant="normal">ϵ</mi><mspace width="0.25em" /><msub><mi
    mathvariant="normal">ℇ</mi><mi>u</mi></msub></mrow></msub><mo>∥</mo><msub><mi>p</mi><mi>u</mi></msub><mo>−</mo><mspace
    width="0.25em" /><msub><mi>p</mi><mi>v</mi></msub><msup><mo>∥</mo><mn>2</mn></msup><mspace
    width="0.25em" /><mo>+</mo><mspace width="0.25em" /><mi>β</mi><mspace width="0.25em"
    /><msub><mi mathvariant="normal">Σ</mi><mrow><mfenced open="(" close=")"><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></mfenced><mspace
    width="0.25em" /><mi mathvariant="normal">ϵ</mi><mspace width="0.25em" /><msub><mi
    mathvariant="normal">ℇ</mi><mi>i</mi></msub></mrow></msub><mspace width="0.25em"
    /><mo>∥</mo><msub><mi>q</mi><mi>i</mi></msub><mo>−</mo><mspace width="0.25em"
    /><msub><mi>q</mi><mi>j</mi></msub><msup><mo>∥</mo><mn>2</mn></msup></mrow></mrow></math>](img/237.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, ![<mml:math  ><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mi> </mml:mi></mml:math>](img/238.png)
    and ![<mml:math  ><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi> </mml:mi></mml:math>](img/239.png)
    are the latent factors for the user, ![<mml:math  ><mml:mi> </mml:mi><mml:mi>u</mml:mi></mml:math>](img/240.png)
    , and the item, ![<mml:math  ><mml:mi> </mml:mi><mml:mi>i</mml:mi></mml:math>](img/241.png)
    , respectively, ![<mml:math  ><mml:msub><mml:mrow><mml:mi>ℇ</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:math>](img/242.png)
    and ![<mml:math  ><mml:msub><mml:mrow><mml:mi>ℇ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/243.png)
    are the sets of edges in the user-user and item-item graphs, and ![<math ><mrow><mi>α</mi></mrow></math>](img/244.png)
    and ![<math ><mrow><mi>β</mi></mrow></math>](img/245.png) are regularization parameters.
  prefs: []
  type: TYPE_NORMAL
- en: This approach has shown improved performance over traditional MF, especially
    in scenarios with sparse data, as it can leverage the graph structure to make
    better predictions for users or items with few interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Graph neural network models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in [*Chapter 4*](B22118_04.xhtml#_idTextAnchor078) , **graph neural
    networks** ( **GNNs** ) have revolutionized the field of graph-based recommendations
    by enabling direct learning on graph-structured data. The following models can
    capture high-order connectivity patterns and learn rich node representations that
    incorporate both node features and graph structure.
  prefs: []
  type: TYPE_NORMAL
- en: PinSage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PinSage** , developed by Pinterest, is a pioneering GNN model for large-scale
    recommendation systems. It adapts the **GraphSAGE** architecture to generate embeddings
    efficiently for nodes in web-scale graphs.'
  prefs: []
  type: TYPE_NORMAL
- en: In a movie recommendation context, PinSage could be used to generate embeddings
    for both users and movies. The model would aggregate information from a node’s
    local neighborhood, capturing not just direct interactions but also higher-order
    relationships. For example, it could identify that two users who haven’t watched
    the same movies might still have similar tastes if they’ve watched movies that
    are themselves similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key steps in PinSage are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Neighborhood sampling** : For each node, sample a fixed number of neighbors
    to make computation feasible on large graphs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Feature aggregation** : Aggregate features from the sampled neighbors using
    learnable aggregation functions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Embedding generation** : Combine the aggregated neighborhood information
    with the node’s features to generate the final embedding.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Neural graph collaborative filtering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Neural graph collaborative filtering** ( **NGCF** ) explicitly incorporates
    the user-item graph structure into the embedding learning process. It propagates
    embeddings on the user-item interaction graph to capture collaborative signals.'
  prefs: []
  type: TYPE_NORMAL
- en: For movie recommendations, NGCF would start with initial embeddings for users
    and movies and then update these embeddings iteratively by passing messages along
    the edges of the user-movie interaction graph. This process allows the model to
    capture high-order connectivity between users and movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The embedding update process in NGCF can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math   display="block"><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>σ</mml:mi><mml:mi> </mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mi> </mml:mi><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi> </mml:mi><mml:mi>i</mml:mi><mml:mi>ϵ</mml:mi><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi> </mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:msqrt></mml:mrow></mml:mfrac><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mfenced></mml:math>](img/246.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, ![<mml:math  ><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/247.png)
    is the embedding of the user, ![<mml:math  ><mml:mi>u</mml:mi></mml:math>](img/248.png)
    , at the ![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/249.png) th layer. ![<mml:math  ><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:math>](img/250.png)
    is the set of items that are interacted with   by the user, ![<mml:math  ><mml:mi>u</mml:mi></mml:math>](img/220.png)
    , and ![<mml:math  ><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/252.png)
    and ![<mml:math  ><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/253.png)
    are   learnable weight matrixes.
  prefs: []
  type: TYPE_NORMAL
- en: LightGCN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**LightGCN** simplifies the NGCF model by removing feature transformation and
    nonlinear activation, focusing solely on the most essential component of **graph
    convolutional networks** ( **GCNs** ) for CF: neighborhood aggregation.'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of movie recommendations, LightGCN would represent users and
    movies as nodes in a bipartite graph. The model then performs multiple layers
    of neighborhood aggregation to capture high-order connectivity. The final embeddings
    are a weighted sum of embeddings from all layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The embedding propagation rule in LightGCN is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math   display="block"><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi> </mml:mi><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi> </mml:mi><mml:mi>i</mml:mi><mml:mi>ϵ</mml:mi><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi> </mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:msqrt></mml:mrow></mml:mfrac><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math>](img/254.png)'
  prefs: []
  type: TYPE_IMG
- en: The simplicity of LightGCN makes it computationally efficient while still achieving
    state-of-the-art performance on many recommendation tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Training graph deep learning models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Training graph deep learning models for recommendation systems is a complex
    process that requires various factors to be considered carefully. In this section,
    we’ll provide a comprehensive guide to training these models.
  prefs: []
  type: TYPE_NORMAL
- en: Data preprocessing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Effective data preprocessing is crucial for the success of graph-based recommendation
    models. Let’s dive deeper into the steps involved.
  prefs: []
  type: TYPE_NORMAL
- en: Building the interaction graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a high-quality interaction graph is the foundation of graph-based
    recommendation systems. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node creation** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign unique identifiers to each user and movie.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create node attributes to store relevant information.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge creation** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create edges based on user-movie interactions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider different types of interactions (for example, ratings, views, and likes).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge weighting** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign weights to edges based on interaction strength.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Normalize weights to ensure consistency across different interaction types.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling** **temporal information** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incorporate the timestamps of interactions as edge attributes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider creating multiple edges for repeated interactions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s some example pseudocode for building a more detailed graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function normalizes the edge weights in the graph to provide
    a relative measure of interaction strength:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Feature engineering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can enhance the graph with rich features to improve model performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User features** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demographic information, such as age, gender, and location
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral features, such as average rating, genre preferences, and activity
    level
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Derived features, such as user segments based on viewing patterns
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Movie features** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic attributes, such as genre, release year, and duration
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Production details, such as director, actors, budget, and production company
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance metrics, such as box office revenue and critic ratings
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Derived features, such as popularity score and genre embeddings
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Temporal features** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time-based user features, such as viewing frequency and time since the last
    activity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Time-based movie features, such as the age of the movie and seasonal popularity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph-based features** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node degree, such as the number of movies rated by a user or the number of ratings
    for a movie
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Centrality measures, such as PageRank and betweenness centrality
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Community detection – for example, assign community labels to nodes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of advanced feature engineering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function calculates genre preferences for a given user. This
    is used as part of the feature engineering process outlined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Model training techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Training graph deep learning models for recommendation systems involves several
    advanced techniques to improve performance and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Loss functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can choose and combine appropriate **loss functions** based on the recommendation
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary cross-entropy** ( **BCE** ) can be used for *implicit* feedback:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Mean squared error** ( **MSE** ) can be employed for *explicit* feedback
    ( rating prediction):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Bayesian personalized ranking** ( **BPR** ) **loss** can be utilized for
    pairwise ranking:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Margin ranking loss** is another option for pairwise ranking:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Combination of losses** can combine multiple loss functions for multi-task
    learning:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Training loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also implement an advanced **training loop** with various optimization
    techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gradient accumulation for larger effective batch sizes** : This technique
    allows for larger effective batch sizes by accumulating gradients over multiple
    batches before performing an optimizer step:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Learning rate scheduling** : The **ReduceLROnPlateau** scheduler adjusts
    the learning rate based on the validation loss, reducing it when the loss plateaus:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Early stopping based on validation performance** : This technique stops training
    when the validation loss doesn’t improve for a specified number of epochs, preventing
    overfitting:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Gradient clipping to prevent exploding gradients** : Gradient clipping prevents
    gradients from becoming too large, which can cause instability during training:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Scalability and optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling large-scale graphs requires advanced techniques for efficient training
    and inference. We covered the challenge of scalability in [*Chapter 5*](B22118_05.xhtml#_idTextAnchor093)
    ; here, we’ll look at practical examples of techniques that can help us address
    this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Mini-batch training with neighborhood sampling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of processing the entire graph, we can use **mini-batch training**
    with neighborhood sampling:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sample a subset of user nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This step randomly selects a subset of user nodes to form the mini-batch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For each user, sample a fixed number of positive and negative movie interactions.
    Here, we sample positive movie interactions from the user’s neighbors and negative
    interactions from movies the user hasn’t interacted with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform **multi-hop neighborhood sampling** to create a subgraph containing
    the relevant nodes and their neighbors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we create the subgraph and conduct message passing within the sampled
    subgraph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Distributed training
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For extremely large graphs, you can implement **distributed training** :'
  prefs: []
  type: TYPE_NORMAL
- en: '**Graph partitioning** : Divide the graph across multiple machines to enable
    distributed processing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Distributed message passing** : Implement efficient communication protocols
    for distributed message passing across machines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Parameter server architecture** : Use **DistributedDataParallel** ( **DDP**
    ) to centralize model parameter updates across all processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By implementing all the strategies outlined in this section, such as efficient
    graph construction, comprehensive feature engineering, sophisticated loss functions,
    and scalable training methods, you can develop powerful and effective graph-based
    recommendation systems.
  prefs: []
  type: TYPE_NORMAL
- en: Explainability in graph-based recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As recommendation systems become more sophisticated, the need for **explainable
    AI** ( **XAI** ) in these systems grows. Graph-based models offer unique opportunities
    for enhancing the explainability of recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Attention mechanisms for interpretability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in [*Chapter 4*](B22118_04.xhtml#_idTextAnchor078) , **graph attention
    networks** ( **GATs** ) can be leveraged to provide insights into which nodes
    or features contribute most to a recommendation. For movie recommendations, this
    could reveal which actors, directors, or genres have the most significant influence
    on a user’s preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a user who frequently watches action movies starring Tom Cruise. The
    attention mechanism might highlight that the presence of Tom Cruise in a movie’s
    cast graph node has a higher weight in the recommendation process for this user
    compared to other factors.
  prefs: []
  type: TYPE_NORMAL
- en: Path-based explanations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Metapath-based models** can offer intuitive explanations by showing the reasoning
    path that led to a recommendation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a movie recommendation might be explained as follows: *We recommended
    “Inception” because you enjoyed “The Dark Knight” (same director: Christopher
    Nolan) and “Interstellar” (similar genre:* *sci-fi thriller).*'
  prefs: []
  type: TYPE_NORMAL
- en: One of the major challenges that businesses face is a lack of data. A new product
    might not have enough customer data to build these sophisticated recommendation
    models. This challenge is called the cold start problem, and we’re going to look
    into how we can leverage graph algorithms to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: The cold start problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cold start problem in recommendation systems refers to the challenge of
    making accurate recommendations for new users or new items that have little to
    no interaction data. In movie recommendation systems, this occurs when a new user
    joins the platform and has no viewing history or when a new movie is released
    and has no user ratings or interactions.
  prefs: []
  type: TYPE_NORMAL
- en: The cold start problem is particularly challenging in movie recommendation systems,
    especially for new users or newly released movies.
  prefs: []
  type: TYPE_NORMAL
- en: Graph embedding transfer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One solution to the cold start problem is **graph embedding transfer** , a
    technique that’s used to initialize representations for new nodes (movies or users)
    in a recommendation graph when there’s no interaction data available. Here’s a
    general description:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For new items (for example, movies):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify similar existing items based on metadata or content features.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the embeddings of these similar items to initialize the embedding of the
    new item.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This gives the new item a starting point in the embedding space that reflects
    its likely characteristics.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For new users:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use available demographic or preference information to find similar existing
    users.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize the new user’s embedding based on these similar users’ embeddings.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As the new user interacts with the system, their embedding can be fine-tuned.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, when a new superhero movie is released, we can initialize its
    embedding by averaging the embeddings of other superhero movies in the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Content-based feature integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another effective approach to mitigate cold start issues is to leverage content-based
    features from available metadata or item descriptions. By integrating multiple
    content-based features such as text attributes, categorical information, and any
    available numerical data, a system can generate initial recommendations even for
    new items or users with no interaction history. This integrated feature representation
    can be used to compute item similarities or train machine learning models that
    predict user preferences based on item characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, when a new user signs up, we can create edges to movies based
    on their stated preferences (genres, actors, and directors), even before they’ve
    watched anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These are just a couple of ways we can approach a cold start problem in a recommendation
    system that leverages graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced graph deep learning as an advanced approach to
    recommendation systems. You learned about the fundamental concepts of recommendation
    systems, including the different types and evaluation metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we delved into graph structures for representing user-item interactions,
    incorporating side information, and capturing temporal dynamics. Various graph-based
    recommendation models were explored, from MF with graph regularization to advanced
    GNN models. You also became familiar with a variety of training techniques, scalability
    challenges, and advanced topics such as explainability and the cold start problem
    in graph-based recommendation systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to investigate the applications of graph learning
    in computer vision.
  prefs: []
  type: TYPE_NORMAL
