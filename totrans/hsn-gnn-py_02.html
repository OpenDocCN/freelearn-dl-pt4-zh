<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer077">
<h1 class="chapter-number" id="_idParaDest-23"><a id="_idTextAnchor023"/>2</h1>
<h1 id="_idParaDest-24"><a id="_idTextAnchor024"/>Graph Theory for Graph Neural Networks</h1>
<p><strong class="bold">Graph theory</strong> <a id="_idIndexMarker043"/>is a fundamental branch of mathematics that deals with the study of graphs and networks. A graph<a id="_idIndexMarker044"/> is a visual representation of complex data structures that helps us understand the relationships between different entities. Graph theory provides us with tools to model and analyze a vast array of real-world problems, such as transportation systems, social networks, and <span class="No-Break">internet connectivity.</span></p>
<p>In this chapter, we will delve into the essentials of graph theory, covering three main topics: graph properties, graph concepts, and graph algorithms. We will begin by defining graphs and their components. We will then introduce the different types of graphs and explain their properties and applications. Next, we will cover fundamental graph concepts, objects, and measures, including the adjacency matrix. Finally, we will dive into graph algorithms, focusing on the <a id="_idIndexMarker045"/>two fundamental <a id="_idIndexMarker046"/>algorithms, <strong class="bold">breadth-first search</strong> (<strong class="bold">BFS</strong>) and <strong class="bold">depth-first </strong><span class="No-Break"><strong class="bold">search</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DFS</strong></span><span class="No-Break">).</span></p>
<p>By the end of this chapter, you will have a solid foundation in graph theory, allowing you to tackle more advanced topics and design graph <span class="No-Break">neural networks.</span></p>
<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>Introducing <span class="No-Break">graph properties</span></li>
<li>Discovering <span class="No-Break">graph concepts</span></li>
<li>Exploring <span class="No-Break">graph algorithms</span></li>
</ul>
<h1 id="_idParaDest-25"><a id="_idTextAnchor025"/>Technical requirements</h1>
<p>All the code examples from this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Hands-On-Graph-Neural-Networks-Using-Python/tree/main/Chapter02"><span class="No-Break">https://github.com/PacktPublishing/Hands-On-Graph-Neural-Networks-Using-Python/tree/main/Chapter02</span></a><span class="No-Break">.</span></p>
<p>The installation steps required to run the code on your local machine can be found in the <em class="italic">Preface</em> of <span class="No-Break">this book.</span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor026"/>Introducing graph properties</h1>
<p>In graph<a id="_idIndexMarker047"/> theory, a graph<a id="_idIndexMarker048"/> is a mathematical structure consisting of a set of objects, called <strong class="bold">vertices</strong> or <strong class="bold">nodes</strong>, and a<a id="_idIndexMarker049"/> set of connections, called <strong class="bold">edges</strong>, which<a id="_idIndexMarker050"/> link pairs of vertices. The notation <img alt="" height="38" src="image/Formula_B19153_02_001.png" width="162"/> is used to represent a<a id="_idIndexMarker051"/> graph, where <img alt="" height="33" src="image/Formula_B19153_02_002.png" width="27"/> is the graph, <img alt="" height="33" src="image/Formula_B19153_02_003.png" width="27"/> is the set of vertices, and <img alt="" height="33" src="image/Formula_B19153_02_0031.png" width="27"/> is the set <span class="No-Break">of edges.</span></p>
<p>The nodes of a graph can represent any objects, such as cities, people, web pages, or molecules, and the edges represent the relationships or connections between them, such as physical roads, social relationships, hyperlinks, or <span class="No-Break">chemical bonds.</span></p>
<p>This section provides an overview of fundamental graph properties that will be used extensively in <span class="No-Break">later chapters.</span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Directed graphs</h2>
<p>One of the<a id="_idIndexMarker052"/> most basic <a id="_idIndexMarker053"/>properties of a graph is whether it is directed or undirected. In a <strong class="bold">directed graph</strong>, also called a <strong class="bold">digraph</strong>, each edge has a direction or orientation. This means that the edge <a id="_idIndexMarker054"/>connects two nodes in a particular direction, where one node is the source and the other is the destination. In contrast, an undirected graph has undirected edges, where the edges have no direction. This means that the edge between two vertices can be traversed in either direction, and the order in which we visit the nodes does <span class="No-Break">not matter.</span></p>
<p>In Python, we can use the <strong class="source-inline">networkx</strong> library to define an undirected graph as follows <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">nx.Graph()</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import networkx as nx
G = nx.Graph()
G.add_edges_from([('A', 'B'), ('A', 'C'), ('B', 'D'),  
('B', 'E'), ('C', 'F'), ('C', 'G')])</pre>
<p>The <strong class="source-inline">G</strong> graph <a id="_idIndexMarker055"/>corresponds<a id="_idIndexMarker056"/> to the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<img alt="Figure 2.1 – Example of an undirected graph" height="628" src="image/B19153_02_001.jpg" width="812"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Example of an undirected graph</p>
<p>The code to create a directed graph is similar; we simply replace <strong class="source-inline">nx.Graph()</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">nx.DiGraph()</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
DG = nx.DiGraph()
DG.add_edges_from([('A', 'B'), ('A', 'C'), ('B', 'D'),  
('B', 'E'), ('C', 'F'), ('C', 'G')])</pre>
<p>The <strong class="source-inline">DG</strong> graph corresponds to the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<img alt="Figure 2.2 – Example of a directed graph" height="736" src="image/B19153_02_002.jpg" width="952"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Example of a directed graph</p>
<p>In <a id="_idIndexMarker057"/>directed graphs, edges <a id="_idIndexMarker058"/>are typically represented using arrows to denote their orientation, as in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor028"/>Weighted graphs</h2>
<p>Another<a id="_idIndexMarker059"/> important property of graphs is whether the edges are weighted or unweighted. In a <strong class="bold">weighted graph</strong>, each <a id="_idIndexMarker060"/>edge has a weight or cost associated with it. These weights can represent various factors, such as distance, travel time, <span class="No-Break">or cost.</span></p>
<p>For example, in a transportation network, the weights of edges might represent the distances between different cities or the time it takes to travel between them. In contrast, unweighted graphs have no weight associated with their edges. These types of graphs are commonly used in situations where the relationships between nodes are binary, and the edges simply indicate the presence or absence of a connection <span class="No-Break">between them.</span></p>
<p>We can modify the<a id="_idIndexMarker061"/> previous undirected graph to add weights to our edges. In <strong class="source-inline">networkx</strong>, the edges of the graph are defined with a tuple containing the start and<a id="_idIndexMarker062"/> end nodes and a dictionary specifying the <span class="No-Break">edge’s weight:</span></p>
<pre class="source-code">
WG = nx.Graph()
WG.add_edges_from([('A', 'B', {"weight": 10}), ('A', 'C', {"weight": 20}), ('B', 'D', {"weight": 30}), ('B', 'E', {"weight": 40}), ('C', 'F', {"weight": 50}), ('C', 'G', {"weight": 60})])
labels = nx.get_edge_attributes(WG, "weight")</pre>
<p>The <strong class="source-inline">WG</strong> graph <a id="_idIndexMarker063"/>corresponds to<a id="_idIndexMarker064"/> the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<img alt="Figure 2.3 – Example of a weighted graph" height="628" src="image/B19153_02_003.jpg" width="814"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Example of a weighted graph</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/>Connected graphs</h2>
<p>Graph <a id="_idIndexMarker065"/>connectivity is a fundamental <a id="_idIndexMarker066"/>concept in graph theory that is closely related to the graph’s structure <span class="No-Break">and function.</span></p>
<p>In a <strong class="bold">connected graph</strong>, there is <a id="_idIndexMarker067"/>a path between any two vertices in the graph. Formally, a <img alt="" height="32" src="image/Formula_B19153_02_005.png" width="25"/> graph is connected if, and only if, for every pair of <img alt="" height="21" src="image/Formula_B19153_02_006.png" width="23"/> and <img alt="" height="21" src="image/Formula_B19153_02_007.png" width="22"/> vertices in <img alt="" height="34" src="image/Formula_B19153_02_008.png" width="27"/>, there<a id="_idIndexMarker068"/> exists a path from <img alt="" height="21" src="image/Formula_B19153_02_009.png" width="23"/> to <img alt="" height="21" src="image/Formula_B19153_02_010.png" width="22"/>. In contrast, a graph is disconnected if it is not connected, which means that at least two vertices are not connected by <span class="No-Break">a path.</span></p>
<p>The <strong class="source-inline">networkx</strong> library provides a built-in function for verifying whether a graph is connected or not. In the following example, the first graph contains isolated nodes (<strong class="source-inline">4</strong> and <strong class="source-inline">5</strong>), unlike the second graph. This is visualized in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>
<pre class="source-code">
G1 = nx.Graph()
G1.add_edges_from([(1, 2), (2, 3), (3, 1), (4, 5)])
print(f"Is graph 1 connected? {nx.is_connected(G1)}")
G2 = nx.Graph()
G2.add_edges_from([(1, 2), (2, 3), (3, 1), (1, 4)])
print(f"Is graph 2 connected? {nx.is_connected(G2)}")</pre>
<p>This code prints the <span class="No-Break">following output:</span></p>
<pre class="source-code">
<strong class="bold">Is graph 1 connected? False</strong>
<strong class="bold">Is graph 2 connected? True</strong></pre>
<p>The first graph<a id="_idIndexMarker069"/> is disconnected because of nodes <strong class="source-inline">4</strong> and <strong class="source-inline">5</strong>. On the other hand, the <a id="_idIndexMarker070"/>second graph is connected. This property is easy to visualize with small graphs, as in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<img alt="Figure 2.4 – Left: graph 1 with isolated nodes (disconnected graph); right: graph 2 where each node is connected to at least another one (connected graph)" height="462" src="image/B19153_02_004.jpg" width="1023"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Left: graph 1 with isolated nodes (disconnected graph); right: graph 2 where each node is connected to at least another one (connected graph)</p>
<p>Connected graphs have several interesting properties and applications. For example, in a communication network, a connected graph ensures that any two nodes can communicate with each other through a path. In contrast, disconnected graphs can have isolated nodes that cannot communicate with other nodes in the network, making it challenging to<a id="_idIndexMarker071"/> design <a id="_idIndexMarker072"/>efficient <span class="No-Break">routing algorithms.</span></p>
<p>There are different ways to measure the connectivity of a graph. One of the most common measures is the minimum number of edges that need to be removed to disconnect the graph, which is known as the graph’s minimum cut. The minimum cut problem has several applications in network flow optimization, clustering, and <span class="No-Break">community detection.</span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/>Types of graphs</h2>
<p>In addition to the commonly used graph types, there are some special types of graphs that have unique properties <span class="No-Break">and characteristics:</span></p>
<ul>
<li>A <strong class="bold">tree</strong> is a <a id="_idIndexMarker073"/>connected, undirected <a id="_idIndexMarker074"/>graph with no cycles (like the graph in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.1</em>). Since there is only one path between any two nodes in a tree, a tree is a special case of a graph. Trees are often used to model hierarchical structures, such as family trees, organizational structures, or <span class="No-Break">classification trees.</span></li>
<li>A <strong class="bold">rooted tree</strong> is <a id="_idIndexMarker075"/>a tree in which one node is designated as the root, and all other<a id="_idIndexMarker076"/> vertices are connected to it by a unique path. Rooted trees are often used in computer science to represent hierarchical data structures, such as filesystems or the structure of <span class="No-Break">XML documents.</span></li>
<li>A <strong class="bold">directed acyclic graph</strong> (<strong class="bold">DAG</strong>) is a<a id="_idIndexMarker077"/> directed graph that has<a id="_idIndexMarker078"/> no cycles (like the graph in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em>). This means that the edges can only be traversed in a particular direction, and there are no loops or cycles. DAGs are often used to model dependencies between tasks or events – for example, in project management or in computing the critical path of <span class="No-Break">a job.</span></li>
<li>A <strong class="bold">bipartite graph</strong> is a <a id="_idIndexMarker079"/>graph in which the vertices can be divided into two disjoint sets, such that all edges connect vertices in different sets. Bipartite graphs are often used in mathematics and computer science to model relationships between two different types of objects, such as buyers and sellers, or employees <span class="No-Break">and projects.</span></li>
<li>A <strong class="bold">complete graph</strong> is a graph<a id="_idIndexMarker080"/> in which every pair of vertices is connected by an<a id="_idIndexMarker081"/> edge. Complete graphs are often used in combinatorics to model problems involving all possible pairwise connections, and in computer networks to model fully <span class="No-Break">connected networks.</span></li>
</ul>
<p><span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.5</em> illustrates these<a id="_idIndexMarker082"/> different types <span class="No-Break">of graphs:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<img alt="Figure 2.5 – Common types of graphs" height="1033" src="image/B19153_02_005.jpg" width="1027"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Common types of graphs</p>
<p>Now that we have <a id="_idIndexMarker083"/>reviewed essential types of graphs, let’s move on to exploring some of the most important graph objects. Understanding these concepts will help us analyze and manipulate <span class="No-Break">graphs effectively.</span></p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor031"/>Discovering graph concepts</h1>
<p>In this section, we will explore some of the essential concepts in graph theory, including graph objects (such as degree and neighbors), graph measures (such as centrality and density), and the adjacency <span class="No-Break">matrix representation.</span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>Fundamental objects</h2>
<p>One of the key<a id="_idIndexMarker084"/> concepts in graph theory<a id="_idIndexMarker085"/> is the <strong class="bold">degree</strong> of a node, which is the number of <a id="_idIndexMarker086"/>edges <strong class="bold">incident</strong> to this node. An edge is said<a id="_idIndexMarker087"/> to be incident on a node if that node is one of the edge’s endpoints. The degree of a node <img alt="" height="23" src="image/Formula_B19153_02_011.png" width="23"/> is often denoted by <img alt="" height="40" src="image/Formula_B19153_02_012.png" width="111"/>. It can be defined for both directed and <span class="No-Break">undirected graphs:</span></p>
<ul>
<li>In an undirected graph, the degree of a vertex is the number of edges that are connected to it. Note that if the node is connected to itself (called <a id="_idIndexMarker088"/>a <strong class="bold">loop</strong>, or <strong class="bold">self-loop</strong>), it adds <a id="_idIndexMarker089"/>two to <span class="No-Break">the degree.</span></li>
<li>In a directed graph, the degree is divided into two<a id="_idIndexMarker090"/> types: <strong class="bold">indegree</strong> and <strong class="bold">outdegree</strong>. The indegree (denoted by <img alt="" height="38" src="image/Formula_B19153_02_013.png" width="127"/>) of a node represents the number of edges that point towards that node, while the outdegree (denoted by <img alt="" height="43" src="image/Formula_B19153_02_014.png" width="140"/>) represents the number of edges that start from that node. In this case, a self-loop<a id="_idIndexMarker091"/> adds one to the indegree and to <span class="No-Break">the outdegree.</span></li>
</ul>
<p>Indegree and outdegree are essential for analyzing and understanding directed graphs, as they provide insight into how information or resources are distributed within the graph. For example, nodes with high indegree are likely to be important sources of information or resources. In contrast, nodes with high outdegree are likely to be important destinations or consumers of information <span class="No-Break">or resources.</span></p>
<p>In <strong class="source-inline">networkx</strong>, we can simply calculate the node degree, indegree, or outdegree using built-in methods. Let’s do it for the undirected graph from <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.1</em> and the directed graph from <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
<pre class="source-code">
G = nx.Graph()
G.add_edges_from([('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E'), ('C', 'F'), ('C', 'G')])
print(f"deg(A) = {G.degree['A']}")
DG = nx.DiGraph()
DG.add_edges_from([('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E'), ('C', 'F'), ('C', 'G')])
print(f"deg^-(A) = {DG.in_degree['A']}")
print(f"deg^+(A) = {DG.out_degree['A']}")</pre>
<p>This code prints the <span class="No-Break">following output:</span></p>
<pre class="source-code">
<strong class="bold">deg(A) = 2</strong>
<strong class="bold">deg^-(A) = 0</strong>
<strong class="bold">deg^+(A) = 2</strong></pre>
<p>We can compare it<a id="_idIndexMarker092"/> to the graphs from <em class="italic">Figures 2.1</em> and <em class="italic">2.2</em>: node <img alt="" height="31" src="image/Formula_B19153_02_015.png" width="27"/> is connected to two edges (<img alt="" height="40" src="image/Formula_B19153_02_016.png" width="343"/>), but is not the destination of any of <span class="No-Break">them (<img alt="" height="42" src="image/Formula_B19153_02_017.png" width="221"/>).</span></p>
<p>The concept of node degree is related to that<a id="_idIndexMarker093"/> of <strong class="bold">neighbors</strong>. Neighbors refer to the nodes directly connected to a particular node through an edge. Moreover, two nodes are said<a id="_idIndexMarker094"/> to be <strong class="bold">adjacent</strong> if they share at least one common neighbor. The concepts of neighbors and adjacency are fundamental to many graph algorithms and applications, such as searching<a id="_idIndexMarker095"/> for a <strong class="bold">path</strong> between two nodes or identifying clusters in <span class="No-Break">a network.</span></p>
<p>In graph theory, a <a id="_idIndexMarker096"/>path is a sequence of edges that connect two nodes (or more) in a graph. The length of a path is the number of edges that are traversed along the path. There are different types of paths, but two of them are <span class="No-Break">particularly important:</span></p>
<ul>
<li>A <strong class="bold">simple path</strong> is a <a id="_idIndexMarker097"/>path that does not visit any node more than once, except for the start and <span class="No-Break">end vertices</span></li>
<li>A <strong class="bold">cycle</strong> is a<a id="_idIndexMarker098"/> path in which the first and last vertices are the same. A graph is said to be acyclic if it contains no cycles (such as trees <span class="No-Break">and DAGs)</span></li>
</ul>
<p>Degrees <a id="_idIndexMarker099"/>and paths can be<a id="_idIndexMarker100"/> used to determine the importance of a node in a network. This<a id="_idIndexMarker101"/> measure is referred<a id="_idIndexMarker102"/> to <span class="No-Break">as </span><span class="No-Break"><strong class="bold">centrality</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/>Graph measures</h2>
<p>Centrality quantifies <a id="_idIndexMarker103"/>the importance of a vertex or node in a network. It helps us to identify key nodes in a graph based on their connectivity and influence on the flow of information or interactions within the network. There are several measures of centrality, each providing a different perspective on the importance of <span class="No-Break">a node:</span></p>
<ul>
<li><strong class="bold">Degree centrality</strong> is <a id="_idIndexMarker104"/>one of the simplest and most<a id="_idIndexMarker105"/> commonly used measures of centrality. It is simply defined as the degree of the node. A high degree centrality indicates that a vertex is highly connected to other vertices in the graph, and thus significantly influences <span class="No-Break">the network.</span></li>
<li><strong class="bold">Closeness centrality</strong> measures <a id="_idIndexMarker106"/>how close a node is to all other nodes in the graph. It corresponds to the average length of the shortest <a id="_idIndexMarker107"/>path between the target node and all other nodes in the graph. A node with high closeness centrality can quickly reach all other vertices in <span class="No-Break">the network.</span></li>
<li><strong class="bold">Betweenness centrality</strong> measures <a id="_idIndexMarker108"/>the number of times a node <a id="_idIndexMarker109"/>lies on the shortest path between pairs of other nodes in the graph. A node with high betweenness centrality acts as a bottleneck or bridge between different parts of <span class="No-Break">the graph.</span></li>
</ul>
<p>Let’s calculate these measures on our previous graphs using the built-in functions of <strong class="source-inline">networkx</strong> and analyze <span class="No-Break">the result:</span></p>
<pre class="source-code">
print(f"Degree centrality      = {nx.degree_centrality(G)}")
print(f"Closeness centrality   = {nx.closeness_centrality(G)}")
print(f"Betweenness centrality = {nx.betweenness_centrality(G)}")</pre>
<p>The <a id="_idIndexMarker110"/>previous code <a id="_idIndexMarker111"/>prints the dictionaries, containing a score for <span class="No-Break">each node:</span></p>
<pre class="source-code">
<strong class="bold">Degree centrality      = {'A': 0.333, 'B': 0.5, 'C': 0.5, 'D': 0.167, 'E': 0.167, 'F': 0.167, 'G': 0.167}</strong>
<strong class="bold">Closeness centrality   = {'A': 0.6, 'B': 0.545, 'C': 0.545, 'D': 0.375, 'E': 0.375, 'F': 0.375, 'G': 0.375}</strong>
<strong class="bold">Betweenness centrality = {'A': 0.6, 'B': 0.6, 'C': 0.6, 'D': 0.0, 'E': 0.0, 'F': 0.0, 'G': 0.0}</strong></pre>
<p>The importance of nodes <img alt="" height="32" src="image/Formula_B19153_02_018.png" width="27"/>, <img alt="" height="30" src="image/Formula_B19153_02_019.png" width="27"/>, and <img alt="" height="31" src="image/Formula_B19153_02_020.png" width="24"/> in a graph depends on the type of centrality used. Degree centrality<a id="_idIndexMarker112"/> considers nodes <img alt="" height="32" src="image/Formula_B19153_02_021.png" width="28"/> and <img alt="" height="31" src="image/Formula_B19153_02_022.png" width="23"/> to be more important because<a id="_idIndexMarker113"/> they have more neighbors than node <img alt="" height="30" src="image/Formula_B19153_02_023.png" width="27"/>. However, in closeness<a id="_idIndexMarker114"/> centrality, node <img alt="" height="31" src="image/Formula_B19153_02_024.png" width="28"/> is the<a id="_idIndexMarker115"/> most important as it can reach any other node in the<a id="_idIndexMarker116"/> graph in the shortest possible path. On the other hand, nodes <img alt="" height="31" src="image/Formula_B19153_02_025.png" width="28"/>, <img alt="" height="37" src="image/Formula_B19153_02_026.png" width="38"/> and <img alt="" height="31" src="image/Formula_B19153_02_027.png" width="24"/> have equal betweenness centrality, as they <a id="_idIndexMarker117"/>all lie on a large number of shortest paths between <span class="No-Break">other nodes.</span></p>
<p>In addition to these measures, we will see how to calculate the importance of a node using machine learning techniques in the next chapters. However, it is not the only measure we <span class="No-Break">will cover.</span></p>
<p>Indeed, <strong class="bold">density</strong> is another<a id="_idIndexMarker118"/> important measure, indicating how connected a graph is. It is a ratio between the actual number of edges and the maximum possible number of edges in the graph. A graph<a id="_idIndexMarker119"/> with high density is considered more connected and has more information flow compared to a graph with <span class="No-Break">low density.</span></p>
<p>The formula to calculate density depends on whether the graph is directed or undirected. For an undirected graph with <img alt="" height="25" src="image/Formula_B19153_02_028.png" width="27"/> nodes, the maximum possible number of edges is <img alt="" height="81" src="image/Formula_B19153_02_029.png" width="142"/>. For a directed graph with <img alt="" height="25" src="image/Formula_B19153_02_030.png" width="27"/> nodes, the maximum number of edges <span class="No-Break">is <img alt="" height="40" src="image/Formula_B19153_02_031.png" width="149"/></span><span class="No-Break">.</span></p>
<p>The density of a graph is <a id="_idIndexMarker120"/>calculated as the number of edges divided by the maximum number of edges. For example, the graph in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.1</em> has <img alt="" height="34" src="image/Formula_B19153_02_032.png" width="23"/> edges and the maximum possible number of <img alt="" height="74" src="image/Formula_B19153_02_033.png" width="200"/> edges. Therefore, it has a density <span class="No-Break">of <img alt="" height="67" src="image/Formula_B19153_02_034.png" width="165"/>.</span></p>
<p>A dense graph<a id="_idIndexMarker121"/> has a density closer to 1, while a sparse graph<a id="_idIndexMarker122"/> has a density closer to 0. There is no strict rule for what constitutes a dense or sparse graph, but generally, a graph is considered dense if its density is greater than 0.5 and sparse if its density is less than 0.1. This measure is directly connected to a fundamental problem with graphs: how to represent <a id="_idIndexMarker123"/>the <span class="No-Break"><strong class="bold">adjacency matrix</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor034"/>Adjacency matrix representation</h2>
<p>An adjacency matrix is<a id="_idIndexMarker124"/> a matrix that represents the edges in a graph, where each cell indicates whether there is an edge between two nodes. The matrix is a square matrix of size <img alt="" height="24" src="image/Formula_B19153_02_035.png" width="88"/>, where <img alt="" height="22" src="image/Formula_B19153_02_036.png" width="25"/> is the number of nodes in the graph. A value of <img alt="" height="31" src="image/Formula_B19153_02_037.png" width="18"/> in the cell <img alt="" height="40" src="image/Formula_B19153_02_038.png" width="72"/> indicates that there is an edge between node <img alt="" height="30" src="image/Formula_B19153_02_039.png" width="12"/> and node <img alt="" height="41" src="image/Formula_B19153_02_040.png" width="20"/>, while a value of <img alt="" height="30" src="image/Formula_B19153_02_041.png" width="19"/> indicates that there is no edge. For an undirected graph, the matrix is symmetric, while for a directed graph, the matrix is not <span class="No-Break">necessarily symmetric.</span></p>
<p>The following figure indicates the adjacency matrix associated with <span class="No-Break">the graph:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<img alt="Figure 2.6 – Example of the adjacency matrix" height="464" src="image/B19153_02_006.jpg" width="1200"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Example of the adjacency matrix</p>
<p>In Python, it can be implemented as a list of lists, as shown in <span class="No-Break">this example:</span></p>
<pre class="source-code">
adj = [[0,1,1,0,0,0,0],
       [1,0,0,1,1,0,0],
       [1,0,0,0,0,1,1],
       [0,1,0,0,0,0,0],
       [0,1,0,0,0,0,0],
       [0,0,1,0,0,0,0],
       [0,0,1,0,0,0,0]]</pre>
<p>The adjacency matrix is <a id="_idIndexMarker125"/>a straightforward representation that can be easily visualized as a 2D array. One of the key advantages of using an adjacency matrix is that checking whether two nodes are connected is a constant time operation. This makes it an efficient way to test the existence of an edge in the graph. Moreover, it is used to perform matrix operations, which are useful for certain graph algorithms, such as calculating the shortest path between <span class="No-Break">two nodes.</span></p>
<p>However, adding or removing nodes can be costly, as the matrix needs to be resized or shifted. One of the main drawbacks of using an adjacency matrix is its space complexity: as the number of nodes in the graph grows, the space required to store the adjacency matrix increases exponentially. Formally, we say that the adjacency matrix has a space complexity of <img alt="" height="44" src="image/Formula_B19153_02_042.png" width="129"/>, where <img alt="" height="39" src="image/Formula_B19153_02_043.png" width="44"/> represents the number of nodes in <span class="No-Break">the graph.</span></p>
<p>Overall, while the adjacency matrix is a useful data structure for representing small graphs, it may not be practical for larger ones due to its space complexity. Additionally, the overhead of adding or removing nodes can make it inefficient for dynamically <span class="No-Break">changing graphs.</span></p>
<p>This is why other<a id="_idIndexMarker126"/> representations can be helpful. For example, another popular way to store graphs is the <strong class="bold">edge list</strong>. An edge list<a id="_idIndexMarker127"/> is a list of all the edges in a graph. Each edge is represented by a tuple or a pair of vertices. The edge list can also include the weight or cost of each edge. This is the data structure we used to create our graphs <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">networkx</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
edge_list = [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)]</pre>
<p>When we compare both data structures applied to our graph, it is clear that the edge list is less verbose. This is the case because our graph is fairly sparse. On the other hand, if our graph was complete, we would require 21 tuples instead of 6. This is explained by a space complexity of <img alt="" height="43" src="image/Formula_B19153_02_044.png" width="111"/>, where <img alt="" height="40" src="image/Formula_B19153_02_045.png" width="47"/> is the number of edges. Edge lists are more efficient for storing sparse graphs, where the number of edges is much smaller than the number <span class="No-Break">of nodes.</span></p>
<p>However, checking whether two vertices are connected in an edge list requires iterating through the entire list, which can be time-consuming for large graphs with many edges. Therefore, edge lists are more commonly used in applications where space is <span class="No-Break">a concern.</span></p>
<p>A third and popular representation is <a id="_idIndexMarker128"/>the <strong class="bold">adjacency list</strong>. It consists of a list of pairs, where each pair represents a node in the graph and its adjacent nodes. The pairs can be stored in a linked list, dictionary, or other data structures, depending on the implementation. For example, an adjacency list for our graph might look <span class="No-Break">like this:</span></p>
<pre class="source-code">
adj_list = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 5, 6],
    3: [1],
    4: [1],
    5: [2],
    6: [2]
}</pre>
<p>An <a id="_idIndexMarker129"/>adjacency list has several advantages over an adjacency matrix or an edge list. First, the space complexity is <img alt="" height="42" src="image/Formula_B19153_02_046.png" width="210"/>, where <img alt="" height="40" src="image/Formula_B19153_02_047.png" width="45"/> is the number of nodes and <img alt="" height="33" src="image/Formula_B19153_02_048.png" width="28"/> is the number of edges. This is more efficient than the <img alt="" height="47" src="image/Formula_B19153_02_049.png" width="132"/> space complexity of an adjacency matrix for sparse graphs. Second, it allows for efficient iteration through the adjacent vertices of a node, which is useful in many graph algorithms. Finally, adding a node or an edge can be done in <span class="No-Break">constant time.</span></p>
<p>However, checking whether two vertices are connected can be slower than with an adjacency matrix. This is because it requires iterating through the adjacency list of one of the vertices, which can be time-consuming for <span class="No-Break">large graphs.</span></p>
<p>Each data structure has its own advantages and disadvantages that depend on the specific application and requirements. In the next section, we will process graphs and introduce the two most fundamental <span class="No-Break">graph algorithms.</span></p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor035"/>Exploring graph algorithms</h1>
<p>Graph algorithms are critical <a id="_idIndexMarker130"/>in solving problems related to graphs, such as finding the shortest path between two nodes or detecting cycles. This section will discuss two graph traversal algorithms: BFS <span class="No-Break">and DFS.</span></p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/>Breadth-first search</h2>
<p>BFS is a graph<a id="_idIndexMarker131"/> traversal algorithm that starts at the root node and explores all <a id="_idIndexMarker132"/>the neighboring nodes at a particular level before moving to the next level of nodes. It works by maintaining a queue of nodes to visit and marking each visited node as it is added to the queue. The algorithm then dequeues the next node in the queue and explores all its neighbors, adding them to the queue if they haven’t been <span class="No-Break">visited yet.</span></p>
<p>The behavior of a BFS is illustrated in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<img alt="Figure 2.7 – Example of graph traversal made by a breadth-first search" height="457" src="image/B19153_02_007.jpg" width="537"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Example of graph traversal made by a breadth-first search</p>
<p>Let’s now<a id="_idIndexMarker133"/> see how<a id="_idIndexMarker134"/> we can implement it <span class="No-Break">in Python:</span></p>
<ol>
<li>We create an empty graph and add edges with the <span class="No-Break"><strong class="source-inline">add_edges_from()</strong></span><span class="No-Break"> method:</span><pre class="source-code">
G = nx.Graph()
G.add_edges_from([('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E'), ('C', 'F'), ('C', 'G')])</pre></li>
<li>We define a function called <strong class="source-inline">bfs()</strong> that implements the BFS algorithm on a graph. The function takes two arguments: the <strong class="source-inline">graph</strong> object and the starting node for <span class="No-Break">the search:</span><pre class="source-code">
def bfs(graph, node):</pre></li>
<li>We initialize two lists (<strong class="source-inline">visited</strong> and <strong class="source-inline">queue</strong>) and add the starting node. The <strong class="source-inline">visited</strong> list keeps track of the nodes that have been visited during the search, while the <strong class="source-inline">queue</strong> list stores the nodes that need to <span class="No-Break">be visited:</span><pre class="source-code">
    visited, queue = [node], [node]</pre></li>
<li>We enter a <strong class="source-inline">while</strong> loop that continues until the <strong class="source-inline">queue</strong> list is empty. Inside the loop, we remove the first node in the <strong class="source-inline">queue</strong> list using the <strong class="source-inline">pop(0)</strong> method and store the result in the <span class="No-Break"><strong class="source-inline">node</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
    while queue:
        node = queue.pop(0)</pre></li>
<li>We<a id="_idIndexMarker135"/> iterate through the neighbors of the node using a <strong class="source-inline">for</strong> loop. For each neighbor that has not been visited yet, we add it to the <strong class="source-inline">visited</strong> list and to the end of the <strong class="source-inline">queue</strong> list using the <strong class="source-inline">append()</strong> method. When<a id="_idIndexMarker136"/> it’s complete, we return the <span class="No-Break"><strong class="source-inline">visited</strong></span><span class="No-Break"> list:</span><pre class="source-code">
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.append(neighbor)
                queue.append(neighbor)
    return visited</pre></li>
<li>We call the <strong class="source-inline">bfs()</strong> function with the <strong class="source-inline">G</strong> argument and the <strong class="source-inline">'A'</strong> <span class="No-Break">starting node:</span><pre class="source-code">
bfs(G, 'A')</pre></li>
<li>The f<a id="_idTextAnchor037"/>unction returns the list of visited nodes in the order in which they <span class="No-Break">were visited:</span><pre class="source-code">
['A', 'B', 'C', 'D', 'E', 'F', 'G']</pre></li>
</ol>
<p>The order we obtained is the one we anticipated in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">.</span></p>
<p>BFS is particularly useful in finding the shortest path between two nodes in an unweighted graph. This is because the algorithm visits nodes in order of their distance from the starting node, so the first time the target node is visited, it must be along the shortest path from the <span class="No-Break">starting node.</span></p>
<p>In addition to finding the shortest path, BFS can also be used to check whether a graph is connected or to find all connected components of a graph. It is also used in applications such as web crawlers, social network analysis, and shortest path routing <span class="No-Break">in networks.</span></p>
<p>The t<a id="_idTextAnchor038"/>ime complexity of BFS is <img alt="" height="44" src="image/Formula_B19153_02_050.png" width="212"/>, where <img alt="" height="38" src="image/Formula_B19153_02_051.png" width="45"/> is the number of nodes and <img alt="" height="41" src="image/Formula_B19153_02_052.png" width="47"/> is the number of edges in the graph. This can be a significant issue for graphs with a high degree of connectivity or for graphs that are sparse. Several variants of BFS have been developed to mitigate this issue, such<a id="_idIndexMarker137"/> as <strong class="bold">bidirectional BFS</strong> and <strong class="bold">A*</strong> search, which <a id="_idIndexMarker138"/>use heuristics to reduce <a id="_idIndexMarker139"/>the number of nodes that need to <span class="No-Break">be</span><span class="No-Break"><a id="_idIndexMarker140"/></span><span class="No-Break"> explored.</span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor039"/>Depth-first search</h2>
<p>DFS is a recursive algorithm <a id="_idIndexMarker141"/>that starts at the root node and explores as far as <a id="_idIndexMarker142"/>possible along each branch <span class="No-Break">before backtracking.</span></p>
<p>It chooses a node and explores all of its unvisited neighbors, visiting the first neighbor that has not been explored and backtracking only when all the neighbors have been visited. By doing so, it explores the graph by following as deep a path from the starting node as possible before backtracking to explore other branches. This continues until all nodes have <span class="No-Break">been explored.</span></p>
<p>The behavior of a DFS is illustrated in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<img alt="Figure 2.8 – Example of graph traversal made by a depth-first search" height="505" src="image/B19153_02_008.jpg" width="593"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Example of graph traversal made by a depth-first search</p>
<p>Let’s <a id="_idIndexMarker143"/>implement <a id="_idIndexMarker144"/>DFS <span class="No-Break">in Python:</span></p>
<ol>
<li>We first initialize an empty list <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">visited</strong></span><span class="No-Break">:</span><pre class="source-code">
visited = []</pre></li>
<li>We define a function called <strong class="source-inline">dfs()</strong> that takes in <strong class="source-inline">visited</strong>, <strong class="source-inline">graph</strong>, and <strong class="source-inline">node</strong> <span class="No-Break">as arguments:</span><pre class="source-code">
def dfs(visited, graph, node):</pre></li>
<li>If the current <strong class="source-inline">node</strong> is not in the <strong class="source-inline">visited</strong> list, we append it to <span class="No-Break">the list:</span><pre class="source-code">
    if node not in visited:
        visited.append(node)</pre></li>
<li>We then iterate through each neighbor of the current <strong class="source-inline">node</strong>. For each neighbor, we recursively call the <strong class="source-inline">dfs()</strong> function passing in <strong class="source-inline">visited</strong>, <strong class="source-inline">graph</strong>, and the neighbor <span class="No-Break">as arguments:</span><pre class="source-code">
        for neighbor in graph[node]:
            visited = dfs(visited, graph, neighbor)</pre></li>
<li>The <strong class="source-inline">dfs()</strong> function continues to explore the graph depth-first, visiting all the neighbors of each node until there are no more unvisited neighbors. Finally, the <strong class="source-inline">visited</strong> list <span class="No-Break">is returned:</span><pre class="source-code">
    return visited</pre></li>
<li>We call the <strong class="source-inline">dfs()</strong> function with <strong class="source-inline">visited</strong> set to an empty list, <strong class="source-inline">G</strong> as the graph, and <strong class="source-inline">'A'</strong> as the <span class="No-Break">starting node:</span><pre class="source-code">
dfs(visited, G, 'A')</pre></li>
<li>The function returns the list of visited nodes in the order in which they <span class="No-Break">were visited:</span><pre class="source-code">
<strong class="bold">['A', 'B', 'D', 'E', 'C', 'F', 'G']</strong></pre></li>
</ol>
<p>Once again, the<a id="_idIndexMarker145"/> order we obtained is the one we anticipated in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">.</span></p>
<p>DFS is useful in solving various problems, such as finding connected components, topological sorting, and solving maze problems. It is particularly useful in finding cycles in a graph since it traverses the graph in a depth-first order, and a cycle exists if, and only if, a node is visited twice during <span class="No-Break">the traversal.</span></p>
<p>Like BFS, it has a<a id="_idIndexMarker146"/> time complexity of <img alt="" height="46" src="image/Formula_B19153_02_053.png" width="216"/>, where <img alt="" height="42" src="image/Formula_B19153_02_054.png" width="49"/> is the number of nodes and <img alt="" height="43" src="image/Formula_B19153_02_055.png" width="50"/> is the number of edges in the graph. It requires less memory but doesn’t guarantee the shallowest path solution. Finally, unlike BFS, you can be trapped in infinite loops <span class="No-Break">using DFS.</span></p>
<p>Additionally, many other algorithms in graph theory build upon BFS and DFS, such as Dijkstra’s shortest path algorithm, Kruskal’s minimum spanning tree algorithm, and Tarjan’s strongly connected components algorithm. Therefore, a solid understanding of BFS and DFS is essential for anyone who wants to work with graphs and develop more advanced <span class="No-Break">graph algorithms.</span></p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor040"/>Summary</h1>
<p>In this chapter, we covered the essentials of graph theory, a branch of mathematics that studies graphs and networks. We began by defining what a graph is and explained the different types of graphs, such as directed, weighted, and connected graphs. We then introduced fundamental graph objects (including neighbors) and measures (such as centrality and density), which are used to understand and analyze <span class="No-Break">graph structures.</span></p>
<p>Additionally, we discussed the adjacency matrix and its different representations. Finally, we explored the two fundamental graph algorithms, BFS and DFS, which form the foundation for developing more complex <span class="No-Break">graph algorithms.</span></p>
<p>In <a href="B19153_03.xhtml#_idTextAnchor041"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Creating Node Representations with DeepWalk</em>, we will explore the DeepWalk architecture and its two components: Word2Vec and random walks. We will start by understanding the Word2Vec architecture and then implement it using a specialized library. Then, we will delve into the DeepWalk algorithm and implement random walks on <span class="No-Break">a graph.</span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer078">
</div>
</div>
</div></body></html>