["```py\n$ tw-make tw-coin_collector --output t1 --seed 10 --level 5 --format ulx \nGlobal seed: 10 \nGame generated: t1.ulx\n```", "```py\n$ tw-play t1.ulx \nUsing TWInform7\\. \n... \n\nHey, thanks for coming over to the TextWorld today, there \nis something I need you to do for me. First thing I need you \nto do is to try to venture east. Then, venture south. After \nthat, try to go to the south. Once you succeed at that, try \nto go west. If you can finish that, pick-up the coin from \nthe floor of the chamber. Once that’s all handled, you can stop! \n\n-= Spare Room =- \nYou are in a spare room. An usual one. \n\nYou don’t like doors? Why not try going east, that entranceway \nis unblocked. \n\n> _\n```", "```py\n>>> from textworld import gym \n>>> from textworld.gym import register_game \n>>> env_id = register_game(\"t1.ulx\") \n>>> env_id \n’tw-v0’ \n>>> env = gym.make(env_id) \n>>> env \n<textworld.gym.envs.textworld.TextworldGymEnv object at 0x102f77350> \n>>> r = env.reset() \n>>> print(r[1]) \n{} \n>>> print(r[0][1205:]) \n$$ \n\nHey, thanks for coming over to the TextWorld today, there is something I need you to do for me. First thing I need you to do is to try to venture east. Then, venture south. After that, try to go to the south. Once you succeed at that, try to go west. If you can finish that, pick-up the coin from the floor of the chamber. Once that’s all handled, you can stop! \n\n-= Spare Room =- \nYou are in a spare room. An usual one. \n\nYou don’t like doors? Why not try going east, that entranceway is unblocked.\n```", "```py\n>>> from textworld import gym, EnvInfos \n>>> from textworld.gym import register_game \n>>> env_id = register_game(\"t1.ulx\", request_infos=EnvInfos(inventory=True, intermediate_reward=True, admissible_commands=True, description=True)) \n>>> env = gym.make(env_id) \n>>> r = env.reset() \n>>> r[1] \n{’description’: \"-= Spare Room =-\\nYou are in a spare room. An usual one.\\n\\n\\n\\nYou don’t like doors? Why not try going east, that entranceway is unblocked.\", ’admissible_commands’: [’go east’, ’inventory’, ’look’], ’inventory’: ’You are carrying nothing.’, ’intermediate_reward’: 0}\n```", "```py\n>>> r = env.step(’go east’) \n>>> r[1:] \n(0, False, {’description’: \"-= Attic =-\\nYou make a grand eccentric entrance into an attic.\\n\\n\\n\\nYou need an unblocked exit? You should try going south. You don’t like doors? Why not try going west, that entranceway is unblocked.\", ’admissible_commands’: [’go south’, ’go west’, ’inventory’, ’look’], ’inventory’: ’You are carrying nothing.’, ’intermediate_reward’: 1})\n```", "```py\nclass TextWorldPreproc(gym.Wrapper): \n    log = logging.getLogger(\"TextWorldPreproc\") \n\n    OBS_FIELD = \"obs\" \n\n    def __init__( \n            self, env: gym.Env, vocab_rev: tt.Optional[tt.Dict[str, int]], \n            encode_raw_text: bool = False, \n            encode_extra_fields: tt.Iterable[str] = (’description’, ’inventory’), \n            copy_extra_fields: tt.Iterable[str] = (), \n            use_admissible_commands: bool = True, keep_admissible_commands: bool = False, \n            use_intermediate_reward: bool = True, tokens_limit: tt.Optional[int] = None, \n            reward_wrong_last_command: tt.Optional[float] = None \n    ): \n        super(TextWorldPreproc, self).__init__(env) \n        self._vocab_rev = vocab_rev \n        self._encode_raw_text = encode_raw_text \n        self._encode_extra_field = tuple(encode_extra_fields) \n        self._copy_extra_fields = tuple(copy_extra_fields) \n        self._use_admissible_commands = use_admissible_commands \n        self._keep_admissible_commands = keep_admissible_commands \n        self._use_intermedate_reward = use_intermediate_reward \n        self._num_fields = len(self._encode_extra_field) + int(self._encode_raw_text) \n        self._last_admissible_commands = None \n        self._last_extra_info = None \n        self._tokens_limit = tokens_limit \n        self._reward_wrong_last_command = reward_wrong_last_command \n        self._cmd_hist = []\n```", "```py\n @property \n    def num_fields(self): \n        return self._num_fields \n\n    def _maybe_tokenize(self, s: str) -> str | tt.List[int]: \n        if self._vocab_rev is None: \n            return s \n        tokens = common.tokenize(s, self._vocab_rev) \n        if self._tokens_limit is not None: \n            tokens = tokens[:self._tokens_limit] \n        return tokens\n```", "```py\n def _encode(self, obs: str, extra_info: dict) -> dict: \n        obs_result = [] \n        if self._encode_raw_text: \n            obs_result.append(self._maybe_tokenize(obs)) \n        for field in self._encode_extra_field: \n            extra = extra_info[field] \n            obs_result.append(self._maybe_tokenize(extra)) \n        result = {self.OBS_FIELD: obs_result} \n        if self._use_admissible_commands: \n            result[KEY_ADM_COMMANDS] = [ \n                self._maybe_tokenize(cmd) for cmd in extra_info[KEY_ADM_COMMANDS] \n            ] \n            self._last_admissible_commands = extra_info[KEY_ADM_COMMANDS] \n        if self._keep_admissible_commands: \n            result[KEY_ADM_COMMANDS] = extra_info[KEY_ADM_COMMANDS] \n            if ’policy_commands’ in extra_info: \n                result[’policy_commands’] = extra_info[’policy_commands’] \n        self._last_extra_info = extra_info \n        for field in self._copy_extra_fields: \n            if field in extra_info: \n                result[field] = extra_info[field] \n        return result\n```", "```py\n def reset(self, seed: tt.Optional[int] = None): \n        res, extra = self.env.reset() \n        self._cmd_hist = [] \n        return self._encode(res, extra), extra \n\n    def step(self, action): \n        if self._use_admissible_commands: \n            action = self._last_admissible_commands[action] \n            self._cmd_hist.append(action) \n        obs, r, is_done, extra = self.env.step(action) \n        if self._use_intermedate_reward: \n            r += extra.get(’intermediate_reward’, 0) \n        if self._reward_wrong_last_command is not None: \n            if action not in self._last_extra_info[KEY_ADM_COMMANDS]: \n                r += self._reward_wrong_last_command \n        return self._encode(obs, extra), r, is_done, False, extra\n```", "```py\n @property \n    def last_admissible_commands(self): \n        if self._last_admissible_commands: \n            return tuple(self._last_admissible_commands) \n        return None \n\n    @property \n    def last_extra_info(self): \n        return self._last_extra_info\n```", "```py\n>>> from textworld import gym, EnvInfos \n>>> from lib import preproc, common \n>>> env_id = gym.register_game(\"games/simple1.ulx\", request_infos=EnvInfos(inventory=True, intermediate_reward=True, admissible_commands=True, description=True)) \n>>> env = gym.make(env_id) \n>>> env.reset()[1] \n{’intermediate_reward’: 0, ’inventory’: ’You are carrying: a type D latchkey, a teacup and a sponge.’, ’description’: \"-= Spare Room =-\\nThis might come as a shock to you, but you’ve just walked into a spare room. You can barely contain your excitement.\\n\\nYou can make out a closed usual looking crate close by. You can make out a rack. However, the rack, like an empty rack, has nothing on it.\\n\\nThere is an exit to the east. Don’t worry, it is unblocked. You don’t like doors? Why not try going south, that entranceway is unguarded.\", ’admissible_commands’: [’drop sponge’, ’drop teacup’, ’drop type D latchkey’, ’examine crate’, ’examine rack’, ’examine sponge’, ’examine teacup’, ’examine type D latchkey’, ’go east’, ’go south’, ’inventory’, ’look’, ’open crate’, ’put sponge on rack’, ’put teacup on rack’, ’put type D latchkey on rack’]}\n```", "```py\n>>> vocab, action_space, obs_space = common.get_games_spaces([\"games/simple1.ulx\"]) \n>>> vocab \n{0: ’a’, 1: ’about’, 2: ’accomplished’, 3: ’an’, 4: ’and’, 5: ’appears’, 6: ’are’, 7: ’arrive’, 8: ’as’, 9: ’barely’, 10: ’be’, 11: ’because’, 12: ’begin’, 13: ’being’, 14: ’believe’ \n.... \n>>> len(vocab) \n192 \n>>> vocab_rev = common.build_rev_vocab(vocab) \n>>> vocab_rev \n{’a’: 0, ’about’: 1, ’accomplished’: 2, ’an’: 3, ’and’: 4, ’appears’: 5, ’are’: 6, ’arrive’: 7 \n... \n>>> pr_env = preproc.TextWorldPreproc(env, vocab_rev) \n>>> r = pr_env.reset() \n>>> r[0] \n{’obs’: [[142, 132, 166, 106, 26, 8, 0, 136, 167, 188, 17, 188, 86, 180, 82, 0, 142, 132, 188, 20, 9, 27, 191, 57, 188, 20, 103, 121, 0, 24, 178, 101, 35, 23, 18, 188, 20, 103, 121, 0, 129, 77, 161, 129, 94, 3, 50, 129, 73, 111, 115, 85, 163, 84, 3, 58, 167, 161, 44, 152, 186, 85, 84, 172, 188, 152, 94, 41, 184, 110, 169, 72, 141, 159, 53, 84, 173], [188, 6, 0, 170, 36, 92, 0, 157, 4, 0, 143]], ’admissible_commands’: [[42, 143], [42, 157], [42, 170, 36, 92], [55, 35], [55, 129], [55, 143], [55, 157], [55, 170, 36, 92], [71, 44], [71, 141], [83], [100], [117, 35], [127, 143, 115, 129], [127, 157, 115, 129], [127, 170, 36, 92, 115, 129]]} \n>>> r[1] \n{’intermediate_reward’: 0, ’inventory’: ’You are carrying: a type D latchkey, a teacup and a sponge.’, ’description’: \"-= Spare Room =-\\nThis might come as a shock to you, but you’ve just walked into a spare room. You can barely contain your excitement.\\n\\nYou can make out a closed usual looking crate close by. You can make out a rack. However, the rack, like an empty rack, has nothing on it.\\n\\nThere is an exit to the east. Don’t worry, it is unblocked. You don’t like doors? Why not try going south, that entranceway is unguarded.\", ’admissible_commands’: [’drop sponge’, ’drop teacup’, ’drop type D latchkey’, ’examine crate’, ’examine rack’, ’examine sponge’, ’examine teacup’, ’examine type D latchkey’, ’go east’, ’go south’, ’inventory’, ’look’, ’open crate’, ’put sponge on rack’, ’put teacup on rack’, ’put type D latchkey on rack’]}\n```", "```py\n>>> r[1][’inventory’] \n’You are carrying: a type D latchkey, a teacup and a sponge.’ \n>>> obs, reward, is_done, _, info = pr_env.step(0) \n>>> info[’inventory’] \n’You are carrying: a type D latchkey and a teacup.’ \n>>> reward \n0\n```", "```py\nclass Encoder(nn.Module): \n    def __init__(self, emb_size: int, out_size: int): \n        super(Encoder, self).__init__() \n        self.net = nn.LSTM(input_size=emb_size, hidden_size=out_size, batch_first=True) \n\n    def forward(self, x): \n        self.net.flatten_parameters() \n        _, hid_cell = self.net(x) \n        return hid_cell[0].squeeze(0)\n```", "```py\nclass Preprocessor(nn.Module): \n    def __init__(self, dict_size: int, emb_size: int, num_sequences: int, \n                 enc_output_size: int, extra_flags: tt.Sequence[str] = ()): \n        super(Preprocessor, self).__init__() \n        self._extra_flags = extra_flags \n        self._enc_output_size = enc_output_size \n        self.emb = nn.Embedding(num_embeddings=dict_size, embedding_dim=emb_size) \n        self.encoders = [] \n        for idx in range(num_sequences): \n            enc = Encoder(emb_size, enc_output_size) \n            self.encoders.append(enc) \n            self.add_module(f\"enc_{idx}\", enc) \n        self.enc_commands = Encoder(emb_size, enc_output_size)\n```", "```py\n def _apply_encoder(self, batch: tt.List[tt.List[int]], encoder: Encoder): \n        dev = self.emb.weight.device \n        batch_t = [self.emb(torch.tensor(sample).to(dev)) for sample in batch] \n        batch_seq = rnn_utils.pack_sequence(batch_t, enforce_sorted=False) \n        return encoder(batch_seq)\n```", "```py\n def encode_observations(self, observations: tt.List[dict]) -> torch.Tensor: \n        sequences = [obs[TextWorldPreproc.OBS_FIELD] for obs in observations ] \n        res_t = self.encode_sequences(sequences) \n        if not self._extra_flags: \n            return res_t \n        extra = [[obs[field] for field in self._extra_flags] for obs in observations] \n        extra_t = torch.Tensor(extra).to(res_t.device) \n        res_t = torch.cat([res_t, extra_t], dim=1) \n        return res_t\n```", "```py\n def encode_sequences(self, batches): \n        data = [] \n        for enc, enc_batch in zip(self.encoders, zip(*batches)): \n            data.append(self._apply_encoder(enc_batch, enc)) \n        res_t = torch.cat(data, dim=1) \n        return res_t \n\n    def encode_commands(self, batch): \n        return self._apply_encoder(batch, self.enc_commands)\n```", "```py\nclass DQNModel(nn.Module): \n    def __init__(self, obs_size: int, cmd_size: int, hid_size: int = 256): \n        super(DQNModel, self).__init__() \n\n        self.net = nn.Sequential( \n            nn.Linear(obs_size + cmd_size, hid_size), \n            nn.ReLU(), \n            nn.Linear(hid_size, 1) \n        ) \n\n    def forward(self, obs, cmd): \n        x = torch.cat((obs, cmd), dim=1) \n        return self.net(x) \n\n    @torch.no_grad() \n    def q_values(self, obs_t, commands_t): \n        result = [] \n        for cmd_t in commands_t: \n            qval = self(obs_t, cmd_t.unsqueeze(0))[0].cpu().item() \n            result.append(qval) \n        return result\n```", "```py\n$ ./train_basic.py -s 1 --dev cuda -r t1 \nRegistered env tw-simple-v0 for game files [’games/simple1.ulx’] \nGame tw-simple-v1, with file games/simple-val.ulx will be used for validation \nEpisode 1: reward=0 (avg 0.00), steps=50 (avg 50.00), speed=0.0 f/s, elapsed=0:00:04 \nEpisode 2: reward=1 (avg 0.02), steps=50 (avg 50.00), speed=0.0 f/s, elapsed=0:00:04 \n1: best avg training reward: 0.020, saved \nEpisode 3: reward=-2 (avg -0.02), steps=50 (avg 50.00), speed=0.0 f/s, elapsed=0:00:04 \nEpisode 4: reward=6 (avg 0.10), steps=30 (avg 49.60), speed=0.0 f/s, elapsed=0:00:04 \n...\n```", "```py\n>>> from sentence_transformers import SentenceTransformer \n>>> tr = SentenceTransformer(\"sentence-transformers/all-MiniLM-L6-v2\") \n>>> tr.get_sentence_embedding_dimension() \n384 \n>>> r = tr.encode(\"You’re standing in an ordinary boring room\") \n>>> type(r) \n<class ’numpy.ndarray’> \n>>> r.shape \n(384,) \n>>> r2 = tr.encode([\"sentence 1\", \"sentence 2\"], convert_to_tensor=True) \n>>> type(r2) \n<class ’torch.Tensor’> \n>>> r2.shape \ntorch.Size([2, 384])\n```", "```py\n$ pip install langchain==0.1.15 langchain-openai==0.1.2\n```", "```py\n env_id = register_game( \n            gamefile=f\"games/{args.game}{index}.ulx\", \n            request_infos=EnvInfos(description=True, objective=True), \n        ) \n        env = gym.make(env_id)\n```", "```py\ndef play_game(env, max_steps: int = 20) -> bool: \n    commands = [] \n\n    obs, info = env.reset() \n\n    print(textwrap.dedent(\"\"\"\\ \n    You’re playing the interactive fiction game. \n    Here is the game objective: %s \n\n    Here is the room description: %s \n\n    What command do you want to execute next? Reply with \n    just a command in lowercase and nothing else. \n    \"\"\")  % (info[’objective’], info[’description’])) \n\n    print(\"=== Send this to chat.openai.com and type the reply...\")\n```", "```py\n while len(commands) < max_steps: \n        cmd = input(\">>> \") \n        commands.append(cmd) \n        obs, r, is_done, info = env.step(cmd) \n        if is_done: \n            print(f\"You won in {len(commands)} steps! \" \n                  f\"Don’t forget to congratulate ChatGPT!\") \n            return True \n\n        print(textwrap.dedent(\"\"\"\\ \n        Last command result: %s \n        Room description: %s \n\n        What’s the next command? \n        \"\"\") % (obs, info[’description’])) \n        print(\"=== Send this to chat.openai.com and type the reply...\") \n\n    print(f\"Wasn’t able to solve after {max_steps} steps, commands: {commands}\") \n    return False\n```", "```py\n$ ./chatgpt_interactive.py 1 \nStarting game 1 \n\nYou’re playing the interactive fiction game. \nHere is the game objective: Get ready to pick stuff up and put it in places, because you’ve just entered TextWorld! Here is your task for today. First stop, go to the south. And then, head east. With that over with, make an effort to go north. With that accomplished, ensure that the type D locker is open. Then, take the keyboard from the type D locker. That’s it! \n\nHere is the room description: -= Spare Room =- \nWhat command do you want to execute next? Reply with \njust a command in lowercase and nothing else. \n\n=== Send this to chat.openai.com and type the reply... \n>>> go south \nLast command result: -= Dish-Pit =- \nRoom description: -= Dish-Pit =- \nWhat’s the next command? \n\n=== Send this to chat.openai.com and type the reply... \n>>> go east \nLast command result: -= Cookhouse =- \nRoom description: -= Cookhouse =- \nWhat’s the next command? \n\n=== Send this to chat.openai.com and type the reply... \n>>> go north \nLast command result: -= Studio =- \nRoom description: -= Studio =- \nWhat’s the next command? \n\n=== Send this to chat.openai.com and type the reply... \n>>> open type d locker \nLast command result: You open the type D locker, revealing a keyboard. \nRoom description: -= Studio =- \nWhat’s the next command? \n\n=== Send this to chat.openai.com and type the reply... \n>>> take keyboard \nYou won in 5 steps! Don’t forget to congratulate ChatGPT!\n```", "```py\nfrom langchain_openai import ChatOpenAI \nfrom langchain_core.output_parsers import StrOutputParser \nfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder \n\ndef play_game(env, max_steps: int = 20) -> bool: \n    prompt_init = ChatPromptTemplate.from_messages([ \n        (\"system\", \"You’re playing the interactive fiction game. \" \n                   \"Reply with just a command in lowercase and nothing else\"), \n        (\"system\", \"Game objective: {objective}\"), \n        (\"user\", \"Room description: {description}\"), \n        (\"user\", \"What command you want to execute next?\"), \n    ]) \n    llm = ChatOpenAI() \n    output_parser = StrOutputParser()\n```", "```py\n commands = [] \n\n    obs, info = env.reset() \n    init_msg = prompt_init.invoke({ \n        \"objective\": info[’objective’], \n        \"description\": info[’description’], \n    }) \n\n    context = init_msg.to_messages() \n    ai_msg = llm.invoke(init_msg) \n    context.append(ai_msg) \n    cmd = output_parser.invoke(ai_msg)\n```", "```py\n prompt_next = ChatPromptTemplate.from_messages([ \n        MessagesPlaceholder(variable_name=\"chat_history\"), \n        (\"user\", \"Last command result: {result}\"), \n        (\"user\", \"Room description: {description}\"), \n        (\"user\", \"What command you want to execute next?\"), \n    ]) \n\n    for _ in range(max_steps): \n        commands.append(cmd) \n        print(\">>>\", cmd) \n        obs, r, is_done, info = env.step(cmd) \n        if is_done: \n            print(f\"I won in {len(commands)} steps!\") \n            return True \n\n        user_msgs = prompt_next.invoke({ \n            \"chat_history\": context, \n            \"result\": obs.strip(), \n            \"description\": info[’description’], \n        }) \n        context = user_msgs.to_messages() \n        ai_msg = llm.invoke(user_msgs) \n        context.append(ai_msg) \n        cmd = output_parser.invoke(ai_msg)\n```", "```py\n print(f\"Wasn’t able to solve after {max_steps} steps, commands: {commands}\") \n    return False\n```"]