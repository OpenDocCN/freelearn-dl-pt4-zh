<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Neural Networks Foundations</h1>
            </header>

            <article>
                
<p>Artificial neural networks (briefly, <em>nets</em>) represent a class of machine learning models, loosely inspired by studies about the central nervous systems of mammals. Each net is made up of several interconnected <em>neurons</em>, organized in <em>layers</em>, which exchange messages (they <em>fire</em>, in jargon) when certain conditions happen. Initial studies were started in the late 1950s with the introduction of the perceptron (for more information, refer to the article: <span><em>The Perceptron: A Probabilistic Model for Information Storage and Organization in the Brain</em>, by F. Rosenblatt,</span> Psychological Review,<span> vol. 65, pp. 386 - 408, 1958</span>), a two-layer network used for simple operations, and further expanded in the late 1960s with the introduction of the <em>backpropagation algorithm</em>, used for efficient multilayer networks training (according to the articles: <span><em>Backpropagation through Time: What It Does and How to Do It</em>, by P. J. Werbos, P</span>roceedings of the IEEE<span>, vol. 78, pp. 1550 - 1560, 1990, and <em>A Fast Learning Algorithm for Deep Belief Nets</em>, by G. E. Hinton, S. Osindero, and Y. W. Teh, Neural Computing, vol. 18, pp. 1527 - 1554, 2006</span>). Some studies argue that these techniques have roots dating further back than normally cited (for more information, refer to the article:<span> <em>Deep Learning in Neural Networks: An Overview</em>, by J. Schmidhuber,</span><span> vol. 61, pp. 85 - 117, 2015</span>). Neural networks were a topic of intensive academic studies until the 1980s, when other simpler approaches became more relevant. However, there has been a resurrection of interest starting from the mid-2000s, thanks to both a breakthrough fast-learning algorithm proposed by G. Hinton (for more information, refer to the articles: <em>The Roots of Backpropagation: From Ordered Derivatives to Neural Networks and Political Forecasting</em>, <em>Neural Networks</em>, <span>by S. Leven,</span><span> vol. 9, 1996 and <em>Learning Representations by Backpropagating Errors</em>, by D. E. Rumelhart, G. E. Hinton, and R. J. Williams, vol. 323, 1986</span>) and the introduction of GPUs, roughly in 2011, for massive numeric computation.</p>
<p>These improvements opened the route for modern <em>deep learning</em>, a class of neural networks characterized by a significant number of layers of neurons, which are able to learn rather sophisticated models based on progressive levels of abstraction. People called it <em>deep</em> with 3-5 layers a few years ago, and now it has gone up to 100-200.</p>
<p>This learning via progressive abstraction resembles vision models that have evolved over millions of years in the human brain. The human visual system is indeed organized into different layers. Our eyes are connected to an area of the brain called the <strong>visual cortex V1</strong>, which is located in the lower posterior part of our brain. This area is common to many mammals and has the role of discriminating basic properties and small changes in visual orientation, spatial frequencies, and colors. It has been estimated that V1 consists of about 140 million neurons, with 10 billion connections between them. V1 is then connected with other areas V2, V3, V4, V5, and V6, doing progressively more complex image processing and recognition of more sophisticated concepts, such as shapes, faces, animals, and many more. This organization in layers is the result of a huge number of attempts tuned over several 100 million years. It has been estimated that there are ~16 billion human cortical neurons, and about 10%-25% of the human cortex is devoted to vision (for more information, refer to the article:<span> </span><em>The Human Brain in Numbers: A Linearly Scaled-up Primate Brain</em>, by S. Herculano-Houzel, vol. 3, 2009). Deep learning has taken some inspiration from this layer-based organization of the human visual system: early artificial neuron layers learn basic properties of images, while deeper layers learn more sophisticated concepts.</p>
<p>This book covers several major aspects of neural networks by providing working nets coded in Keras, a minimalist and efficient Python library for deep learning computations running on the top of either Google's TensorFlow (for more information, refer to <a href="https://www.tensorflow.org/" target="_blank">https://www.tensorflow.org/</a>) or University of Montreal's Theano (<span>for more information, refer to <a href="http://deeplearning.net/software/theano/" target="_blank">http://deeplearning.net/software/theano/</a></span>) backend. So, let's start.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Perceptron</li>
<li>Multilayer perceptron</li>
<li>Activation functions</li>
<li>Gradient descent</li>
<li>Stochastic gradient descent</li>
<li>Backpropagation</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Perceptron</h1>
            </header>

            <article>
                
<p>The perceptron is a simple algorithm which, given an input vector <em>x</em> of <em>m</em> values (<em>x<sub>1</sub></em>, <em>x<sub>2</sub></em>, ..., <em>x<sub>n</sub></em>) often called input features or simply features, outputs either <em>1</em> (yes) or <em>0</em> (no). Mathematically, we define a function:</p>
<div class="CDPAlignCenter CDPAlign"><img height="44" src="assets/image_01_005.png" width="187"/></div>
<p>Here, <em>w</em> is a vector of weights, <em>wx</em> is the dot product <img height="25" src="assets/image_01_008.jpg" width="53"/>, and <em>b</em> is a bias. If you remember elementary geometry, <em>wx + b</em> defines a boundary hyperplane that changes position according to the values assigned to <em>w</em> and <em>b</em>. If <em>x</em> lies above the straight line, then the answer is positive, otherwise it is negative. Very simple algorithm! The perception cannot express a <em>maybe</em> answer. It can answer <em>yes</em> (<em>1</em>) or <em>no</em> (<em>0</em>) if we understand how to define <em>w</em> and <em>b</em>, that is the training process that will be discussed in the following paragraphs.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The first example of Keras code</h1>
            </header>

            <article>
                
<p>The initial building block of Keras is a model, and the simplest model is called <strong>sequential</strong>. A sequential Keras model is a linear pipeline (a stack) of neural networks layers. This code fragment defines a single layer with <kbd>12</kbd> artificial neurons, and it expects <kbd>8</kbd> input variables (also known as features):</p>
<pre>
from keras.models import Sequential<br/>model = Sequential()<br/>model.add(Dense(12, input_dim=8, kernel_initializer='random_uniform'))
</pre>
<p>Each neuron can be initialized with specific weights. Keras provides a few choices, the most common of which are listed as follows:</p>
<ul>
<li><kbd>random_uniform</kbd>: Weights are initialized to uniformly random small values in (<em>-0.05</em>, <em>0.05</em>). <span>In other words, any value within the given interval is equally likely to be drawn.</span></li>
<li><kbd>random_normal</kbd>: Weights are initialized according to a Gaussian, with a zero mean and small standard deviation of <em>0.05</em>. For those of you who are not familiar with a Gaussian, think about a symmetric <em>bell curve</em> shape.</li>
<li><kbd>zero</kbd>: All weights are initialized to zero.</li>
</ul>
<p>A full list is available at <a href="https://keras.io/initializations/" target="_blank">https://keras.io/initializations/</a>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Multilayer perceptron — the first example of a network</h1>
            </header>

            <article>
                
<p>In this chapter, we define the first example of a network with multiple linear layers. Historically, perceptron was the name given to a model having one single linear layer, and as a consequence, if it has multiple layers, you would call it <strong>multilayer perceptron</strong> (<strong>MLP</strong>). The following image represents a generic neural network with one input layer, one intermediate layer and one output layer.</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="136" src="assets/B06258_01_02.png" width="214"/></div>
<p>In the preceding diagram, each node in the first layer receives an input and fires according to the predefined local decision boundaries. Then the output of the first layer is passed to the second layer, the results of which are passed to the final output layer consisting of one single neuron. It is interesting to note that this layered organization vaguely resembles the patterns of human vision we discussed earlier.</p>
<div class="packt_infobox">The <em>net</em> is dense, meaning that each neuron in a layer is connected to all neurons located in the previous layer and to all the neurons in the following layer.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Problems in training the perceptron and a solution</h1>
            </header>

            <article>
                
<p>Let's consider a single neuron; what are the best choices for the weight <em>w</em> and the bias <em>b</em>? Ideally, we would like to provide a set of training examples and let the computer adjust the weight and the bias in such a way that the errors produced in the output are minimized. In order to make this a bit more concrete, let's suppose we have a set of images of cats and another separate set of images not containing cats. For the sake of simplicity, assume that each neuron looks at a single input pixel value. While the computer processes these images, we would like our neuron to adjust its weights and bias so that we have fewer and fewer images wrongly recognized as non-cats. This approach seems very intuitive, but it requires that a small change in weights (and/or bias) causes only a small change in outputs.</p>
<p>If we have a big output jump, we cannot <em>progressively</em> learn (rather than trying things in all possible directions—a process known as exhaustive search—without knowing if we are improving). After all, kids learn little by little. Unfortunately, the perceptron does not show this little-by-little behavior. A perceptron is either <em>0</em> or <em>1</em> and that is a big jump and it will not help it to learn, as shown in the following graph:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="264" src="assets/B06258_01_03.png" width="357"/></div>
<p>We need something different, smoother. We need a function that progressively changes from <em>0</em> to <em>1</em> with no discontinuity. Mathematically, this means that we need a continuous function that allows us to compute the derivative.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Activation function — sigmoid</h1>
            </header>

            <article>
                
<p>The sigmoid function is defined as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="44" src="assets/image_01_068.jpg" width="101"/></div>
<p>As represented in the following graph, it has small output changes in <em>(0, 1)</em> when the input varies in <img height="20" src="assets/image_01_020.jpg" width="41"/>. Mathematically, the function is continuous. A typical sigmoid function is represented in the following graph:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="236" src="assets/B06258_01_05.png" width="340"/></div>
<p>A neuron can use the sigmoid for computing the nonlinear function <img src="assets/image_01_022.png"/>. Note that, if <img src="assets/image_01_023.png"/> is very large and positive, then <img height="20" src="assets/image_01_024.jpg" width="51"/>, so <img height="22" src="assets/image_01_025.jpg" width="53"/>, while if <img height="18" src="assets/image_01_026.jpg" width="66"/> is very large and negative <img height="22" src="assets/image_01_027.jpg" width="60"/> so <img height="22" src="assets/image_01_028.jpg" width="56"/>. In other words, a neuron with sigmoid activation has a behavior similar to the perceptron, but the changes are gradual and output values, such as <em>0.5539</em> or <em>0.123191</em>, are perfectly legitimate. In this sense, a sigmoid neuron can answer <em>maybe</em>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Activation function — ReLU</h1>
            </header>

            <article>
                
<p>The sigmoid is not the only kind of smooth activation function used for neural networks. Recently, a very simple function called <strong>rectified linear unit</strong> (<strong>ReLU</strong>) became very popular because it generates very good experimental results. A ReLU is simply defined as <img height="22" src="assets/image_01_029.jpg" width="97"/>, and the nonlinear function is represented in the following graph. As you can see in the following graph, the function is zero for negative values, and it grows linearly for positive values:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="151" src="assets/B06258_01_06.png" width="379"/>              </div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Activation functions</h1>
            </header>

            <article>
                
<p>Sigmoid and ReLU are generally called <em>activation functions</em> in neural network jargon. In the <em>Testing different optimizers in Keras</em> section, we will see that those gradual changes, typical of sigmoid and ReLU functions, are the basic building blocks to developing a learning algorithm which adapts little by little, by progressively reducing the mistakes made by our nets. An example of using the activation function σ with the (<em>x<sub>1</sub></em>, <em>x<sub>2</sub></em>, ..., <em>x<sub>m</sub></em>) input vector, (<em>w<sub>1</sub></em>, <em>w<sub>2</sub></em>, <em>...</em>, <em>w<sub>m</sub></em>) weight vector, <em>b</em> bias, and Σ summation is given in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="181" src="assets/B06258_01_07.png" width="363"/></div>
<p>Keras supports a number of activation functions, and a full list is available at <a href="https://keras.io/activations/" target="_blank">https://keras.io/activations/</a>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">A real example — recognizing handwritten digits</h1>
            </header>

            <article>
                
<p>In this section, we will build a network that can recognize handwritten numbers. For achieving this goal, we use MNIST (for more information, refer to <a href="http://yann.lecun.com/exdb/mnist/" target="_blank">http://yann.lecun.com/exdb/mnist/</a>), a database of handwritten digits made up of a training set of 60,000 examples and a test set of 10,000 examples. The training examples are annotated by humans with the correct answer. For instance, if the handwritten digit is the number three, then three is simply the label associated with that example.</p>
<p>In machine learning, when a dataset with correct answers is available, we say that we can perform a form of <em>supervised learning</em>. In this case, we can use training examples for tuning up our net. Testing examples also have the correct answer associated with each digit. In this case, however, the idea is to pretend that the label is unknown, let the network do the prediction, and then later on, reconsider the label to evaluate how well our neural network has learned to recognize digits. So, not unsurprisingly, testing examples are just used to test our net.</p>
<p>Each MNIST image is in gray scale, and it consists of 28 x 28 pixels. A subset of these numbers is represented in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="101" src="assets/B06258_01_08.png" width="131"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">One-hot encoding — OHE</h1>
            </header>

            <article>
                
<p>In many applications, it is convenient to transform categorical (non-numerical) features into numerical variables. For instance, the categorical feature digit with the value <em>d</em> in <em>[0-9]</em> can be encoded into a binary vector with <em>10</em> positions, which always has <em>0</em> value, except the <em>d</em>-th position where a <em>1</em> is present. This type of representation is called <strong>one-hot encoding</strong> (<strong>OHE</strong>) and is very common in data mining when the learning algorithm is specialized for dealing with numerical functions.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Defining a simple neural net in Keras</h1>
            </header>

            <article>
                
<p>Here, we use Keras to define a network that recognizes MNIST handwritten digits. We start with a very simple neural network and then progressively improve it.</p>
<p>Keras provides suitable libraries to load the dataset and split it into training sets <kbd>X_train</kbd><em>,</em> used for fine-tuning our net, and tests set <em><kbd>X_test</kbd>,</em> used for assessing the performance. Data is converted into <kbd>float32</kbd> for supporting GPU computation and normalized to <em>[0, 1]</em>. In addition, we load the true labels into <kbd>Y_train</kbd> and <kbd>Y_test</kbd> respectively and perform a one-hot encoding on them. Let's see the code:</p>
<pre>
from __future__ import print_function<br/>import numpy as np<br/>from keras.datasets import mnist<br/>from keras.models import Sequential<br/>from keras.layers.core import Dense, Activation<br/>from keras.optimizers import SGD<br/>from keras.utils import np_utils<br/>np.random.seed(1671) # for reproducibility<br/><br/># network and training<br/>NB_EPOCH = 200<br/>BATCH_SIZE = 128<br/>VERBOSE = 1<br/>NB_CLASSES = 10 # number of outputs = number of digits<br/>OPTIMIZER = SGD() # SGD optimizer, explained later in this chapter<br/>N_HIDDEN = 128<br/>VALIDATION_SPLIT=0.2 # how much TRAIN is reserved for VALIDATION<br/><br/># data: shuffled and split between train and test sets<br/>#<br/>(X_train, y_train), (X_test, y_test) = mnist.load_data()<br/>#X_train is 60000 rows of 28x28 values --&gt; reshaped in 60000 x 784<br/>RESHAPED = 784<br/>#<br/>X_train = X_train.reshape(60000, RESHAPED)<br/>X_test = X_test.reshape(10000, RESHAPED)<br/>X_train = X_train.astype('float32')<br/>X_test = X_test.astype('float32')<br/># normalize<br/>#<br/>X_train /= 255<br/>X_test /= 255<br/>print(X_train.shape[0], 'train samples')<br/>print(X_test.shape[0], 'test samples')<br/># convert class vectors to binary class matrices<br/>Y_train = np_utils.to_categorical(y_train, NB_CLASSES)<br/>Y_test = np_utils.to_categorical(y_test, NB_CLASSES)
</pre>
<p>The input layer has a neuron associated with each pixel in the image for a total of <em>28 x 28 = 784</em> neurons, one for each pixel in the MNIST images.</p>
<p>Typically, the values associated with each pixel are normalized in the range <em>[0, 1]</em> (which means that the intensity of each pixel is divided by 255, the maximum intensity value). The output is 10 classes, one for each digit.</p>
<p>The final layer is a single neuron with activation function softmax, which is a generalization of the sigmoid function<em>.</em> Softmax <em>squashes</em> a k-dimensional vector of arbitrary real values into a k-dimensional vector of real values in the range <em>(0, 1)</em>. In our case, it aggregates 10 answers provided by the previous layer with 10 neurons:</p>
<pre>
# 10 outputs<br/># final stage is softmax<br/>model = Sequential()<br/>model.add(Dense(NB_CLASSES, input_shape=(RESHAPED,)))<br/>model.add(Activation('softmax'))<br/>model.summary()
</pre>
<p>Once we define the model, we have to compile it so that it can be executed by the Keras backend (either Theano or TensorFlow). There are a few choices to be made during compilation:</p>
<ul>
<li>We need to select the <em>optimizer</em> that is the specific algorithm used to update weights while we train our model</li>
<li>We need to select the <em>objective function</em> that is used by the optimizer to navigate the space of weights (frequently, objective functions are called <em>loss function</em>, and the process of optimization is defined as a process of loss <em>minimization</em>)</li>
<li>We need to evaluate the trained model</li>
</ul>
<p>Some common choices for the objective function (a<span> complete list of Keras objective functions is at </span><a href="https://keras.io/objectives/">https://keras.io/objectives/</a>) are as follows:</p>
<ul>
<li><strong>MSE</strong>: This is the mean squared error between the predictions and the true values. Mathematically, if <img height="15" src="assets/image_01_042.jpg" width="14"/> is a vector of <em>n</em> predictions, and <em>Y</em> is the vector of <em>n</em> observed values, then they satisfy the following equation:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="51" src="assets/image_01_043.png" width="257"/></div>
<div class="packt_infobox">These objective functions average all the mistakes made for each prediction, and if the prediction is far from the true value, then this distance is made more evident by the squaring operation.</div>
<ul>
<li><strong>Binary cross-entropy</strong>: This is the binary logarithmic loss. Suppose that our model predicts <em>p</em> while the target is <em>t</em>, then the binary cross-entropy is defined as follows:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="16" src="assets/image_01_044.png" width="180"/></div>
<div class="packt_infobox">This objective function is suitable for binary labels prediction.</div>
<ul>
<li><strong>Categorical cross-entropy</strong>: This is the multiclass logarithmic loss. If the target is <em>t<sub>i,j</sub></em> and the prediction is <em>p<sub>i,j</sub></em>, then the categorical cross-entropy is this:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="18" src="assets/image_01_047.png" width="153"/></div>
<div class="packt_infobox">This objective function is suitable for multiclass labels predictions. It is also the default choice in association with softmax activation.</div>
<p>Some common choices for metrics (a<span> complete list of Keras metrics is at </span><a href="https://keras.io/metrics/">https://keras.io/metrics/</a>) are as follows:</p>
<ul>
<li><strong>Accuracy</strong>: This is the proportion of correct predictions with respect to the targets</li>
<li><strong>Precision</strong>: This denotes how many selected items are relevant for a multilabel classification</li>
<li><strong>Recall</strong>: This denotes how many selected items are relevant for a multilabel classification</li>
</ul>
<p>Metrics are similar to objective functions, with the only difference that they are not used for training a model but only for evaluating a model. Compiling a model in Keras is easy:</p>
<pre>
model.compile(loss='categorical_crossentropy', optimizer=OPTIMIZER, metrics=['accuracy'])
</pre>
<p>Once the model is compiled, it can be then trained with the <kbd>fit()</kbd> function, which specifies a few parameters:</p>
<ul>
<li><kbd>epochs</kbd>: This is the number of times the model is exposed to the training set. At each iteration, the optimizer tries to adjust the weights so that the objective function is minimized.</li>
<li><kbd>batch_size</kbd>: This is the number of training instances observed before the optimizer performs a weight update.</li>
</ul>
<p>Training a model in Keras is very simple. Suppose we want to iterate for <kbd>NB_EPOCH</kbd> steps:</p>
<pre>
history = model.fit(X_train, Y_train,<br/>batch_size=BATCH_SIZE, epochs=NB_EPOCH,<br/>verbose=VERBOSE, validation_split=VALIDATION_SPLIT)
</pre>
<div class="packt_infobox">We reserved part of the training set for validation. The key idea is that we reserve a part of the training data for measuring the performance on the validation while training. This is a good practice to follow for any machine learning task, which we will adopt in all our examples.</div>
<p>Once the model is trained, we can evaluate it on the test set that contains new unseen examples. In this way, we can get the minimal value reached by the objective function and best value reached by the evaluation metric.</p>
<p>Note that the training set and the test set are, of course, rigorously separated. There is no point in evaluating a model on an example that has already been used for training. Learning is essentially a process intended to generalize unseen observations and not to memorize what is already known:</p>
<pre>
score = model.evaluate(X_test, Y_test, verbose=VERBOSE)<br/>print("Test score:", score[0])<br/>print('Test accuracy:', score[1])
</pre>
<p>So, congratulations, you have just defined your first neural network in Keras. A few lines of code, and your computer is able to recognize handwritten numbers. Let's run the code and see what the performance is.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Running a simple Keras net and establishing a baseline</h1>
            </header>

            <article>
                
<p>So let's see what will happen when we run the code in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="343" src="assets/B06258_01_12.png" width="784"/></div>
<p>First, the net architecture is dumped, and we can see the different types of layers used, their output shape, how many parameters they need to optimize, and how they are connected. Then, the network is trained on 48,000 samples, and 12,000 are reserved for validation. Once the neural model is built, it is then tested on 10,000 samples. As you can see, Keras is internally using TensorFlow as a backend system for computation. For now, we don't go into the internals on how the training happens, but we can notice that the program runs for 200 iterations, and each time, the accuracy improves. When the training ends, we test our model on the test set and achieve about 92.36% accuracy on training, 92.27% on validation, and 92.22% on the test.</p>
<p>This means that a bit less than one handwritten character out of ten is not correctly recognized. We can certainly do better than that. In the following screenshot, we can see the test accuracy:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="123" src="assets/B06258_01_12a.png" width="681"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Improving the simple net in Keras with hidden layers</h1>
            </header>

            <article>
                
<p>We have a baseline accuracy of 92.36% on training, 92.27% on validation, and 92.22% on the test. This is a good starting point, but we can certainly improve it. Let's see how.</p>
<p>A first improvement is to add additional layers to our network. So, after the input layer, we have a first dense layer with the <kbd>N_HIDDEN</kbd> neurons and an activation function <kbd>relu</kbd>. This additional layer is considered <em>hidden</em> because it is not directly connected to either the input or the output. After the first hidden layer, we have a second hidden layer, again with the <kbd>N_HIDDEN</kbd> neurons, followed by an output layer with 10 neurons, each of which will fire when the relative digit is recognized. The following code defines this new network:</p>
<pre>
from __future__ import print_function<br/>import numpy as np<br/>from keras.datasets import mnist<br/>from keras.models import Sequential<br/>from keras.layers.core import Dense, Activation<br/>from keras.optimizers import SGD<br/>from keras.utils import np_utils<br/>np.random.seed(1671) # for reproducibility<br/># network and training<br/>NB_EPOCH = 20<br/>BATCH_SIZE = 128<br/>VERBOSE = 1<br/>NB_CLASSES = 10 # number of outputs = number of digits<br/>OPTIMIZER = SGD() # optimizer, explained later in this chapter<br/>N_HIDDEN = 128<br/>VALIDATION_SPLIT=0.2 # how much TRAIN is reserved for VALIDATION<br/># data: shuffled and split between train and test sets<br/>(X_train, y_train), (X_test, y_test) = mnist.load_data()<br/>#X_train is 60000 rows of 28x28 values --&gt; reshaped in 60000 x 784<br/>RESHAPED = 784<br/>#<br/>X_train = X_train.reshape(60000, RESHAPED)<br/>X_test = X_test.reshape(10000, RESHAPED)<br/>X_train = X_train.astype('float32')<br/>X_test = X_test.astype('float32')<br/># normalize<br/>X_train /= 255<br/>X_test /= 255<br/>print(X_train.shape[0], 'train samples')<br/>print(X_test.shape[0], 'test samples')<br/># convert class vectors to binary class matrices<br/>Y_train = np_utils.to_categorical(y_train, NB_CLASSES)<br/>Y_test = np_utils.to_categorical(y_test, NB_CLASSES)<br/># M_HIDDEN hidden layers<br/># 10 outputs<br/># final stage is softmax<br/>model = Sequential()<br/>model.add(Dense(N_HIDDEN, input_shape=(RESHAPED,)))<br/>model.add(Activation('relu'))<br/>model.add(Dense(N_HIDDEN))<br/>model.add(Activation('relu'))<br/>model.add(Dense(NB_CLASSES))<br/>model.add(Activation('softmax'))<br/>model.summary()<br/>model.compile(loss='categorical_crossentropy',<br/>optimizer=OPTIMIZER,<br/>metrics=['accuracy'])<br/>history = model.fit(X_train, Y_train,<br/>batch_size=BATCH_SIZE, epochs=NB_EPOCH,<br/>verbose=VERBOSE, validation_split=VALIDATION_SPLIT)<br/>score = model.evaluate(X_test, Y_test, verbose=VERBOSE)<br/>print("Test score:", score[0])<br/>print('Test accuracy:', score[1])
</pre>
<p>Let's run the code and see which result we get with this multilayer network. Not bad. By adding two hidden layers, we reached 94.50% on the training set, 94.63% on validation, and 94.41% on the test. This means that we gained an additional 2.2% accuracy on the test with respect to the previous network. However, we dramatically reduced the number of iterations from 200 to 20. That's good, but we want more.</p>
<p>If you want, you can play by yourself and see what happens if you add only one hidden layer instead of two, or if you add more than two layers. I leave this experiment as an exercise. The following screenshot shows the output of the preceding example:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="624" src="assets/B06258_01_13.png" width="544"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Further improving the simple net in Keras with dropout</h1>
            </header>

            <article>
                
<p>Now our baseline is 94.50% on the training set, 94.63% on validation, and 94.41% on the test. A second improvement is very simple. We decide to randomly drop with the dropout probability some of the values propagated inside our internal dense network of hidden layers. In machine learning, this is a well-known form of regularization. Surprisingly enough, this idea of randomly dropping a few values can improve our performance:</p>
<pre>
from __future__ import print_function<br/>import numpy as np<br/>from keras.datasets import mnist<br/>from keras.models import Sequential<br/>from keras.layers.core import Dense, Dropout, Activation<br/>from keras.optimizers import SGD<br/>from keras.utils import np_utils<br/>np.random.seed(1671) # for reproducibility<br/># network and training<br/>NB_EPOCH = 250<br/>BATCH_SIZE = 128<br/>VERBOSE = 1<br/>NB_CLASSES = 10 # number of outputs = number of digits<br/>OPTIMIZER = SGD() # optimizer, explained later in this chapter<br/>N_HIDDEN = 128<br/>VALIDATION_SPLIT=0.2 # how much TRAIN is reserved for VALIDATION<br/>DROPOUT = 0.3<br/># data: shuffled and split between train and test sets<br/>(X_train, y_train), (X_test, y_test) = mnist.load_data()<br/>#X_train is 60000 rows of 28x28 values --&gt; reshaped in 60000 x 784<br/>RESHAPED = 784<br/>#<br/>X_train = X_train.reshape(60000, RESHAPED)<br/>X_test = X_test.reshape(10000, RESHAPED)<br/>X_train = X_train.astype('float32')<br/>X_test = X_test.astype('float32')<br/># normalize<br/>X_train /= 255<br/>X_test /= 255<br/># convert class vectors to binary class matrices<br/>Y_train = np_utils.to_categorical(y_train, NB_CLASSES)<br/>Y_test = np_utils.to_categorical(y_test, NB_CLASSES)<br/># M_HIDDEN hidden layers 10 outputs<br/>model = Sequential()<br/>model.add(Dense(N_HIDDEN, input_shape=(RESHAPED,)))<br/>model.add(Activation('relu'))<br/>model.add(Dropout(DROPOUT))<br/>model.add(Dense(N_HIDDEN))<br/>model.add(Activation('relu'))<br/>model.add(Dropout(DROPOUT))<br/>model.add(Dense(NB_CLASSES))<br/>model.add(Activation('softmax'))<br/>model.summary()<br/>model.compile(loss='categorical_crossentropy',<br/>optimizer=OPTIMIZER,<br/>metrics=['accuracy'])<br/>history = model.fit(X_train, Y_train,<br/>batch_size=BATCH_SIZE, epochs=NB_EPOCH,<br/>verbose=VERBOSE, validation_split=VALIDATION_SPLIT)<br/>score = model.evaluate(X_test, Y_test, verbose=VERBOSE)<br/>print("Test score:", score[0])<br/>print('Test accuracy:', score[1])
</pre>
<p>Let's run the code for 20 iterations as previously done, and we will see that this net achieves an accuracy of 91.54% on the training, 94.48% on validation, and 94.25% on the test:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B06258_01_14.png"/></div>
<p>Note that training accuracy should still be above the test accuracy, otherwise we are not training long enough. So let's try to increase significantly the number of epochs up to 250, and we get 98.1% accuracy on training, 97.73% on validation, and 97.7% on the test:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B06258_01_15.png"/></div>
<p>It is useful to observe how accuracy increases on training and test sets when the number of epochs increases. As you can see in the following graph, these two curves touch at about 250 epochs, and therefore, there is no need to train further after that point:</p>
<table class="a">
<tbody>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="191" src="assets/B06258_01_16.png" width="307"/></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="191" src="assets/B06258_01_17.png" width="307"/></div>
</td>
</tr>
</tbody>
</table>
<p>Note that it has been frequently observed that networks with random dropout in internal hidden layers can generalize better on unseen examples contained in test sets. Intuitively, one can think of this as each neuron becoming more capable because it knows it cannot depend on its neighbors. During testing, there is no dropout, so we are now using all our highly tuned neurons. In short, it is generally a good approach to test how a net performs when some dropout function is adopted.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Testing different optimizers in Keras</h1>
            </header>

            <article>
                
<p>We have defined and used a network; it is useful to start giving an intuition about how networks are trained. Let's focus on one popular training technique known as <strong>gradient descent</strong> (<strong>GD</strong>). Imagine a generic cost function <em>C(w)</em> in one single variable <em>w</em> like in the following graph:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="266" src="assets/B06258_01_18.png" width="260"/></div>
<p>The gradient descent can be seen as a hiker who aims at climbing down a mountain into a valley. The mountain represents the function <em>C</em>, while the valley represents the minimum <em>C<sub>min</sub></em>. The hiker has a starting point <em>w<sub>0</sub></em>. The hiker moves little by little. At each step <em>r</em>, the gradient is the direction of maximum increase. Mathematically, this direction is the value of the partial derivative <img height="32" src="assets/image_01_062.jpg" width="20"/> evaluated at point <em>w<sub>r</sub></em> reached at step <em>r</em>. Therefore by taking the opposite direction, <img height="31" src="assets/image_01_064.jpg" width="50"/>, the hiker can move towards the valley. At each step, the hiker can decide what the leg length is before the next step. This is the <em>learning rate</em> <img height="18" src="assets/image_01_065.jpg" width="31"/> in gradient descent jargon. Note that if <img height="13" src="assets/image_01_066.jpg" width="10"/> is too small, then the hiker will move slowly. However, if <img height="13" src="assets/image_01_066.jpg" width="10"/> is too high, then the hiker will possibly miss the valley.</p>
<p>Now you should remember that a sigmoid is a continuous function, and it is possible to compute the derivative. It can be proven that the sigmoid is shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="38" src="assets/image_01_068.png" width="115"/></div>
<p>It has the following derivative:</p>
<div class="CDPAlignCenter CDPAlign"> <img height="44" src="assets/image_01_069.png" width="171"/> </div>
<p>ReLU is not differentiable in <em>0</em>. We can, however, extend the first derivative in <em>0</em> to a function over the whole domain by choosing it to be either <em>0</em> or <em>1</em>. The point-wise derivative of ReLU <img height="14" src="assets/image_01_070.png" width="71"/> is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="49" src="assets/B06258_01_070.png" width="130"/></div>
<p>Once we have the derivative, it is possible to optimize the nets with a gradient descent technique. Keras uses its backend (either TensorFlow or Theano) for computing the derivative on our behalf so we don't need to worry about implementing or computing it. We just choose the activation function, and Keras computes its derivative on our behalf.</p>
<p>A neural network is essentially a composition of multiple functions with thousands, and sometimes millions, of parameters. Each network layer computes a function whose error should be minimized in order to improve the accuracy observed during the learning phase. When we discuss backpropagation, we will discover that the minimization game is a bit more complex than our toy example. However, it is still based on the same intuition of descending a valley.</p>
<p>Keras implements a fast variant of gradient descent known as <strong>stochastic gradient descent</strong> (<strong>SGD</strong>) and two more advanced optimization techniques known as <strong>RMSprop</strong> and <strong>Adam</strong>. RMSprop and Adam include the concept of momentum (a velocity component) in addition to the acceleration component that SGD has. This allows faster convergence at the cost of more computation. A full list of Keras-supported optimizers is at <a href="https://keras.io/optimizers/" target="_blank">https://keras.io/optimizers/</a>. SGD was our default choice so far. So now let's try the other two. It is very simple, we just need to change few lines:</p>
<pre>
from keras.optimizers import RMSprop, Adam<br/>...<br/>OPTIMIZER = RMSprop() # optimizer,
</pre>
<p>That's it. Let's test it as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="643" src="assets/B06258_01_19.png" width="525"/></div>
<p>As you can see in the preceding screenshot, RMSprop is faster than SDG since we are able to achieve an accuracy of 97.97% on training, 97.59% on validation, and 97.84% on the test improving SDG with only 20 iterations. For the sake of completeness, let's see how the accuracy and loss change with the number of epochs, as shown in the following graphs:</p>
<table class="a0">
<tbody>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="191" src="assets/B06258_01_20.png" width="307"/></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="191" src="assets/B06258_01_21.png" width="307"/></div>
</td>
</tr>
</tbody>
</table>
<p><br/>
<br/>
OK, let's try the other optimizer, <kbd>Adam()</kbd>. It is pretty simple, as follows:</p>
<pre>
OPTIMIZER = Adam() # optimizer
</pre>
<p>As we have seen, Adam is slightly better. With Adam, we achieve 98.28% accuracy on training, 98.03% on validation, and 97.93% on the test with 20 iterations, as shown in the following graphs:</p>
<table class="a1">
<tbody>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="191" src="assets/B06258_01_22.png" width="307"/></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="191" src="assets/B06258_01_23.png" width="307"/></div>
</td>
</tr>
</tbody>
</table>
<br/>
<p>This is our fifth variant, and remember that our initial baseline was at 92.36%.</p>
<p>So far, we made progressive improvements; however, the gains are now more and more difficult. Note that we are optimizing with a dropout of 30%. For the sake of completeness, it could be useful to report the accuracy on the test only for other dropout values with <kbd>Adam()</kbd> chosen as optimizer, as shown in the following graph:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="327" src="assets/B06258_01_24.png" width="530"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Increasing the number of epochs</h1>
            </header>

            <article>
                
<p>Let's make another attempt and increase the number of epochs used for training from 20 to 200. Unfortunately, this choice increases our computation time by 10, but it gives us no gain. The experiment is unsuccessful, but we have learned that if we spend more time learning, we will not necessarily improve. Learning is more about adopting smart techniques and not necessarily about the time spent in computations. Let's keep track of our sixth variant in the following graph:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="221" src="assets/B06258_01_25.png" width="539"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Controlling the optimizer learning rate</h1>
            </header>

            <article>
                
<p>There is another attempt we can make, which is changing the learning parameter for our optimizer. As you can see in the following graph, the optimal value is somewhere close to <em>0.001</em>, which is the default learning rate for the optimer. Good! Adam works well out of the box:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="295" src="assets/B06258_01_26.png" width="477"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Increasing the number of internal hidden neurons</h1>
            </header>

            <article>
                
<p>We can make yet another attempt, that is, changing the number of internal hidden neurons. We report the results of the experiments with an increasing number of hidden neurons. We can see in the following graph that by increasing the complexity of the model, the run time increases significantly because there are more and more parameters to optimize. However, the gains that we are getting by increasing the size of the network decrease more and more as the network grows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="236" src="assets/B06258_01_27.png" width="684"/></div>
<p class="CDPAlignLeft CDPAlign">In the following graph, we show the time needed for each iteration as the number of hidden neurons grow:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="290" src="assets/B06258_01_28.png" width="469"/></div>
<p>The following graph shows the accuracy as the number of hidden neurons grow:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="293" src="assets/B06258_01_29.png" width="474"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Increasing the size of batch computation</h1>
            </header>

            <article>
                
<p>Gradient descent tries to minimize the cost function on all the examples provided in the training sets and, at the same time, for all the features provided in the input. Stochastic gradient descent is a much less expensive variant, which considers only <kbd>BATCH_SIZE</kbd> examples. So, let's see what the behavior is by changing this parameter. As you can see, the optimal accuracy value is reached for <kbd>BATCH_SIZE=128</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="179" src="assets/B06258_01_30.png" width="493"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summarizing the experiments run for recognizing handwritten charts</h1>
            </header>

            <article>
                
<p>So, let's summarize: with five different variants, we were able to improve our performance from 92.36% to 97.93%. First, we defined a simple layer network in Keras. Then, we improved the performance by adding some hidden layers. After that, we improved the performance on the test set by adding a few random dropouts to our network and by experimenting with different types of optimizers. Current results are summarized in the following table:</p>
<table class="a2">
<tbody>
<tr>
<td><strong>Model/Accuracy</strong></td>
<td><strong>Training</strong></td>
<td><strong>Validation</strong></td>
<td><strong>Test</strong></td>
</tr>
<tr>
<td><strong>Simple</strong></td>
<td>92.36%</td>
<td>92.37%</td>
<td>92.22%</td>
</tr>
<tr>
<td><strong>Two hidden (128)</strong></td>
<td>94.50%</td>
<td>94.63%</td>
<td>94.41%</td>
</tr>
<tr>
<td><strong>Dropout (30%)</strong></td>
<td>98.10%</td>
<td>97.73%</td>
<td>97.7% (200 epochs)</td>
</tr>
<tr>
<td><strong>RMSprop</strong></td>
<td>97.97%</td>
<td>97.59%</td>
<td>97.84% (20 epochs)</td>
</tr>
<tr>
<td><strong>Adam</strong></td>
<td>98.28%</td>
<td>98.03%</td>
<td>97.93% (20 epochs)</td>
</tr>
</tbody>
</table>
<p>However, the next two experiments did not provide significant improvements. Increasing the number of internal neurons creates more complex models and requires more expensive computations, but it provides only marginal gains. We get the same experience if we increase the number of training epochs. A final experiment consisted in changing the <kbd>BATCH_SIZE</kbd> for our optimizer.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Adopting regularization for avoiding overfitting</h1>
            </header>

            <article>
                
<p>Intuitively, a good machine learning model should achieve low error on training data. Mathematically, this is equivalent to minimizing the loss function on the training data given the machine learning model built. This is expressed by the following formula.:</p>
<div class="CDPAlignCenter CDPAlign"><img height="17" src="assets/image_01_084.png" width="250"/></div>
<p>However, this might not be enough. A model can become excessively complex in order to capture all the relations inherently expressed by the training data. This increase of complexity might have two negative consequences. First, a complex model might require a significant amount of time to be executed. Second, a complex model can achieve very good performance on training data—because all the inherent relations in trained data are memorized, but not so good performance on validation data—as the model is not able to generalize on fresh unseen data. Again, learning is more about generalization than memorization. The following graph represents a typical loss function decreasing on both validation and training sets. However, a certain point the loss on validation starts to increase because of overfitting:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="253" src="assets/B06258_01_31.png" width="282"/></div>
<p>As a rule of thumb, if during the training we see that the loss increases on validation, after an initial decrease, then we have a problem of model complexity that overfits training. Indeed, overfitting is the word used in machine learning for concisely describing this phenomenon.</p>
<p>In order to solve the overfitting problem, we need a way to capture the complexity of a model, that is, how complex a model can be. What could be the solution? Well, a model is nothing more than a vector of weights. Therefore the complexity of a model can be conveniently represented as the number of nonzero weights. In other words, if we have two models, <em>M1</em> and <em>M2</em>, achieving pretty much the same performance in terms of loss function, then we should choose the simplest model that has the minimum number of nonzero weights. We can use a hyperparameter <em>⅄&gt;=0</em> for controlling what the importance of having a simple model is, as in this formula:</p>
<div class="CDPAlignCenter CDPAlign"><img height="16" src="assets/image_01_086.png" width="396"/></div>
<p>There are three different types of regularizations used in machine learning:</p>
<ul>
<li><strong>L1 regularization</strong> (also known as <strong>lasso</strong>): The complexity of the model is expressed as the sum of the absolute values of the weights</li>
<li><strong>L2 regularization</strong> (also known as <strong>ridge</strong>): The complexity of the model is expressed as the sum of the squares of the weights</li>
<li><strong>Elastic net regularization</strong>: The complexity of the model is captured by a combination of the two preceding techniques</li>
</ul>
<p>Note that the same idea of regularization can be applied independently to the weights, to the model, and to the activation.</p>
<p>Therefore, playing with regularization can be a good way to increase the performance of a network, in particular when there is an evident situation of overfitting. This set of experiments is left as an exercise for the interested reader.</p>
<p>Note that Keras supports both l1, l2, and elastic net regularizations. Adding regularization is easy; for instance, here we have a <kbd>l2</kbd> regularizer for kernel (the weight <em>W</em>):</p>
<pre>
<span class="hljs-keyword">from</span><span> keras </span><span class="hljs-keyword">import</span><span> regularizers model.add(Dense(</span><span class="hljs-number">64</span><span>, input_dim=</span><span class="hljs-number">64</span><span>, kernel_regularizer=regularizers.l2(</span><span class="hljs-number">0.01</span><span>)</span><span>))</span>
</pre>
<p>A full description of the available parameters is available at: <a href="https://keras.io/regularizers/" target="_blank">https://keras.io/regularizers/</a>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Hyperparameters tuning</h1>
            </header>

            <article>
                
<p>The preceding experiments gave a sense of what the opportunities for fine-tuning a net are. However, what is working for this example is not necessarily working for other examples. For a given net, there are indeed multiple parameters that can be optimized (such as the number of <kbd>hidden neurons</kbd>, <kbd>BATCH_SIZE</kbd>, number of <kbd>epochs</kbd>, and many more according to the complexity of the net itself).</p>
<p>Hyperparameter tuning is the process of finding the optimal combination of those parameters that minimize cost functions. The key idea is that if we have <em>n</em> parameters, then we can imagine that they define a space with <em>n</em> dimensions, and the goal is to find the point in this space which corresponds to an optimal value for the cost function. One way to achieve this goal is to create a grid in this space and systematically check for each grid vertex what the value assumed by the cost function is. In other words, the parameters are divided into buckets, and different combinations of values are checked via a brute force approach.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Predicting output</h1>
            </header>

            <article>
                
<p>When a net is trained, it can be course be used for predictions. In Keras, this is very simple. We can use the following method:</p>
<pre>
# calculate predictions<br/>predictions = model.predict(X)
</pre>
<p>For a given input, several types of output can be computed, including a method:</p>
<ul>
<li><kbd>model.evaluate()</kbd>: This is used to compute the loss values</li>
<li><kbd>model.predict_classes()</kbd>: This is used to compute category outputs</li>
<li><kbd>model.predict_proba()</kbd>: This is used to compute class probabilities</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">A practical overview of backpropagation</h1>
            </header>

            <article>
                
<p>Multilayer perceptrons learn from training data through a process called backpropagation. The process can be described as a way of progressively correcting mistakes as soon as they are detected. Let's see how this works.</p>
<p>Remember that each neural network layer has an associated set of weights that determines the output values for a given set of inputs. In addition to that, remember that a neural network can have multiple hidden layers.</p>
<p>In the beginning, all the weights have some random assignment. Then the net is activated for each input in the training set: values are propagated <em>forward</em> from the input stage through the hidden stages to the output stage where a prediction is made (note that we have kept the following diagram simple by only representing a few values with green dotted lines, but in reality, all the values are propagated forward through the network):</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="184" src="assets/B06258_01_32.png" width="241"/></div>
<p>Since we know the true observed value in the training set, it is possible to calculate the error made in prediction. The key intuition for backtracking is to propagate the error back and use an appropriate optimizer algorithm, such as a gradient descent, to adjust the neural network weights with the goal of reducing the error (again for the sake of simplicity, only a few error values are represented):</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="193" src="assets/B06258_01_33.png" width="253"/></div>
<p>The process of forward propagation from input to output and backward propagation of errors is repeated several times until the error gets below a predefined threshold. The whole process is represented in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="201" src="assets/B06258_01_34.png" width="475"/></div>
<p>The features represent the input and the labels are here used to drive the learning process. The model is updated in such a way that the loss function is progressively minimized. In a neural network, what really matters is not the output of a single neuron but the collective weights adjusted in each layer. Therefore, the network progressively adjusts its internal weights in such a way that the prediction increases the number of labels correctly forecasted. Of course, using the right set features and having a quality labeled data is fundamental to minimizing the bias during the learning process.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Towards a deep learning approach</h1>
            </header>

            <article>
                
<p>While playing with handwritten digit recognition, we came to the conclusion that the closer we get to the accuracy of 99%, the more difficult it is to improve. If we want to have more improvements, we definitely need a new idea. What are we missing? Think about it.</p>
<p>The fundamental intuition is that, so far, we lost all the information related to the local spatiality of the images. In particular, this piece of code transforms the bitmap, representing each written digit into a flat vector where the spatial locality is gone:</p>
<pre>
#X_train is 60000 rows of 28x28 values --&gt; reshaped in 60000 x 784<br/>X_train = X_train.reshape(60000, 784)<br/>X_test = X_test.reshape(10000, 784)
</pre>
<p>However, this is not how our brain works. Remember that our vision is based on multiple cortex levels, each one recognizing more and more structured information, still preserving the locality. First we see single pixels, then from that, we recognize simple geometric forms and then more and more sophisticated elements such as objects, faces, human bodies, animals and so on.</p>
<p>In <a href="4be2a04a-4545-4051-bcd9-32764d21f0f2.xhtml" target="_blank">Chapter 3</a>, <em>Deep Learning with ConvNets</em>, we will see that a particular type of deep learning network known as <strong>convolutional neural network</strong> (<strong>CNN</strong>) has been developed by taking into account both the idea of preserving the spatial locality in images (and, more generally, in any type of information) and the idea of learning via progressive levels of abstraction: with one layer, you can only learn simple patterns; with more than one layer, you can learn multiple patterns. Before discussing CNN, we need to discuss some aspects of Keras architecture and have a practical introduction to a few additional machine learning concepts. This will be the topic of the next chapters.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, you learned the basics of neural networks, more specifically, what a perceptron is, what a multilayer perceptron is, how to define neural networks in Keras, how to progressively improve metrics once a good baseline is established, and how to fine-tune the hyperparameter's space. In addition to that, you now also have an intuitive idea of what some useful activation functions (sigmoid and ReLU) are, and how to train a network with backpropagation algorithms based on either gradient descent, on stochastic gradient descent, or on more sophisticated approaches, such as Adam and RMSprop.</p>
<p>In the next chapter, we will see how to install Keras on AWS, Microsoft Azure, Google Cloud, and on your own machine. In addition to that, we will provide an overview of Keras APIs.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>