<html><head></head><body>
  <div id="_idContainer093">
   <h1 class="chapter-number" id="_idParaDest-14">
    <a id="_idTextAnchor014">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     1
    </span>
   </h1>
   <h1 id="_idParaDest-15">
    <a id="_idTextAnchor015">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Introduction to Graph Learning
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     Graph data is a powerful and intuitive way of expressing information, and several practical scenarios can be better expressed using graph data than tabular approaches.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     Analyzing graph data has been a topic of study for decades, but it has only recently begun to capture the limelight due to advances in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      compute capabilities.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     In this book, we aim to introduce you to the world of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.6.1">
      graphs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.7.1">
     .
    </span>
    <span class="koboSpan" id="kobo.7.2">
     Here, we’ll begin by discussing what graph data is and the fundamental mathematical terminologies surrounding graphs.
    </span>
    <span class="koboSpan" id="kobo.7.3">
     Next, we’ll take a small detour and discuss some common graph algorithms and their applications in graph data analytics.
    </span>
    <span class="koboSpan" id="kobo.7.4">
     We’ll extend our discussion on graph data analytics to the requirement of graph deep learning and why it stands as a specialized subdomain compared to applying
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      existing architectures.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     In this chapter, we’ll cover the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      following topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      Do we
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       need graphs?
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.13.1">
       Formalizing graphs
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.14.1">
      Types and properties
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.15.1">
       of graphs
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.16.1">
      Graph
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       data structures
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.18.1">
      Traditional
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.19.1">
       graph-based solutions
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.20.1">
      The need for
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.21.1">
        representation learning
       </span>
      </strong>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.22.1">
       Graph neural networks
      </span>
     </strong>
     <span class="koboSpan" id="kobo.23.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.24.1">
       GNNs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.25.1">
      ) and the need for a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.26.1">
       separate vertical
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-16">
    <a id="_idTextAnchor016">
    </a>
    <span class="koboSpan" id="kobo.27.1">
     Do we need graphs?
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     The recent
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.29.1">
      artificial intelligence
     </span>
    </strong>
    <span class="koboSpan" id="kobo.30.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.31.1">
      AI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.32.1">
     ) revolution is
    </span>
    <a id="_idIndexMarker000">
    </a>
    <span class="koboSpan" id="kobo.33.1">
     the tip of the iceberg of a
    </span>
    <a id="_idIndexMarker001">
    </a>
    <span class="koboSpan" id="kobo.34.1">
     megatrend that has been impacting the computing industry for decades now.
    </span>
    <span class="koboSpan" id="kobo.34.2">
     Over time, computing performance has increased exponentially against power consumed and cost; information storage costs have also decreased exponentially.
    </span>
    <span class="koboSpan" id="kobo.34.3">
     To put this into perspective, while a terabyte of data can be stored in a disk costing around 100 US dollars in 2024, it would have taken more than a million dollars in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.35.1">
      early 1990s!
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     Using computers and their derivative products, such as software, web applications, games, and multimedia content, has become deeply tied to our normal lifestyle.
    </span>
    <span class="koboSpan" id="kobo.36.2">
     This dependence led to the need for understanding the behavior of all the interacting entities: humans, computer hardware, software such as web applications, and even organizations as a whole.
    </span>
    <span class="koboSpan" id="kobo.36.3">
     The end goal was to find ways to make interactions more efficient, which could lead to unprecedented
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      business opportunities.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.38.1">
     Initially, given the constraints of the time, the information that was collected was less organized and the recorded truth provided a very high-level overview of systems, and only about a handful of variables within the system (for data scientists, think of data at aggregated levels, and with a small number of dimensions).
    </span>
    <span class="koboSpan" id="kobo.38.2">
     At some point, someone realized computing power and data storage were cheap enough that you could record facts more granularly: not only could individual scenarios be recorded separately and more frequently, but other variables could also be recorded every time a snapshot was taken.
    </span>
    <span class="koboSpan" id="kobo.38.3">
     The data revolution had begun, and stakeholders realized that by capturing and reviewing enough data about these interacting entities, a holistic picture of their behavior in the ecosystem could be drawn.
    </span>
    <span class="koboSpan" id="kobo.38.4">
     The 2010s were spent commoditizing data and its products, to the point that even Series A-funded startups have adopted a data solution: be it warehousing, Elasticsearch, or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      recommendation engines.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     Taking a step back, let’s understand what data means.
    </span>
    <span class="koboSpan" id="kobo.40.2">
     A data point is essentially just a factual statement.
    </span>
    <span class="koboSpan" id="kobo.40.3">
     Very little discussion exists
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.41.1">
      on how the fact is represented in the data
     </span>
    </em>
    <span class="koboSpan" id="kobo.42.1">
     .
    </span>
    <span class="koboSpan" id="kobo.42.2">
     The de facto representation of data is tabular, and this has generally worked well for the capabilities built around the current data ecosystem.
    </span>
    <span class="koboSpan" id="kobo.42.3">
     The focus on data science research and engineering has revolved around existing database architectures, which is why the tabular form of representation is the most widespread.
    </span>
    <span class="koboSpan" id="kobo.42.4">
     However, the tabular form need isn’t the only form of representation.
    </span>
    <span class="koboSpan" id="kobo.42.5">
     The purpose of this chapter is to build a case around the graph form of representation and why graph representations can be the best option for several
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.43.1">
      practical scenarios.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.44.1">
     Graph data is represented
    </span>
    <a id="_idIndexMarker002">
    </a>
    <span class="koboSpan" id="kobo.45.1">
     using
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.46.1">
      nodes
     </span>
    </strong>
    <span class="koboSpan" id="kobo.47.1">
     (also called objects, vertices, or nouns) and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.48.1">
      edges
     </span>
    </strong>
    <span class="koboSpan" id="kobo.49.1">
     (also
    </span>
    <a id="_idIndexMarker003">
    </a>
    <span class="koboSpan" id="kobo.50.1">
     called relationships, links, or verbs).
    </span>
    <span class="koboSpan" id="kobo.50.2">
     Certain real-life scenarios necessitate emphasizing the relationships between the objects rather than just treating each object as an independent entity.
    </span>
    <span class="koboSpan" id="kobo.50.3">
     Graph data structures provide us with a natural way to express these scenarios, as opposed to something such as the tabular format.
    </span>
    <span class="koboSpan" id="kobo.50.4">
     Using the simple construct of treating entities as nodes and relationships as edges between two nodes, graph representations can effectively model information from a wide range of domains: from network
    </span>
    <a id="_idIndexMarker004">
    </a>
    <span class="koboSpan" id="kobo.51.1">
     topology to biological systems and supply chains to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.52.1">
      molecular structure.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-17">
    <a id="_idTextAnchor017">
    </a>
    <span class="koboSpan" id="kobo.53.1">
     A case study
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.54.1">
     To make this point
    </span>
    <a id="_idIndexMarker005">
    </a>
    <span class="koboSpan" id="kobo.55.1">
     clearer, let’s consider a common question that arises in social networks.
    </span>
    <span class="koboSpan" id="kobo.55.2">
     For a user (say John), we want to ascertain whether another user (say Mary) is a second-degree connection (to John).
    </span>
    <span class="koboSpan" id="kobo.55.3">
     A second-degree connection simply means Mary and John have a common connection, but Mary isn’t directly connected (is friends with) to John.
    </span>
    <span class="koboSpan" id="kobo.55.4">
     The social media platform commonly tracks this piece of information between a pair of users and determines whether they should be recommended by the platform to connect.
    </span>
    <span class="koboSpan" id="kobo.55.5">
     We’ll tackle this problem from two perspectives: first using the tabular representation, and then using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.56.1">
      graph representa
     </span>
     <a id="_idTextAnchor018">
     </a>
     <a id="_idTextAnchor019">
     </a>
     <span class="koboSpan" id="kobo.57.1">
      tion.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.58.1">
     Tabular representation
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.59.1">
     First, we need to
    </span>
    <a id="_idIndexMarker006">
    </a>
    <span class="koboSpan" id="kobo.60.1">
     understand what the schema of the tables
    </span>
    <a id="_idIndexMarker007">
    </a>
    <span class="koboSpan" id="kobo.61.1">
     in the database would be.
    </span>
    <span class="koboSpan" id="kobo.61.2">
     In a typical social media platform database, there would be several tables – one for users (capturing demographic information such as age, location, date of joining, and so on), one for posts (containing details about a post made, such as the user who made the post, the contents of the post, the date of making the post, the visibility level, and so on), and many more.
    </span>
    <span class="koboSpan" id="kobo.61.3">
     The table of concern for us would be something called
    </span>
    <a id="_idIndexMarker008">
    </a>
    <span class="koboSpan" id="kobo.62.1">
     the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.63.1">
      connections table
     </span>
    </strong>
    <span class="koboSpan" id="kobo.64.1">
     .
    </span>
    <span class="koboSpan" id="kobo.64.2">
     It should capture information about which users are connected directly (that is, they have a first-degree connection).
    </span>
    <span class="koboSpan" id="kobo.64.3">
     The schema should go somewhat
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.65.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.66.1">
connections(
    conn_id: UUID,
    user_id_1: UUID FOREIGN KEY,
    user_id_2: UUID FOREIGN KEY,
    date_of_conn: TIMESTAMP,
    status_of_conn: TEXT
)</span></pre>
   <p>
    <em class="italic">
     <span class="koboSpan" id="kobo.67.1">
      Table 1.1
     </span>
    </em>
    <span class="koboSpan" id="kobo.68.1">
     shows a
    </span>
    <a id="_idIndexMarker009">
    </a>
    <span class="koboSpan" id="kobo.69.1">
     table that contains a few
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.70.1">
      data
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker010">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.71.1">
      points:
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-1">
    <colgroup>
     <col/>
     <col/>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.72.1">
           conn_id
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.73.1">
           user_id_1
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.74.1">
           user_id_2
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.75.1">
           date_of_conn
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.76.1">
           status_of_conn
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.77.1">
          conn_uuid_0
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.78.1">
          john_uuid
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.79.1">
          alex_uuid
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.80.1">
          2022-10-30
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.81.1">
          active
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.82.1">
          conn_uuid_1
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.83.1">
          alex_uuid
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.84.1">
          greg_uuid
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.85.1">
          2023-03-12
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.86.1">
          active
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.87.1">
          conn_uuid_2
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.88.1">
          greg_uuid
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.89.1">
          mary_uuid
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.90.1">
          2023-04-11
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.91.1">
          active
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.92.1">
          conn_uuid_3
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.93.1">
          mary_uuid
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.94.1">
          alex_uuid
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.95.1">
          2023-06-09
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.96.1">
          active
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.97.1">
     Table 1.1 – Example data stored in tabular format
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.98.1">
     To determine whether John and Mary have a second-degree connection, a SQL query similar to the following can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.99.1">
      be executed:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer016">
     <span class="koboSpan" id="kobo.100.1">
      <img alt="Figure 1.1 – A SQL query being performed over tables that were introduced previously to retrieve second-degree connections" src="image/B22118_01_1.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.101.1">
     Figure 1.1 – A SQL query being performed over tables that were introduced previously to retrieve second-degree connections
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.102.1">
     The crux of this
    </span>
    <a id="_idIndexMarker011">
    </a>
    <span class="koboSpan" id="kobo.103.1">
     query
    </span>
    <a id="_idIndexMarker012">
    </a>
    <span class="koboSpan" id="kobo.104.1">
     contains a recursive self-join operation, where each recursion level contains the connections of a certain degree.
    </span>
    <span class="koboSpan" id="kobo.104.2">
     The initial filter of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.105.1">
      user_id_1 =
     </span>
    </strong>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.106.1">
      'john_uuid'
     </span>
    </strong>
    <span class="koboSpan" id="kobo.107.1">
     OR
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.108.1">
      user_id_2 = 'john_uuid'
     </span>
    </strong>
    <span class="koboSpan" id="kobo.109.1">
     ensures that we only concern ourselves with users who are on some level and connected to John.
    </span>
    <span class="koboSpan" id="kobo.109.2">
     Finally, by filtering by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.110.1">
      degree = 2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.111.1">
     , we can get the list of all users who have a second-degree connection
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.112.1">
      to John.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     How efficient is this approach?
    </span>
    <span class="koboSpan" id="kobo.113.2">
     The worst-case time complexity can be evaluated asymptotically and expressed in
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.114.1">
      Big-O notation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.115.1">
     .
    </span>
    <span class="koboSpan" id="kobo.115.2">
     Let
    </span>
    <span class="koboSpan" id="kobo.116.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/1.png" style="vertical-align:-0.010em;height:0.658em;width:0.672em"/>
    </span>
    <span class="koboSpan" id="kobo.117.1">
     be the count of users present on the social media platform and
    </span>
    <span class="koboSpan" id="kobo.118.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/2.png" style="vertical-align:-0.000em;height:0.648em;width:0.557em"/>
    </span>
    <span class="koboSpan" id="kobo.119.1">
     be the count of all first-degree connections (or the number of entries in the connections table).
    </span>
    <span class="koboSpan" id="kobo.119.2">
     Join algorithms have evolved, and current join operations are very efficient, but if we look at the naive approach, where two tables have lengths
    </span>
    <span class="koboSpan" id="kobo.120.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;L&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/3.png" style="vertical-align:-0.000em;height:0.648em;width:0.566em"/>
    </span>
    <span class="koboSpan" id="kobo.121.1">
     and
    </span>
    <span class="koboSpan" id="kobo.122.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;R&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/4.png" style="vertical-align:-0.008em;height:0.656em;width:0.635em"/>
    </span>
    <span class="koboSpan" id="kobo.123.1">
     , a join operation would have an
    </span>
    <span class="koboSpan" id="kobo.124.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;L&lt;/mml:mi&gt;&lt;mml:mi&gt;*&lt;/mml:mi&gt;&lt;mml:mi&gt;R&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/5.png" style="vertical-align:-0.157em;height:0.821em;width:3.405em"/>
    </span>
    <span class="koboSpan" id="kobo.125.1">
     time complexity.
    </span>
    <span class="koboSpan" id="kobo.125.2">
     Applying this logic
    </span>
    <a id="_idIndexMarker013">
    </a>
    <span class="koboSpan" id="kobo.126.1">
     to the preceding recursion, we’ll see
    </span>
    <a id="_idIndexMarker014">
    </a>
    <span class="koboSpan" id="kobo.127.1">
     that the time complexity of the entire query is
    </span>
    <span class="koboSpan" id="kobo.128.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;mml:mi&gt;*&lt;/mml:mi&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/6.png" style="vertical-align:-0.157em;height:0.821em;width:3.171em"/>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      or
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.130.1">
      <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/7.png" style="vertical-align:-0.195em;height:0.897em;width:2.421em"/>
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.131.1">
      .
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.132.1">
     Graph representation
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.133.1">
     Now, let’s look at the
    </span>
    <a id="_idIndexMarker015">
    </a>
    <span class="koboSpan" id="kobo.134.1">
     graph representation for the same problem.
    </span>
    <span class="koboSpan" id="kobo.134.2">
     Let each node of the graph represent a user and each edge connecting two nodes represent a first-degree connection between the users that the connected nodes represent.
    </span>
    <span class="koboSpan" id="kobo.134.3">
     An illustration using
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.135.1">
      Table 1.1
     </span>
    </em>
    <span class="koboSpan" id="kobo.136.1">
     would look
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.137.1">
      like this:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer024">
     <span class="koboSpan" id="kobo.138.1">
      <img alt="Figure 1.2 – Representing data from Table 1.1 in a graph" src="image/B22118_01_2.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.139.1">
     Figure 1.2 – Representing data from Table 1.1 in a graph
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.140.1">
     How do we find the answer to whether John and Mary have a second-degree connection here?
    </span>
    <span class="koboSpan" id="kobo.140.2">
     We can employ an intuitive algorithm over
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      this graph:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.142.1">
       Start from a source
      </span>
     </strong>
     <span class="koboSpan" id="kobo.143.1">
      : Begin at a chosen starting point, often called
     </span>
     <a id="_idIndexMarker016">
     </a>
     <span class="koboSpan" id="kobo.144.1">
      the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.145.1">
       source
      </span>
     </em>
     <span class="koboSpan" id="kobo.146.1">
      or
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.147.1">
       initial node
      </span>
     </strong>
     <span class="koboSpan" id="kobo.148.1">
      of the
     </span>
     <a id="_idIndexMarker017">
     </a>
     <span class="koboSpan" id="kobo.149.1">
      graph.
     </span>
     <span class="koboSpan" id="kobo.149.2">
      This is your current position for exploration.
     </span>
     <span class="koboSpan" id="kobo.149.3">
      For our use case, the initial node would be that
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.150.1">
       of John.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.151.1">
       Explore neighbors level by level
      </span>
     </strong>
     <span class="koboSpan" id="kobo.152.1">
      : Visit all the neighbors of the current node before moving on to their neighbors.
     </span>
     <span class="koboSpan" id="kobo.152.2">
      Imagine exploring the graph in layers, moving outward one level at a time.
     </span>
     <span class="koboSpan" id="kobo.152.3">
      This ensures that you discover all nodes at a certain distance before moving
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.153.1">
       farther away.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.154.1">
       Mark visited nodes
      </span>
     </strong>
     <span class="koboSpan" id="kobo.155.1">
      : As you visit each node, mark it as visited to avoid revisiting the same node.
     </span>
     <span class="koboSpan" id="kobo.155.2">
      Use a queue to keep track of the order in which you encounter nodes.
     </span>
     <span class="koboSpan" id="kobo.155.3">
      While marking the nodes, you can also keep track of how many jumps from the initial node were made to reach this node.
     </span>
     <span class="koboSpan" id="kobo.155.4">
      Continue this process until you’ve visited all reachable nodes from the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.156.1">
       starting point.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.157.1">
     In simpler terms, this
    </span>
    <a id="_idIndexMarker018">
    </a>
    <span class="koboSpan" id="kobo.158.1">
     algorithm explores the graph by gradually moving away from the starting point, checking neighboring nodes level by level, and keeping track of visited nodes to avoid duplication.
    </span>
    <span class="koboSpan" id="kobo.158.2">
     It’s like ripples spreading out from a pebble dropped in a pond, exploring nearby areas before moving to more distant ones.
    </span>
    <span class="koboSpan" id="kobo.158.3">
     This algorithm
    </span>
    <a id="_idIndexMarker019">
    </a>
    <span class="koboSpan" id="kobo.159.1">
     is called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.160.1">
      breadth-first search
     </span>
    </strong>
    <span class="koboSpan" id="kobo.161.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.162.1">
      BFS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     ), and it’s one of the most popular
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.164.1">
      graph algorithms:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer025">
     <span class="koboSpan" id="kobo.165.1">
      <img alt="Figure 1.3 – Running BFS on the graph" src="image/B22118_01_3.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.166.1">
     Figure 1.3 – Running BFS on the graph
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.167.1">
     By using this algorithm, if Mary’s node is marked as visited and has a jump count of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.168.1">
      2
     </span>
    </em>
    <span class="koboSpan" id="kobo.169.1">
     , then we can safely say that John and Mary have a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.170.1">
      second-degree connection.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.171.1">
     What’s the time
    </span>
    <a id="_idIndexMarker020">
    </a>
    <span class="koboSpan" id="kobo.172.1">
     complexity of BFS?
    </span>
    <span class="koboSpan" id="kobo.172.2">
     As mentioned previously, the number of users is assumed to be
    </span>
    <span class="koboSpan" id="kobo.173.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/1.png" style="vertical-align:-0.010em;height:0.658em;width:0.674em"/>
    </span>
    <span class="koboSpan" id="kobo.174.1">
     , and the number of first-degree connections is
    </span>
    <span class="koboSpan" id="kobo.175.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/2.png" style="vertical-align:-0.000em;height:0.648em;width:0.558em"/>
    </span>
    <span class="koboSpan" id="kobo.176.1">
     .
    </span>
    <span class="koboSpan" id="kobo.176.2">
     Effectively, BFS touches all vertices and edges of the graph at most once, so the time complexity is simply
    </span>
    <span class="koboSpan" id="kobo.177.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/10.png" style="vertical-align:-0.156em;height:0.820em;width:3.631em"/>
    </span>
    <span class="koboSpan" id="kobo.178.1">
     .
    </span>
    <span class="koboSpan" id="kobo.178.2">
     In a practical scenario, the number of connections far outweighs the number of users on the platform, so the time complexity can be approximated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.179.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.180.1">
      <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/11.png" style="vertical-align:-0.156em;height:0.820em;width:1.958em"/>
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.181.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.182.1">
     Is
    </span>
    <span class="koboSpan" id="kobo.183.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/12.png" style="vertical-align:-0.156em;height:0.820em;width:1.923em"/>
    </span>
    <span class="koboSpan" id="kobo.184.1">
     better than
    </span>
    <span class="koboSpan" id="kobo.185.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/13.png" style="vertical-align:-0.195em;height:0.897em;width:2.366em"/>
    </span>
    <span class="koboSpan" id="kobo.186.1">
     ?
    </span>
    <span class="koboSpan" id="kobo.186.2">
     Definitely.
    </span>
    <span class="koboSpan" id="kobo.186.3">
     We can see that just by changing the perspective of approaching the problem, we achieve a much more efficient solution.
    </span>
    <span class="koboSpan" id="kobo.186.4">
     To further test your understanding, think of a scenario where the problem was kept the same, except you now have to check whether John and Mary were third-degree connections instead of second-degree connections.
    </span>
    <span class="koboSpan" id="kobo.186.5">
     How would the time complexities of both approaches
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.187.1">
      be affected?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.188.1">
     Graphs are useful in practice.
    </span>
    <span class="koboSpan" id="kobo.188.2">
     But before we talk about how certain properties of graphs and algorithms are used to solve graph problems, we need to define a common language that we can use to refer to graphs and their properties.
    </span>
    <span class="koboSpan" id="kobo.188.3">
     The following section will cover how
    </span>
    <a id="_idIndexMarker021">
    </a>
    <span class="koboSpan" id="kobo.189.1">
     graphs are commonly defined in mathematics, and how a simple representation can cover all the different types of data that graphs
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.190.1">
      can represent.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-18">
    <a id="_idTextAnchor020">
    </a>
    <span class="koboSpan" id="kobo.191.1">
     Formalizing graphs
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.192.1">
     Graphs are a very
    </span>
    <a id="_idIndexMarker022">
    </a>
    <span class="koboSpan" id="kobo.193.1">
     popular concept in mathematics.
    </span>
    <span class="koboSpan" id="kobo.193.2">
     In this domain, a common terminology is well accepted.
    </span>
    <span class="koboSpan" id="kobo.193.3">
     Let’s take a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.194.1">
      closer look.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-19">
    <a id="_idTextAnchor021">
    </a>
    <span class="koboSpan" id="kobo.195.1">
     Definition and semantics
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.196.1">
     With the argument
    </span>
    <a id="_idIndexMarker023">
    </a>
    <span class="koboSpan" id="kobo.197.1">
     being made for graph representations to be a relevant topic for practical problems, let’s take a moment to define what a graph is.
    </span>
    <span class="koboSpan" id="kobo.197.2">
     A graph is an abstract concept.
    </span>
    <span class="koboSpan" id="kobo.197.3">
     Mathematically, it’s generally repre
    </span>
    <a id="_idTextAnchor022">
    </a>
    <span class="koboSpan" id="kobo.198.1">
     sented as
    </span>
    <span class="koboSpan" id="kobo.199.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;G&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/14.png" style="vertical-align:-0.156em;height:0.820em;width:2.969em"/>
    </span>
    <span class="koboSpan" id="kobo.200.1">
     , where
    </span>
    <span class="koboSpan" id="kobo.201.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;G&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/15.png" style="vertical-align:-0.015em;height:0.679em;width:0.682em"/>
    </span>
    <span class="koboSpan" id="kobo.202.1">
     is the graph, which contains a set of vertices,
    </span>
    <span class="koboSpan" id="kobo.203.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/1.png" style="vertical-align:-0.010em;height:0.658em;width:0.676em"/>
    </span>
    <span class="koboSpan" id="kobo.204.1">
     , and a set of edges,
    </span>
    <span class="koboSpan" id="kobo.205.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/17.png" style="vertical-align:-0.000em;height:0.648em;width:0.572em"/>
    </span>
    <span class="koboSpan" id="kobo.206.1">
     .
    </span>
    <span class="koboSpan" id="kobo.206.2">
     Each element of
    </span>
    <span class="koboSpan" id="kobo.207.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/17.png" style="vertical-align:-0.000em;height:0.648em;width:0.572em"/>
    </span>
    <span class="koboSpan" id="kobo.208.1">
     is a tuple,
    </span>
    <span class="koboSpan" id="kobo.209.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/19.png" style="vertical-align:-0.333em;height:1.174em;width:3.278em"/>
    </span>
    <span class="koboSpan" id="kobo.210.1">
     , where
    </span>
    <span class="koboSpan" id="kobo.211.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;∈&lt;/mml:mo&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/20.png" style="vertical-align:-0.333em;height:0.981em;width:4.671em"/>
    </span>
    <span class="koboSpan" id="kobo.212.1">
     , and represents a connection between the two vertices.
    </span>
    <span class="koboSpan" id="kobo.212.2">
     That’s all there is to the mathematical definition; how you choose to apply semantics to this is completely up
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.213.1">
      to you.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.214.1">
     In the example mentioned in the previous section, the users of the social media platform were represented by the vertices, and the connection between the two users was represented by the edges.
    </span>
    <span class="koboSpan" id="kobo.214.2">
     Also, vertices and edges need not be so homogeneous.
    </span>
    <span class="koboSpan" id="kobo.214.3">
     Consider the graph representation of a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.215.1">
      home network:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer039">
     <span class="koboSpan" id="kobo.216.1">
      <img alt="Figure 1.4 – A classic heterogeneous graph, where there are multiple types of elements represented as nodes. There is also heterogeneity in the interactions represented by edges" src="image/B22118_01_4.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.217.1">
     Figure 1.4 – A classic heterogeneous graph, where there are multiple types of elements represented as nodes.
    </span>
    <span class="koboSpan" id="kobo.217.2">
     There is also heterogeneity in the interactions represented by edges
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.218.1">
     Here, the nodes represent all entities
    </span>
    <a id="_idIndexMarker024">
    </a>
    <span class="koboSpan" id="kobo.219.1">
     present in the home network, from human users to
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.220.1">
      Internet of Things
     </span>
    </strong>
    <span class="koboSpan" id="kobo.221.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.222.1">
      IoT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.223.1">
     ) devices, routers, and smart TVs.
    </span>
    <span class="koboSpan" id="kobo.223.2">
     The semantics of the edges range from interaction to network communication and media streaming.
    </span>
    <span class="koboSpan" id="kobo.223.3">
     Formally, the set of
    </span>
    <a id="_idIndexMarker025">
    </a>
    <span class="koboSpan" id="kobo.224.1">
     vertices and edges can be defined
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.225.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.226.1">
V = {user</span><span class="subscript"><span class="koboSpan" id="kobo.227.1">i</span></span><span class="koboSpan" id="kobo.228.1">, user</span><span class="subscript"><span class="koboSpan" id="kobo.229.1">2</span></span><span class="koboSpan" id="kobo.230.1">, iPhone, Smart TV, Laptop, Android Phone, Raspberry Pi, Router, ISP</span><span class="subscript"><span class="koboSpan" id="kobo.231.1">1</span></span><span class="koboSpan" id="kobo.232.1">, ISP</span><span class="subscript"><span class="koboSpan" id="kobo.233.1">2</span></span><span class="koboSpan" id="kobo.234.1">}
E = {
  (user</span><span class="subscript"><span class="koboSpan" id="kobo.235.1">1</span></span><span class="koboSpan" id="kobo.236.1">,iPhone: interacts with),
  (user</span><span class="subscript"><span class="koboSpan" id="kobo.237.1">1</span></span><span class="koboSpan" id="kobo.238.1">,Smart TV: interacts with),
  (user</span><span class="subscript"><span class="koboSpan" id="kobo.239.1">1</span></span><span class="koboSpan" id="kobo.240.1">,Laptop: interacts with),
  (user</span><span class="subscript"><span class="koboSpan" id="kobo.241.1">2</span></span><span class="koboSpan" id="kobo.242.1">,Smart TV: interacts with),
  (user</span><span class="subscript"><span class="koboSpan" id="kobo.243.1">2</span></span><span class="koboSpan" id="kobo.244.1">,Laptop: interacts with),
  (user</span><span class="subscript"><span class="koboSpan" id="kobo.245.1">2</span></span><span class="koboSpan" id="kobo.246.1">,Android Phone: interacts with),
  (iPhone,Router: communicates with),
  (Smart TV,Router: communicates with),
  (Laptop,Router: communicates with),
  (Android Phone,Router: communicates with),
  (Raspberry Pi,Smart TV: streams to),
  (Raspberry Pi,Router: communicates with),
  (Router,ISP</span><span class="subscript"><span class="koboSpan" id="kobo.247.1">1</span></span><span class="koboSpan" id="kobo.248.1">: is connected to),
  (Android Phone,ISP</span><span class="subscript"><span class="koboSpan" id="kobo.249.1">2</span></span><span class="koboSpan" id="kobo.250.1">: is connected to)
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.251.1">
     Graph representations can be further supercharged by adding more information specific to the nodes or edges.
    </span>
    <span class="koboSpan" id="kobo.251.2">
     A popular way to represent this information is by using a feature vector.
    </span>
    <span class="koboSpan" id="kobo.251.3">
     We’ll learn more about how node and edge features can be added in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.252.1">
      future chapters.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.253.1">
     The key takeaway here is that graphs are an incredibly powerful way of representing facts.
    </span>
    <span class="koboSpan" id="kobo.253.2">
     With this definition at hand, let’s try to investigate a few derived characteristics of graphs.
    </span>
    <span class="koboSpan" id="kobo.253.3">
     Certain characteristics of graphs imply certain high-level facts about how the nodes and edges in
    </span>
    <a id="_idIndexMarker026">
    </a>
    <span class="koboSpan" id="kobo.254.1">
     the graph are organized.
    </span>
    <span class="koboSpan" id="kobo.254.2">
     The next section focuses on a few such popular properties and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.255.1">
      graph types.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-20">
    <a id="_idTextAnchor023">
    </a>
    <span class="koboSpan" id="kobo.256.1">
     Types and properties of graphs
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.257.1">
     Several types of graphs have been identified, each
    </span>
    <a id="_idIndexMarker027">
    </a>
    <span class="koboSpan" id="kobo.258.1">
     with its unique properties, but we’ll focus on the ones that are most popular.
    </span>
    <span class="koboSpan" id="kobo.258.2">
     Note that these types need not be mutually exclusive, meaning a graph can be labeled as more than one type at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.259.1">
      a time.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-21">
    <a id="_idTextAnchor024">
    </a>
    <span class="koboSpan" id="kobo.260.1">
     Directed graphs
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.261.1">
     Graphs are
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.262.1">
      directed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.263.1">
     when
    </span>
    <a id="_idIndexMarker028">
    </a>
    <span class="koboSpan" id="kobo.264.1">
     the edges have a one-way
    </span>
    <a id="_idIndexMarker029">
    </a>
    <span class="koboSpan" id="kobo.265.1">
     relationship between their connecting nodes.
    </span>
    <span class="koboSpan" id="kobo.265.2">
     There are many scenarios where the relationship that’s represented is unidirectional.
    </span>
    <span class="koboSpan" id="kobo.265.3">
     In a graph representing a family tree, an edge might represent the relation “
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.266.1">
      is a parent of,
     </span>
    </em>
    <span class="koboSpan" id="kobo.267.1">
     ” and another might represent the relation “
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.268.1">
      is a pet of.
     </span>
    </em>
    <span class="koboSpan" id="kobo.269.1">
     ” Such relationships can’t be inverted between the nodes and hold the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.270.1">
      same meaning.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-22">
    <a id="_idTextAnchor025">
    </a>
    <span class="koboSpan" id="kobo.271.1">
     Bipartite graphs
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.272.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.273.1">
      bipartite graph
     </span>
    </strong>
    <span class="koboSpan" id="kobo.274.1">
     is a type
    </span>
    <a id="_idIndexMarker030">
    </a>
    <span class="koboSpan" id="kobo.275.1">
     of graph whose
    </span>
    <a id="_idIndexMarker031">
    </a>
    <span class="koboSpan" id="kobo.276.1">
     vertices can be divided into two disjoint sets such that every edge connects a vertex from one set to a vertex in the other set.
    </span>
    <span class="koboSpan" id="kobo.276.2">
     In other words, there are no edges that connect vertices within the same set.
    </span>
    <span class="koboSpan" id="kobo.276.3">
     Mathematically, a graph,
    </span>
    <span class="koboSpan" id="kobo.277.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;G&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/21.png" style="vertical-align:-0.156em;height:0.820em;width:4.550em"/>
    </span>
    <span class="koboSpan" id="kobo.278.1">
     , is bipartite if the vertex set,
    </span>
    <span class="koboSpan" id="kobo.279.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/1.png" style="vertical-align:-0.010em;height:0.658em;width:0.665em"/>
    </span>
    <span class="koboSpan" id="kobo.280.1">
     , is partitioned into two non-empty sets,
    </span>
    <span class="koboSpan" id="kobo.281.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" src="image/23.png" style="vertical-align:-0.333em;height:0.981em;width:0.900em"/>
    </span>
    <span class="koboSpan" id="kobo.282.1">
     and
    </span>
    <span class="koboSpan" id="kobo.283.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" src="image/24.png" style="vertical-align:-0.333em;height:0.981em;width:0.900em"/>
    </span>
    <span class="koboSpan" id="kobo.284.1">
     , such that every edge in
    </span>
    <span class="koboSpan" id="kobo.285.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/25.png" style="vertical-align:-0.000em;height:0.648em;width:0.550em"/>
    </span>
    <span class="koboSpan" id="kobo.286.1">
     connects a vertex in
    </span>
    <span class="koboSpan" id="kobo.287.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" src="image/26.png" style="vertical-align:-0.333em;height:0.981em;width:0.918em"/>
    </span>
    <span class="koboSpan" id="kobo.288.1">
     to a vertex
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.289.1">
      in
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.290.1">
      <img alt="&lt;mml:math  &gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" src="image/27.png" style="vertical-align:-0.333em;height:0.981em;width:0.918em"/>
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.291.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.292.1">
     Bipartite graphs are often denoted as
    </span>
    <span class="koboSpan" id="kobo.293.1">
     <img alt="&lt;math &gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" src="image/28.png" style="vertical-align:-0.333em;height:1.174em;width:4.683em"/>
    </span>
    <span class="koboSpan" id="kobo.294.1">
     , where
    </span>
    <span class="koboSpan" id="kobo.295.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" src="image/29.png" style="vertical-align:-0.333em;height:0.981em;width:0.897em"/>
    </span>
    <span class="koboSpan" id="kobo.296.1">
     and
    </span>
    <span class="koboSpan" id="kobo.297.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" src="image/30.png" style="vertical-align:-0.333em;height:0.981em;width:0.898em"/>
    </span>
    <span class="koboSpan" id="kobo.298.1">
     are the two disjoint sets of vertices, and
    </span>
    <span class="koboSpan" id="kobo.299.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/31.png" style="vertical-align:-0.000em;height:0.648em;width:0.546em"/>
    </span>
    <span class="koboSpan" id="kobo.300.1">
     is the set of edges connecting vertices from
    </span>
    <span class="koboSpan" id="kobo.301.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" src="image/32.png" style="vertical-align:-0.333em;height:0.981em;width:0.890em"/>
    </span>
    <span class="koboSpan" id="kobo.302.1">
     to
    </span>
    <span class="koboSpan" id="kobo.303.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" src="image/33.png" style="vertical-align:-0.333em;height:0.981em;width:0.890em"/>
    </span>
    <span class="koboSpan" id="kobo.304.1">
     One common application of bipartite graphs is in modeling relationships between two distinct types of entities, where edges represent connections or relationships between entities of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.305.1">
      different types.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.306.1">
     Bipartite graphs occur very commonly in the wild.
    </span>
    <span class="koboSpan" id="kobo.306.2">
     In e-commerce,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.307.1">
      recommendation systems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.308.1">
     , also
    </span>
    <a id="_idIndexMarker032">
    </a>
    <span class="koboSpan" id="kobo.309.1">
     known as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.310.1">
      recommender systems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.311.1">
     (see
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.312.1">
      Chapters 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.313.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.314.1">
      9
     </span>
    </em>
    <span class="koboSpan" id="kobo.315.1">
     ), are built on bipartite graph data, where the nodes consist of users and items.
    </span>
    <span class="koboSpan" id="kobo.315.2">
     The users and items never interact within their own kind; only interactions between users and items exist.
    </span>
    <span class="koboSpan" id="kobo.315.3">
     This interaction can be in the form of clicks or orders of items made by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.316.1">
      the user:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer053">
     <span class="koboSpan" id="kobo.317.1">
      <img alt="Figure 1.5 – A classic example of a bipartite graph, from an e-commerce application" src="image/B22118_01_5.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.318.1">
     Figure 1.5 – A classic example of a bipartite graph, from an e-commerce application
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.319.1">
     Another example of a bipartite graph is the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.320.1">
      marriage problem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.321.1">
     , where vertices in one set represent men, vertices in the other set represent women, and edges represent marriages between couples.
    </span>
    <span class="koboSpan" id="kobo.321.2">
     Another example is modeling interactions between customers and
    </span>
    <a id="_idIndexMarker033">
    </a>
    <span class="koboSpan" id="kobo.322.1">
     products in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.323.1">
      recommender
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker034">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.324.1">
      systems.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-23">
    <a id="_idTextAnchor026">
    </a>
    <span class="koboSpan" id="kobo.325.1">
     Connected graphs
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.326.1">
     Fully
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.327.1">
      connected graphs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.328.1">
     , also known as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.329.1">
      complete graphs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.330.1">
     , are graphs in which every pair of distinct
    </span>
    <a id="_idIndexMarker035">
    </a>
    <span class="koboSpan" id="kobo.331.1">
     vertices
    </span>
    <a id="_idIndexMarker036">
    </a>
    <span class="koboSpan" id="kobo.332.1">
     is connected by an edge, forming a network where each node is directly linked to every other node.
    </span>
    <span class="koboSpan" id="kobo.332.2">
     They exhibit high connectivity but can become computationally intensive as the number of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.333.1">
      nodes increases.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-24">
    <a id="_idTextAnchor027">
    </a>
    <span class="koboSpan" id="kobo.334.1">
     Weighted graphs
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.335.1">
     Graphs can also be
    </span>
    <a id="_idIndexMarker037">
    </a>
    <span class="koboSpan" id="kobo.336.1">
     appended with additional information
    </span>
    <a id="_idIndexMarker038">
    </a>
    <span class="koboSpan" id="kobo.337.1">
     on both the nodes and edges.
    </span>
    <span class="koboSpan" id="kobo.337.2">
     When the edges are added as scalar additional information, the graph is said to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.338.1">
      be
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.339.1">
       weighted
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.340.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.341.1">
     While on the topic of graph types, let’s complete our discussion by introducing a few commonly noted properties of graphs.
    </span>
    <span class="koboSpan" id="kobo.341.2">
     These aren’t labels that are attached to graphs, as we discussed previously regarding the different types of graphs, but certain measures or attributes of graphs that are agnostic of the type of graph
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      under concern.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-25">
    <a id="_idTextAnchor028">
    </a>
    <span class="koboSpan" id="kobo.343.1">
     Subgraphs
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.344.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.345.1">
      subgraph
     </span>
    </strong>
    <span class="koboSpan" id="kobo.346.1">
     is a graph that’s formed from a subset
    </span>
    <a id="_idIndexMarker039">
    </a>
    <span class="koboSpan" id="kobo.347.1">
     of the vertices and edges of the original graph.
    </span>
    <span class="koboSpan" id="kobo.347.2">
     More formally, let
    </span>
    <span class="koboSpan" id="kobo.348.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;G&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/34.png" style="vertical-align:-0.015em;height:0.679em;width:0.678em"/>
    </span>
    <span class="koboSpan" id="kobo.349.1">
     be a graph with vertex set
    </span>
    <span class="koboSpan" id="kobo.350.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/1.png" style="vertical-align:-0.010em;height:0.658em;width:0.672em"/>
    </span>
    <span class="koboSpan" id="kobo.351.1">
     and edge set
    </span>
    <span class="koboSpan" id="kobo.352.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/2.png" style="vertical-align:-0.000em;height:0.648em;width:0.556em"/>
    </span>
    <span class="koboSpan" id="kobo.353.1">
     .
    </span>
    <span class="koboSpan" id="kobo.353.2">
     A subgraph of
    </span>
    <span class="koboSpan" id="kobo.354.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;G&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/34.png" style="vertical-align:-0.015em;height:0.679em;width:0.678em"/>
    </span>
    <span class="koboSpan" id="kobo.355.1">
     is a graph,
    </span>
    <span class="koboSpan" id="kobo.356.1">
     <img alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;G&lt;/mml:mi&gt;&lt;mml:mi&gt;'&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/38.png" style="vertical-align:-0.015em;height:0.692em;width:0.965em"/>
    </span>
    <span class="koboSpan" id="kobo.357.1">
     , such that
    </span>
    <span class="koboSpan" id="kobo.358.1">
     <img alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;G&lt;/mml:mi&gt;&lt;mml:mi&gt;'&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/39.png" style="vertical-align:-0.170em;height:0.847em;width:2.463em"/>
    </span>
    <span class="koboSpan" id="kobo.359.1">
     is a subset of
    </span>
    <span class="koboSpan" id="kobo.360.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/40.png" style="vertical-align:-0.010em;height:0.658em;width:0.705em"/>
    </span>
    <span class="koboSpan" id="kobo.361.1">
     and E(
    </span>
    <span class="koboSpan" id="kobo.362.1">
     <img alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;G&lt;/mml:mi&gt;&lt;mml:mi&gt;'&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/41.png" style="vertical-align:-0.169em;height:0.846em;width:1.398em"/>
    </span>
    <span class="koboSpan" id="kobo.363.1">
     is a subset of
    </span>
    <span class="koboSpan" id="kobo.364.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/2.png" style="vertical-align:-0.000em;height:0.648em;width:0.558em"/>
    </span>
    <span class="koboSpan" id="kobo.365.1">
     .
    </span>
    <span class="koboSpan" id="kobo.365.2">
     Often, searching for subgraphs with useful properties such as being bipartite, or connected, is an important step for the bigger problem
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.366.1">
      at hand.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-26">
    <a id="_idTextAnchor029">
    </a>
    <span class="koboSpan" id="kobo.367.1">
     Centrality
    </span>
   </h2>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.368.1">
      Centrality
     </span>
    </strong>
    <span class="koboSpan" id="kobo.369.1">
     is a
    </span>
    <a id="_idIndexMarker040">
    </a>
    <span class="koboSpan" id="kobo.370.1">
     measure in
    </span>
    <a id="_idIndexMarker041">
    </a>
    <span class="koboSpan" id="kobo.371.1">
     graph theory that quantifies the importance or influence of a node within a network.
    </span>
    <span class="koboSpan" id="kobo.371.2">
     Nodes with high centrality are more central to the network, playing a more significant role in its structure and dynamics.
    </span>
    <span class="koboSpan" id="kobo.371.3">
     There are several centrality measures, each capturing different aspects of a node’s importance.
    </span>
    <span class="koboSpan" id="kobo.371.4">
     Here are some common
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.372.1">
      centrality measures:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.373.1">
       Degree centrality
      </span>
     </strong>
     <span class="koboSpan" id="kobo.374.1">
      : The degree
     </span>
     <a id="_idIndexMarker042">
     </a>
     <span class="koboSpan" id="kobo.375.1">
      centrality of a node is the number of edges connected to it (that is, the number of neighbors it has).
     </span>
     <span class="koboSpan" id="kobo.375.2">
      Nodes with a high degree of centrality are well-connected and may play a crucial role in spreading information
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.376.1">
       or influence.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.377.1">
       Closeness centrality
      </span>
     </strong>
     <span class="koboSpan" id="kobo.378.1">
      : Closeness centrality measures how close a node is to all other nodes in the network.
     </span>
     <span class="koboSpan" id="kobo.378.2">
      It’s the reciprocal of the sum of the shortest path distances from a node to all other nodes.
     </span>
     <span class="koboSpan" id="kobo.378.3">
      Nodes with high closeness centrality can quickly interact with other nodes and are often central in terms of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.379.1">
       communication efficiency.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.380.1">
       Betweenness centrality
      </span>
     </strong>
     <span class="koboSpan" id="kobo.381.1">
      : Betweenness centrality quantifies the number of shortest paths that pass through a node.
     </span>
     <span class="koboSpan" id="kobo.381.2">
      A node with high betweenness centrality has a significant influence on communication between other nodes.
     </span>
     <span class="koboSpan" id="kobo.381.3">
      Nodes with high betweenness centrality act as bridges or gatekeepers in the network, controlling
     </span>
     <a id="_idIndexMarker043">
     </a>
     <span class="koboSpan" id="kobo.382.1">
      the flow
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.383.1">
       of information.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.384.1">
       Eigenvector centrality
      </span>
     </strong>
     <span class="koboSpan" id="kobo.385.1">
      : Eigenvector centrality considers not only the number of connections a node has but also the centrality of its neighbors.
     </span>
     <span class="koboSpan" id="kobo.385.2">
      It’s based on the principle that connections to high-scoring nodes contribute more to a node’s centrality.
     </span>
     <span class="koboSpan" id="kobo.385.3">
      Nodes with high eigenvector centrality are connected to other central nodes, making them important in the overall
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.386.1">
       network structure.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.387.1">
       PageRank
      </span>
     </strong>
     <span class="koboSpan" id="kobo.388.1">
      : PageRank is a centrality measure that’s used in web search algorithms (for example, Google’s PageRank).
     </span>
     <span class="koboSpan" id="kobo.388.2">
      It assigns importance to a node based on both the number and quality of its incoming links.
     </span>
     <span class="koboSpan" id="kobo.388.3">
      Nodes with high PageRank are considered influential
     </span>
     <a id="_idIndexMarker044">
     </a>
     <span class="koboSpan" id="kobo.389.1">
      as they are linked to other
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.390.1">
       important nodes.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.391.1">
     Centrality measures help identify key nodes in a network, which can be important for understanding information flow, identifying influential individuals, or targeting nodes for interventions in various applications such as social networks, transportation systems, and biological
    </span>
    <a id="_idIndexMarker045">
    </a>
    <span class="koboSpan" id="kobo.392.1">
     networks.
    </span>
    <span class="koboSpan" id="kobo.392.2">
     Different centrality measures may
    </span>
    <a id="_idIndexMarker046">
    </a>
    <span class="koboSpan" id="kobo.393.1">
     be appropriate, depending on the specific context and goals of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.394.1">
      the analysis.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-27">
    <a id="_idTextAnchor030">
    </a>
    <span class="koboSpan" id="kobo.395.1">
     Community structure
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.396.1">
     In terms of graphs,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.397.1">
      community structure
     </span>
    </strong>
    <span class="koboSpan" id="kobo.398.1">
     refers to dividing a network or graph into groups or
    </span>
    <a id="_idIndexMarker047">
    </a>
    <span class="koboSpan" id="kobo.399.1">
     clusters
    </span>
    <a id="_idIndexMarker048">
    </a>
    <span class="koboSpan" id="kobo.400.1">
     of nodes that are densely connected internally but have fewer connections between groups.
    </span>
    <span class="koboSpan" id="kobo.400.2">
     Nodes within a community are more likely to share similar properties, interests, or functions, and identifying community structure is a fundamental aspect of analyzing the organization and dynamics of complex networks.
    </span>
    <span class="koboSpan" id="kobo.400.3">
     Detecting communities in a graph is crucial for understanding the modular organization of the system and can have applications in various fields, including social network analysis, biology, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.401.1">
      information retrieval.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-28">
    <a id="_idTextAnchor031">
    </a>
    <span class="koboSpan" id="kobo.402.1">
     Isomorphism
    </span>
   </h2>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.403.1">
      Isomorphism
     </span>
    </strong>
    <span class="koboSpan" id="kobo.404.1">
     is a concept in graph
    </span>
    <a id="_idIndexMarker049">
    </a>
    <span class="koboSpan" id="kobo.405.1">
     theory that deals
    </span>
    <a id="_idIndexMarker050">
    </a>
    <span class="koboSpan" id="kobo.406.1">
     with the structural similarity between two graphs.
    </span>
    <span class="koboSpan" id="kobo.406.2">
     Two graphs are considered isomorphic if a one-to-one correspondence exists between their vertices such that the adjacency relationships are preserved.
    </span>
    <span class="koboSpan" id="kobo.406.3">
     In other words, the graphs are essentially the same from a structural point of view, even if the vertex and edge labels
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.407.1">
      may differ.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.408.1">
     Graph isomorphism is a fundamental problem in computer science and has applications in various areas, such as chemistry, computer-aided design, and pattern recognition.
    </span>
    <span class="koboSpan" id="kobo.408.2">
     Despite its practical importance, finding a fast algorithm for graph isomorphism has proven to be a challenging problem, and it remains an open question whether such an algorithm exists with polynomial
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.409.1">
      time complexity:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer063">
     <span class="koboSpan" id="kobo.410.1">
      <img alt="Figure 1.6 – G and H are isomorphic graphs. To understand this, notice the mapping: g1→h1, g2→h2, g3→h3, and so on" src="image/B22118_01_6.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.411.1">
     Figure 1.6 – G and H are isomorphic graphs.
    </span>
    <span class="koboSpan" id="kobo.411.2">
     To understand this, notice the mapping: g
    </span>
    <span class="subscript">
     <span class="koboSpan" id="kobo.412.1">
      1
     </span>
    </span>
    <span class="koboSpan" id="kobo.413.1">
     →h
    </span>
    <span class="subscript">
     <span class="koboSpan" id="kobo.414.1">
      1
     </span>
    </span>
    <span class="koboSpan" id="kobo.415.1">
     , g
    </span>
    <span class="subscript">
     <span class="koboSpan" id="kobo.416.1">
      2
     </span>
    </span>
    <span class="koboSpan" id="kobo.417.1">
     →h
    </span>
    <span class="subscript">
     <span class="koboSpan" id="kobo.418.1">
      2
     </span>
    </span>
    <span class="koboSpan" id="kobo.419.1">
     , g
    </span>
    <span class="subscript">
     <span class="koboSpan" id="kobo.420.1">
      3
     </span>
    </span>
    <span class="koboSpan" id="kobo.421.1">
     →h
    </span>
    <span class="subscript">
     <span class="koboSpan" id="kobo.422.1">
      3
     </span>
    </span>
    <span class="koboSpan" id="kobo.423.1">
     , and so on
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.424.1">
     The properties of specialized graphs can be exploited to derive further insights into the scenarios represented by these
    </span>
    <a id="_idIndexMarker051">
    </a>
    <span class="koboSpan" id="kobo.425.1">
     graphs.
    </span>
    <span class="koboSpan" id="kobo.425.2">
     Now, let’s take a look at
    </span>
    <a id="_idIndexMarker052">
    </a>
    <span class="koboSpan" id="kobo.426.1">
     how graphs can be fed into machines so that they can be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      read algorithmically.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-29">
    <a id="_idTextAnchor032">
    </a>
    <span class="koboSpan" id="kobo.428.1">
     Graph data structures
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.429.1">
     How should we feed
    </span>
    <a id="_idIndexMarker053">
    </a>
    <span class="koboSpan" id="kobo.430.1">
     graph data into computer programs so that we can apply graph-based algorithms to solve problems?
    </span>
    <span class="koboSpan" id="kobo.430.2">
     This will be addressed in this section.
    </span>
    <span class="koboSpan" id="kobo.430.3">
     Each representation has its advantages and disadvantages, and we’ll explore them from the perspective of the time complexity of determining whether an edge exists and updating
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.431.1">
      the graph.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-30">
    <a id="_idTextAnchor033">
    </a>
    <span class="koboSpan" id="kobo.432.1">
     Adjacency matrix
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.433.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.434.1">
      adjacency matrix
     </span>
    </strong>
    <span class="koboSpan" id="kobo.435.1">
     aims to
    </span>
    <a id="_idIndexMarker054">
    </a>
    <span class="koboSpan" id="kobo.436.1">
     record the graph structure
    </span>
    <a id="_idIndexMarker055">
    </a>
    <span class="koboSpan" id="kobo.437.1">
     via a matrix.
    </span>
    <span class="koboSpan" id="kobo.437.2">
     A matrix, say
    </span>
    <span class="koboSpan" id="kobo.438.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/43.png" style="vertical-align:-0.000em;height:0.663em;width:0.663em"/>
    </span>
    <span class="koboSpan" id="kobo.439.1">
     , of size
    </span>
    <span class="koboSpan" id="kobo.440.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;mml:mo&gt;×&lt;/mml:mo&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/44.png" style="vertical-align:-0.012em;height:0.495em;width:1.973em"/>
    </span>
    <span class="koboSpan" id="kobo.441.1">
     is created (where
    </span>
    <span class="koboSpan" id="kobo.442.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/45.png" style="vertical-align:-0.012em;height:0.460em;width:0.437em"/>
    </span>
    <span class="koboSpan" id="kobo.443.1">
     denotes the number of nodes, or mathematically,
    </span>
    <span class="koboSpan" id="kobo.444.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/46.png" style="vertical-align:-0.141em;height:0.789em;width:3.102em"/>
    </span>
    <span class="koboSpan" id="kobo.445.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.445.2">
     We start with all entries of
    </span>
    <span class="koboSpan" id="kobo.446.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/47.png" style="vertical-align:-0.000em;height:0.663em;width:0.659em"/>
    </span>
    <span class="koboSpan" id="kobo.447.1">
     being 0.
    </span>
    <span class="koboSpan" id="kobo.447.2">
     Next, if
    </span>
    <span class="koboSpan" id="kobo.448.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" src="image/48.png" style="vertical-align:-0.340em;height:1.188em;width:1.177em"/>
    </span>
    <span class="koboSpan" id="kobo.449.1">
     ,
    </span>
    <span class="koboSpan" id="kobo.450.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;j&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;∈&lt;/mml:mo&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/49.png" style="vertical-align:-0.483em;height:1.474em;width:3.236em"/>
    </span>
    <span class="koboSpan" id="kobo.451.1">
     , then element
    </span>
    <span class="koboSpan" id="kobo.452.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;j&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/50.png" style="vertical-align:-0.257em;height:1.021em;width:1.566em"/>
    </span>
    <span class="koboSpan" id="kobo.453.1">
     of
    </span>
    <span class="koboSpan" id="kobo.454.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/47.png" style="vertical-align:-0.000em;height:0.663em;width:0.659em"/>
    </span>
    <span class="koboSpan" id="kobo.455.1">
     is labeled
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.456.1">
      1
     </span>
    </em>
    <span class="koboSpan" id="kobo.457.1">
     .
    </span>
    <span class="koboSpan" id="kobo.457.2">
     If the graph is undirected, then if
    </span>
    <span class="koboSpan" id="kobo.458.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" src="image/52.png" style="vertical-align:-0.340em;height:1.188em;width:1.191em"/>
    </span>
    <span class="koboSpan" id="kobo.459.1">
     ,
    </span>
    <span class="koboSpan" id="kobo.460.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;j&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;∈&lt;/mml:mo&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/53.png" style="vertical-align:-0.483em;height:1.474em;width:3.267em"/>
    </span>
    <span class="koboSpan" id="kobo.461.1">
     , then both elements of
    </span>
    <span class="koboSpan" id="kobo.462.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/43.png" style="vertical-align:-0.000em;height:0.663em;width:0.663em"/>
    </span>
    <span class="koboSpan" id="kobo.463.1">
     ,
    </span>
    <span class="koboSpan" id="kobo.464.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;j&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/55.png" style="vertical-align:-0.257em;height:1.021em;width:1.583em"/>
    </span>
    <span class="koboSpan" id="kobo.465.1">
     , and
    </span>
    <span class="koboSpan" id="kobo.466.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;j&lt;/mml:mi&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/56.png" style="vertical-align:-0.257em;height:1.021em;width:1.583em"/>
    </span>
    <span class="koboSpan" id="kobo.467.1">
     , are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.468.1">
      labeled
     </span>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.469.1">
       1
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.470.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.471.1">
     The time complexity to check whether an edge exists in an adjacency matrix is
    </span>
    <span class="koboSpan" id="kobo.472.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/57.png" style="vertical-align:-0.156em;height:0.820em;width:2.002em"/>
    </span>
    <span class="koboSpan" id="kobo.473.1">
     since it just involves checking a particular cell in the matrix.
    </span>
    <span class="koboSpan" id="kobo.473.2">
     However, adding a new vertex to the graph would be difficult, and depending on the matrix implementation, it might need an entirely new initialization.
    </span>
    <span class="koboSpan" id="kobo.473.3">
     Finally, the space complexity of the adjacency matrix is also large, in the order of
    </span>
    <span class="koboSpan" id="kobo.474.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/58.png" style="vertical-align:-0.195em;height:0.897em;width:3.211em"/>
    </span>
    <span class="koboSpan" id="kobo.475.1">
     .
    </span>
    <span class="koboSpan" id="kobo.475.2">
     Sparse matrix implementations exist, which might reduce the space required by the matrix in memory, but they come with their own set of drawbacks.
    </span>
    <span class="koboSpan" id="kobo.475.3">
     Adjacency matrices are a good choice when the graph is fairly small and
    </span>
    <a id="_idIndexMarker056">
    </a>
    <span class="koboSpan" id="kobo.476.1">
     static and
    </span>
    <a id="_idIndexMarker057">
    </a>
    <span class="koboSpan" id="kobo.477.1">
     also requires
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.478.1">
      frequent lookup.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-31">
    <a id="_idTextAnchor034">
    </a>
    <span class="koboSpan" id="kobo.479.1">
     Adjacency list
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.480.1">
     Another popular data
    </span>
    <a id="_idIndexMarker058">
    </a>
    <span class="koboSpan" id="kobo.481.1">
     structure that’s used to store graph data
    </span>
    <a id="_idIndexMarker059">
    </a>
    <span class="koboSpan" id="kobo.482.1">
     is an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.483.1">
      adjacency list
     </span>
    </strong>
    <span class="koboSpan" id="kobo.484.1">
     .
    </span>
    <span class="koboSpan" id="kobo.484.2">
     It contains a dictionary that has keys as node names, and each entry contains a list of all nodes connected to the key node with an edge.
    </span>
    <span class="koboSpan" id="kobo.484.3">
     Unlike adjacency matrices, whose space complexity is
    </span>
    <span class="koboSpan" id="kobo.485.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/59.png" style="vertical-align:-0.195em;height:0.897em;width:3.003em"/>
    </span>
    <span class="koboSpan" id="kobo.486.1">
     , adjacency lists have a space complexity of
    </span>
    <span class="koboSpan" id="kobo.487.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mfenced open=&quot;|&quot; close=&quot;|&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/60.png" style="vertical-align:-0.191em;height:0.889em;width:4.439em"/>
    </span>
    <span class="koboSpan" id="kobo.488.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.488.2">
     However, adjacency lists are far more flexible with efficient time complexities for many data-related tasks.
    </span>
    <span class="koboSpan" id="kobo.488.3">
     Inserting vertices and edges is
    </span>
    <span class="koboSpan" id="kobo.489.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/61.png" style="vertical-align:-0.156em;height:0.820em;width:1.812em"/>
    </span>
    <span class="koboSpan" id="kobo.490.1">
     ; accessing neighbors takes
    </span>
    <span class="koboSpan" id="kobo.491.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/62.png" style="vertical-align:-0.156em;height:0.820em;width:1.879em"/>
    </span>
    <span class="koboSpan" id="kobo.492.1">
     as well, while finding whether an edge exists or not can take
    </span>
    <span class="koboSpan" id="kobo.493.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mfenced open=&quot;|&quot; close=&quot;|&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/63.png" style="vertical-align:-0.191em;height:0.889em;width:2.600em"/>
    </span>
    <span class="koboSpan" id="kobo.494.1">
     time.
    </span>
    <span class="koboSpan" id="kobo.494.2">
     Adjacency lists are a good choice when the graph is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.495.1">
      inherently sparse:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer085">
     <span class="koboSpan" id="kobo.496.1">
      <img alt="Figure 1.7 – For the given graph, G, M and L are the adjacency matrix and list, respectively" src="image/B22118_01_7.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.497.1">
     Figure 1.7 – For the given graph, G, M and L are the adjacency matrix and list, respectively
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.498.1">
     So far, we’ve talked about adjacency matrices and adjacency lists as the two most popular data structures that are used to represent graphs in algorithms.
    </span>
    <span class="koboSpan" id="kobo.498.2">
     However, several other graph
    </span>
    <a id="_idIndexMarker060">
    </a>
    <span class="koboSpan" id="kobo.499.1">
     data structures can be used based on the
    </span>
    <a id="_idIndexMarker061">
    </a>
    <span class="koboSpan" id="kobo.500.1">
     problem statement.
    </span>
    <span class="koboSpan" id="kobo.500.2">
     Each graph data structure has its own set of advantages and disadvantages, and this serves as a great domain on which further research can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.501.1">
      be performed.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-32">
    <a id="_idTextAnchor035">
    </a>
    <span class="koboSpan" id="kobo.502.1">
     Traditional graph-based solutions
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.503.1">
     Many
    </span>
    <a id="_idIndexMarker062">
    </a>
    <span class="koboSpan" id="kobo.504.1">
     computer scientists have etched their names in history by devising elegant solutions to seemingly complex problems involving graphs.
    </span>
    <span class="koboSpan" id="kobo.504.2">
     However, graphs aren’t just confined to the algorithm books, and graph-based problems are common in the wild.
    </span>
    <span class="koboSpan" id="kobo.504.3">
     Lots of business problems and scientific research can be boiled down to graph-based problems, on which existing solutions can be implemented to generate the required output.
    </span>
    <span class="koboSpan" id="kobo.504.4">
     In this section, we’ll talk about the most popular problems in the domain of graphs, a few approaches to solving them, and where these problems are encountered in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.505.1">
      practical scenarios.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-33">
    <a id="_idTextAnchor036">
    </a>
    <span class="koboSpan" id="kobo.506.1">
     Searching
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.507.1">
     There are two
    </span>
    <a id="_idIndexMarker063">
    </a>
    <span class="koboSpan" id="kobo.508.1">
     fundamental approaches when performing a search over a graph: breadth-first and depth-first.
    </span>
    <span class="koboSpan" id="kobo.508.2">
     Both are means to traverse a graph from a starting point to all nodes that can be reached from the initial node, but the differentiating factor is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.509.1">
      their approach.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.510.1">
     In BFS, the algorithm explores a graph level by level, starting from the source vertex and visiting all its neighbors before moving on to the next level.
    </span>
    <span class="koboSpan" id="kobo.510.2">
     This approach ensures that nodes closer to the source are visited before deeper nodes.
    </span>
    <span class="koboSpan" id="kobo.510.3">
     On the other hand,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.511.1">
      depth-first search
     </span>
    </strong>
    <span class="koboSpan" id="kobo.512.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.513.1">
      DFS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.514.1">
     ) explores
    </span>
    <a id="_idIndexMarker064">
    </a>
    <span class="koboSpan" id="kobo.515.1">
     a graph by going as deep as possible along each branch before backtracking.
    </span>
    <span class="koboSpan" id="kobo.515.2">
     It explores one branch of the graph until it reaches the end before moving on to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.516.1">
      next branch.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.517.1">
     BFS is well-suited for finding the shortest path in unweighted graphs and is commonly used in network routing protocols and social network analysis.
    </span>
    <span class="koboSpan" id="kobo.517.2">
     DFS, with its deep exploration, is useful in topological sorting, cycle detection, and solving problems such as maze exploration
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.518.1">
      and puzzle-solving.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.519.1">
     Now that we have a basic understanding of search algorithms, let’s look at another class of problems, called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.520.1">
      partitioning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.521.1">
     .
    </span>
    <span class="koboSpan" id="kobo.521.2">
     The need to understand graph partitions occurs frequently
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.522.1">
      in practice.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-34">
    <a id="_idTextAnchor037">
    </a>
    <span class="koboSpan" id="kobo.523.1">
     Partitioning
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.524.1">
     In graph
    </span>
    <a id="_idIndexMarker065">
    </a>
    <span class="koboSpan" id="kobo.525.1">
     theory, partitioning
    </span>
    <a id="_idIndexMarker066">
    </a>
    <span class="koboSpan" id="kobo.526.1">
     refers to dividing the vertices or edges of a graph into disjoint subsets or components.
    </span>
    <span class="koboSpan" id="kobo.526.2">
     The goal of partitioning is to group elements of the graph in such a way that certain properties are satisfied, or specific objectives are achieved.
    </span>
    <span class="koboSpan" id="kobo.526.3">
     There are different types of graph partitioning, and the choice of partitioning criteria depends on the application or problem
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.527.1">
      at hand:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.528.1">
       Vertex partitioning
      </span>
     </strong>
     <span class="koboSpan" id="kobo.529.1">
      : This involves dividing the set of vertices of a graph into disjoint subsets.
     </span>
     <span class="koboSpan" id="kobo.529.2">
      Vertex partitioning is done to achieve balance in terms of the number of vertices in each subset.
     </span>
     <span class="koboSpan" id="kobo.529.3">
      This is a problem that’s commonly encountered in load balancing in parallel computing, network design, and social
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.530.1">
       network analysis.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.531.1">
       Edge partitioning
      </span>
     </strong>
     <span class="koboSpan" id="kobo.532.1">
      : As the name suggests, this involves dividing the set of edges of a graph into disjoint subsets.
     </span>
     <span class="koboSpan" id="kobo.532.2">
      Just like vertex partitioning, the objective here is to balance the number of edges or the total weight of edges in each subset.
     </span>
     <span class="koboSpan" id="kobo.532.3">
      Edge partitioning problems generally find application in communication optimization in distributed computing, minimizing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.533.1">
       inter-partition communication.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.534.1">
       Graph cut
      </span>
     </strong>
     <span class="koboSpan" id="kobo.535.1">
      : This involves partitioning a graph by removing a minimum number of edges.
     </span>
     <span class="koboSpan" id="kobo.535.2">
      This is done to minimize the cut size (total weight of removed edges) while achieving certain constraints.
     </span>
     <span class="koboSpan" id="kobo.535.3">
      Applications include image segmentation and community detection in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.536.1">
       social networks.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.537.1">
       K-way partitioning
      </span>
     </strong>
     <span class="koboSpan" id="kobo.538.1">
      : This is a generalization of the aforementioned ideas and involves dividing the vertices or edges into
     </span>
     <span class="koboSpan" id="kobo.539.1">
      <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/64.png" style="vertical-align:-0.012em;height:0.723em;width:0.481em"/>
     </span>
     <span class="koboSpan" id="kobo.540.1">
      disjoint subsets.
     </span>
     <span class="koboSpan" id="kobo.540.2">
      We find k-way partitioning problems where we need to achieve balance in terms of the number of elements in each of the
     </span>
     <span class="koboSpan" id="kobo.541.1">
      <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/64.png" style="vertical-align:-0.012em;height:0.723em;width:0.475em"/>
     </span>
     <span class="koboSpan" id="kobo.542.1">
      subsets, such as in domains such as
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.543.1">
       very-large-scale integration
      </span>
     </strong>
     <span class="koboSpan" id="kobo.544.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.545.1">
       VLSI
      </span>
     </strong>
     <span class="koboSpan" id="kobo.546.1">
      ) design
     </span>
     <a id="_idIndexMarker067">
     </a>
     <span class="koboSpan" id="kobo.547.1">
      and parallel computing.
     </span>
     <span class="koboSpan" id="kobo.547.2">
      You can read more
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.548.1">
       here:
      </span>
     </span>
     <a href="https://patterns.eecs.berkeley.edu/?page_id=571">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.549.1">
        https://patterns.eecs.berkeley.edu/?page_id=571
       </span>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.550.1">
       .
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.551.1">
     Graph partitioning problems are often NP-hard, meaning finding an optimal solution may be computationally intractable for large graphs.
    </span>
    <span class="koboSpan" id="kobo.551.2">
     Therefore, various heuristics, approximation algorithms, and optimization techniques are employed to find good solutions in a reasonable amount
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.552.1">
      of time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.553.1">
     Another important
    </span>
    <a id="_idIndexMarker068">
    </a>
    <span class="koboSpan" id="kobo.554.1">
     problem in the domain of graphs is path
    </span>
    <a id="_idIndexMarker069">
    </a>
    <span class="koboSpan" id="kobo.555.1">
     optimization, and a lot of supply chain businesses and network researchers have been traditionally interested in solutions to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.556.1">
      such problems.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-35">
    <a id="_idTextAnchor038">
    </a>
    <span class="koboSpan" id="kobo.557.1">
     Path optimization
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.558.1">
     Two common
    </span>
    <a id="_idIndexMarker070">
    </a>
    <span class="koboSpan" id="kobo.559.1">
     problems in graph theory are finding the shortest path and finding the widest path between two nodes in a weighted graph.
    </span>
    <span class="koboSpan" id="kobo.559.2">
     Their applications are obvious and involve route optimization in supply chains and social network analysis (the problem mentioned in the preceding case study can also be viewed as a shortest path problem between the two nodes, especially if a slight modification was made by needing the edges to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.560.1">
      be weighted).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.561.1">
     The widest path problem is a variant of the shortest path problem.
    </span>
    <span class="koboSpan" id="kobo.561.2">
     Formally, the problem is defined thus: given a weighted graph, the widest path problem seeks a path from a source vertex to a target vertex such that the minimum edge weight (bottleneck) along the path is maximized.
    </span>
    <span class="koboSpan" id="kobo.561.3">
     This can be particularly relevant in network design or communication systems, where the goal is to maximize the capacity of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.562.1">
      bottleneck link.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.563.1">
     The most popular
    </span>
    <a id="_idIndexMarker071">
    </a>
    <span class="koboSpan" id="kobo.564.1">
     solution to find the shortest path between two
    </span>
    <a id="_idIndexMarker072">
    </a>
    <span class="koboSpan" id="kobo.565.1">
     nodes is
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.566.1">
      Dijkstra’s algorithm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.567.1">
     .
    </span>
    <span class="koboSpan" id="kobo.567.2">
     While not diving too much into the details, here’s a short step-by-step summary of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.568.1">
      the algorithm:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.569.1">
        Initialization
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.570.1">
       :
      </span>
     </span>
     <ol>
      <li class="upper-roman">
       <span class="koboSpan" id="kobo.571.1">
        Start at the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.572.1">
         source vertex.
        </span>
       </span>
      </li>
      <li class="upper-roman">
       <span class="koboSpan" id="kobo.573.1">
        Assign a tentative distance of 0 to the source and infinity to all
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.574.1">
         other vertices.
        </span>
       </span>
      </li>
      <li class="upper-roman">
       <span class="koboSpan" id="kobo.575.1">
        Mark all vertices
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.576.1">
         as unvisited.
        </span>
       </span>
      </li>
     </ol>
    </li>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.577.1">
        Iterative exploration
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.578.1">
       :
      </span>
     </span>
     <ol>
      <li class="upper-roman">
       <span class="koboSpan" id="kobo.579.1">
        Select the unvisited vertex with the smallest
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.580.1">
         tentative distance.
        </span>
       </span>
      </li>
      <li class="upper-roman">
       <span class="koboSpan" id="kobo.581.1">
        For the selected vertex, consider all
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.582.1">
         its neighbors.
        </span>
       </span>
      </li>
      <li class="upper-roman">
       <span class="koboSpan" id="kobo.583.1">
        Update the tentative distance of each neighbor by adding the distance from the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.584.1">
         current vertex.
        </span>
       </span>
      </li>
      <li class="upper-roman">
       <span class="koboSpan" id="kobo.585.1">
        If the updated distance is smaller than the current tentative distance,
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.586.1">
         update it.
        </span>
       </span>
      </li>
      <li class="upper-roman">
       <span class="koboSpan" id="kobo.587.1">
        Mark the current vertex
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.588.1">
         as visited.
        </span>
       </span>
      </li>
     </ol>
    </li>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.589.1">
        Termination
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.590.1">
       :
      </span>
     </span>
     <ol>
      <li class="upper-roman">
       <span class="koboSpan" id="kobo.591.1">
        Repeat the iterative process until the destination vertex is visited or all vertices have
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.592.1">
         been visited.
        </span>
       </span>
      </li>
      <li class="upper-roman">
       <span class="koboSpan" id="kobo.593.1">
        The final assigned distances represent the shortest paths from the source to all
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.594.1">
         other vertices.
        </span>
       </span>
      </li>
      <li class="upper-roman">
       <span class="koboSpan" id="kobo.595.1">
        Reconstruct the shortest path by backtracking from the destination to the source using the information that was stored about the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.596.1">
         shortest distances.
        </span>
       </span>
      </li>
     </ol>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.597.1">
     In summary, Dijkstra’s algorithm explores the graph in a step-by-step manner, always choosing the vertex with the smallest tentative distance.
    </span>
    <span class="koboSpan" id="kobo.597.2">
     It gradually builds up the shortest paths from the source to all other vertices while marking visited vertices.
    </span>
    <span class="koboSpan" id="kobo.597.3">
     The final result is a set of shortest distances and paths from the source to all other vertices in the graph.
    </span>
    <span class="koboSpan" id="kobo.597.4">
     The widest path problem can also be solved by the same algorithm, but instead of maintaining the smallest tentative distance per node, we maintain the bottleneck weight (or the maximum of the minimum weights across all paths).
    </span>
    <span class="koboSpan" id="kobo.597.5">
     The time complexity of this algorithm depends heavily on the implementation used, and the complexity ranges from
    </span>
    <span class="koboSpan" id="kobo.598.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfenced open=&quot;|&quot; close=&quot;|&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mfenced open=&quot;|&quot; close=&quot;|&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mi&gt;*&lt;/mml:mi&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/66.png" style="vertical-align:-0.257em;height:1.021em;width:1.399em"/>
    </span>
    <span class="_-----MathTools-_Math_Base">
     <span class="koboSpan" id="kobo.599.1">
      <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfenced open=&quot;|&quot; close=&quot;|&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mfenced open=&quot;|&quot; close=&quot;|&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;E&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mi&gt;*&lt;/mml:mi&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/67.png" style="vertical-align:-0.257em;height:1.022em;width:7.435em"/>
     </span>
    </span>
    <span class="koboSpan" id="kobo.600.1">
     to
    </span>
    <span class="koboSpan" id="kobo.601.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;mml:mo&gt;|&lt;/mml:mo&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" src="image/68.png" style="vertical-align:-0.195em;height:0.897em;width:3.005em"/>
    </span>
    <span class="koboSpan" id="kobo.602.1">
     .
    </span>
    <span class="koboSpan" id="kobo.602.2">
     Dijkstra’s algorithm fails when the edge weights are negative, however, and is also inefficient if the graph is nearly fully connected.
    </span>
    <span class="koboSpan" id="kobo.602.3">
     In such scenarios, alternatives such as the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.603.1">
      Bellman-Ford
     </span>
    </strong>
    <strong class="bold">
     <span class="koboSpan" id="kobo.604.1">
      algorithm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.605.1">
     can
    </span>
    <a id="_idIndexMarker073">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.606.1">
      be used.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.607.1">
     Now that we have a basic understanding of what kind of analytics are performed on graph data, let’s look at another powerful way of learning patterns within graph data.
    </span>
    <span class="koboSpan" id="kobo.607.2">
     The core ideas of
    </span>
    <a id="_idIndexMarker074">
    </a>
    <span class="koboSpan" id="kobo.608.1">
     representation learning are described in the following section; we’ll learn how representation learning is an important first step for solving many complex problems
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.609.1">
      involving graphs.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-36">
    <a id="_idTextAnchor039">
    </a>
    <span class="koboSpan" id="kobo.610.1">
     The need for representation learning
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.611.1">
     Here, we’ll introduce
    </span>
    <a id="_idIndexMarker075">
    </a>
    <span class="koboSpan" id="kobo.612.1">
     a new concept called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.613.1">
      representation learning for graphs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.614.1">
     .
    </span>
    <span class="koboSpan" id="kobo.614.2">
     Let’s use a small analogy to understand what this means.
    </span>
    <span class="koboSpan" id="kobo.614.3">
     A typical corporate organization has several entities: employees, IT equipment, offices, and so on.
    </span>
    <span class="koboSpan" id="kobo.614.4">
     All these entities maintain different types of relationships with each other: employees can be related to each other based on organizational hierarchy; one employee may use several pieces of IT equipment; several pieces of equipment, such as servers, can be networked with each other; employees and equipment can report physically or be located in a particular office, respectively; and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.615.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.616.1">
     A graph, quite rightly, seems like a natural way to represent this information,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.617.1">
      like this:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer091">
     <span class="koboSpan" id="kobo.618.1">
      <img alt="Figure 1.8 – A graph showing the different entities in an organization interacting with each other" src="image/B22118_01_8.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.619.1">
     Figure 1.8 – A graph showing the different entities in an organization interacting with each other
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.620.1">
     Graphs are very visually intuitive.
    </span>
    <span class="koboSpan" id="kobo.620.2">
     However, performing algorithmic calculations on graphs isn’t trivial.
    </span>
    <span class="koboSpan" id="kobo.620.3">
     Could
    </span>
    <a id="_idIndexMarker076">
    </a>
    <span class="koboSpan" id="kobo.621.1">
     we find a way to capture the characteristics as well as the relationship information of each entity as much as possible, but within some common fields?
    </span>
    <span class="koboSpan" id="kobo.621.2">
     Consider a sort of unique ID card for each entity that contains the following fields: Name, Sub-Organization, Date of Initiation, Years in Industry, and Geographic Location.
    </span>
    <span class="koboSpan" id="kobo.621.3">
     So, a few ID cards may look
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.622.1">
      like this:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer092">
     <span class="koboSpan" id="kobo.623.1">
      <img alt="Figure 1.9 – Examples of a few ID cards with the same fields for all entities" src="image/B22118_01_9.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.624.1">
     Figure 1.9 – Examples of a few ID cards with the same fields for all entities
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.625.1">
     Now, if you’re presented with a set of ID cards of all entities and not the preceding graph, could you answer questions such as which employee reports to whom?
    </span>
    <span class="koboSpan" id="kobo.625.2">
     Alternatively, which ID card is that of an employee, which of the office, and which of a piece of IT equipment?
    </span>
    <span class="koboSpan" id="kobo.625.3">
     It’s not easy (or completely feasible) to determine the answers to such questions
    </span>
    <a id="_idIndexMarker077">
    </a>
    <span class="koboSpan" id="kobo.626.1">
     using just the information in the ID cards, but we can get close to the correct answer.
    </span>
    <span class="koboSpan" id="kobo.626.2">
     To answer whether an employee is under some other employee in the hierarchy, we can check whether both employees have the same
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.627.1">
      Sub-Organization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.628.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.629.1">
      Geographic-Location
     </span>
    </strong>
    <span class="koboSpan" id="kobo.630.1">
     values and whether the employee higher in the hierarchy has a higher
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.631.1">
      Years-in-Industry
     </span>
    </strong>
    <span class="koboSpan" id="kobo.632.1">
     value than the other.
    </span>
    <span class="koboSpan" id="kobo.632.2">
     Guessing whether an ID card belongs to an office might simply mean checking whether the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.633.1">
      Sub-Organization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.634.1">
     value of the entity is blank, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.635.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.636.1">
     While this approach sounds non-intuitive at first, using such heuristics to try to answer these practical questions based simply on the ID cards, and not the graph, can be performed efficiently by computers and modern-day implementations.
    </span>
    <span class="koboSpan" id="kobo.636.2">
     The ID card here tries to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.637.1">
      represent
     </span>
    </em>
    <span class="koboSpan" id="kobo.638.1">
     the characteristics of the entities and relationships in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.639.1">
      the graph.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.640.1">
     More formally, the ID cards in the preceding example are vector embeddings of a fixed dimension that’s associated with each node of the graph.
    </span>
    <span class="koboSpan" id="kobo.640.2">
     A learning algorithm is applied that tries to capture as much information present in the graph structure within these embeddings.
    </span>
    <span class="koboSpan" id="kobo.640.3">
     These sets of embeddings are then used to answer difficult questions regarding the graph, instead of relying on the original
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.641.1">
      graph itself.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.642.1">
     Why should we try to
    </span>
    <a id="_idIndexMarker078">
    </a>
    <span class="koboSpan" id="kobo.643.1">
     learn representations?
    </span>
    <span class="koboSpan" id="kobo.643.2">
     What benefits do working with embeddings present over working with the original graph in itself?
    </span>
    <span class="koboSpan" id="kobo.643.3">
     Let’s take
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.644.1">
      a look:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.645.1">
       Scalability
      </span>
     </strong>
     <span class="koboSpan" id="kobo.646.1">
      : Traditional
     </span>
     <a id="_idIndexMarker079">
     </a>
     <span class="koboSpan" id="kobo.647.1">
      graph algorithms can become computationally expensive and impractical for large-scale graphs.
     </span>
     <span class="koboSpan" id="kobo.647.2">
      Representation learning allows compact embeddings to be generated that capture essential graph information, enabling more scalable and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.648.1">
       efficient computations.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.649.1">
       Task flexibility
      </span>
     </strong>
     <span class="koboSpan" id="kobo.650.1">
      : Representation learning produces embeddings that are task-agnostic, meaning they can be used for a variety of downstream tasks.
     </span>
     <span class="koboSpan" id="kobo.650.2">
      Traditional graph algorithms are often designed for specific problems, and adapting them to different tasks might be challenging.
     </span>
     <span class="koboSpan" id="kobo.650.3">
      Embeddings provide a more flexible and versatile way to approach
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.651.1">
       diverse tasks.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.652.1">
       Incorporating node and edge features
      </span>
     </strong>
     <span class="koboSpan" id="kobo.653.1">
      : Many real-world graphs come with additional features associated with nodes and edges.
     </span>
     <span class="koboSpan" id="kobo.653.2">
      Representation learning methods can naturally incorporate these features into the learning process, allowing for a more comprehensive understanding of the graph’s characteristics.
     </span>
     <span class="koboSpan" id="kobo.653.3">
      Traditional graph algorithms might not easily integrate
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.654.1">
       external features.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.655.1">
       Handling dynamic graphs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.656.1">
      : Representation learning is well-suited for dynamic graphs where the structure evolves.
     </span>
     <span class="koboSpan" id="kobo.656.2">
      The learned embeddings can capture temporal patterns and changes, providing a more adaptive approach compared to traditional graph algorithms, which might not inherently address
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.657.1">
       temporal aspects.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.658.1">
       Generalization to unseen data
      </span>
     </strong>
     <span class="koboSpan" id="kobo.659.1">
      : Representation learning aims to generate embeddings that generalize well to unseen data.
     </span>
     <span class="koboSpan" id="kobo.659.2">
      This is particularly useful in scenarios where the graph structure is not completely known or is subject to change.
     </span>
     <span class="koboSpan" id="kobo.659.3">
      Traditional graph algorithms may not generalize as effectively to new or unseen
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.660.1">
       graph instances.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.661.1">
       Noise robustness
      </span>
     </strong>
     <span class="koboSpan" id="kobo.662.1">
      : Embeddings can be more robust to noisy or incomplete graph data.
     </span>
     <span class="koboSpan" id="kobo.662.2">
      Traditional graph algorithms may be sensitive to noise, but representation learning methods can learn to ignore irrelevant information and focus on the most informative aspects of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.663.1">
       the graph.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.664.1">
       Integration with machine learning models
      </span>
     </strong>
     <span class="koboSpan" id="kobo.665.1">
      : Representation learning facilitates the integration of graph data with machine learning models.
     </span>
     <span class="koboSpan" id="kobo.665.2">
      The learned embeddings can serve as input features for various machine learning tasks, allowing practitioners to leverage the power of both graph-based and non-graph-based
     </span>
     <a id="_idIndexMarker080">
     </a>
     <span class="koboSpan" id="kobo.666.1">
      algorithms in a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.667.1">
       unified framework.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.668.1">
     By capturing essential information in compact embeddings, it becomes more feasible to apply machine learning
    </span>
    <a id="_idIndexMarker081">
    </a>
    <span class="koboSpan" id="kobo.669.1">
     techniques to graph-structured data and address a wide range of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.670.1">
      tasks efficiently.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-37">
    <a id="_idTextAnchor040">
    </a>
    <span class="koboSpan" id="kobo.671.1">
     GNNs and the need for a separate vertical
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.672.1">
     We won’t dive into
    </span>
    <a id="_idIndexMarker082">
    </a>
    <span class="koboSpan" id="kobo.673.1">
     the
    </span>
    <a id="_idIndexMarker083">
    </a>
    <span class="koboSpan" id="kobo.674.1">
     details of what GNNs do or how they differ from other popular neural network architectures in this chapter.
    </span>
    <span class="koboSpan" id="kobo.674.2">
     Here, we’ll merely attempt to explain why there’s a need to study GNNs separately from other deep
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.675.1">
      learning architectures.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.676.1">
     Before talking about the differences, we must discuss the similarities.
    </span>
    <span class="koboSpan" id="kobo.676.2">
     GNNs are an architecture choice that’s specialized for processing graph data and outputting representations or node embeddings.
    </span>
    <span class="koboSpan" id="kobo.676.3">
     Similar to how convolutional networks are fundamental for reading pixel data, the set of architectures under GNNs are optimized for reading graph data.
    </span>
    <span class="koboSpan" id="kobo.676.4">
     GNN-based learning tasks follow the same trajectory as other deep learning solutions: to iteratively optimize the parameters of the model so that a loss function can be minimized.
    </span>
    <span class="koboSpan" id="kobo.676.5">
     In the case of GNNs, the loss function often tries to capture and preserve meaningful information about the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.677.1">
      graph structure.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.678.1">
     Now, let’s have a look at the differences, and why GNNs require
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.679.1">
      special attention:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.680.1">
       Irregular graph structures
      </span>
     </strong>
     <span class="koboSpan" id="kobo.681.1">
      : Graphs can have irregular and varying structures, with nodes having different numbers of neighbors.
     </span>
     <span class="koboSpan" id="kobo.681.2">
      This irregularity poses challenges for traditional deep learning architectures, which often assume fixed input sizes.
     </span>
     <span class="koboSpan" id="kobo.681.3">
      For example, in a social network, individuals may have varying numbers of connections (friends, followers, and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.682.1">
       so on).
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.683.1">
       Permutation invariance
      </span>
     </strong>
     <span class="koboSpan" id="kobo.684.1">
      : The order of nodes in a graph shouldn’t affect the output of a GNN.
     </span>
     <span class="koboSpan" id="kobo.684.2">
      Achieving permutation invariance is crucial to ensure that the model can generalize across different node orders.
     </span>
     <span class="koboSpan" id="kobo.684.3">
      A good example of permutation invariance is in molecular graphs in chemistry.
     </span>
     <span class="koboSpan" id="kobo.684.4">
      The properties of a molecule depend only on its structure, not the order in which the atoms
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.685.1">
       are labeled.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.686.1">
       Graph isomorphism problem
      </span>
     </strong>
     <span class="koboSpan" id="kobo.687.1">
      : Determining whether two graphs are isomorphic is a computationally complex problem.
     </span>
     <span class="koboSpan" id="kobo.687.2">
      GNNs need to be able to capture
     </span>
     <a id="_idIndexMarker084">
     </a>
     <span class="koboSpan" id="kobo.688.1">
      and
     </span>
     <a id="_idIndexMarker085">
     </a>
     <span class="koboSpan" id="kobo.689.1">
      differentiate between different
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.690.1">
       graph structures.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.691.1">
       Node and graph classification
      </span>
     </strong>
     <span class="koboSpan" id="kobo.692.1">
      : GNNs often need to perform tasks such as node classification or graph classification.
     </span>
     <span class="koboSpan" id="kobo.692.2">
      These tasks require the model to capture both local and global information from the graph, which can
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.693.1">
       be challenging.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.694.1">
       Handling different types of edges
      </span>
     </strong>
     <span class="koboSpan" id="kobo.695.1">
      : Graphs may have different types of edges, each representing a different kind of relationship between nodes.
     </span>
     <span class="koboSpan" id="kobo.695.2">
      GNNs need to be able to model and leverage this heterogeneity in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.696.1">
       edge types.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.697.1">
       Pooling and aggregation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.698.1">
      : Aggregating information from neighbors in a graph is a fundamental operation in GNNs.
     </span>
     <span class="koboSpan" id="kobo.698.2">
      Designing effective pooling and aggregation strategies to capture important information while avoiding information loss or redundancy is a challenge.
     </span>
     <span class="koboSpan" id="kobo.698.3">
      A good example is when recommendation systems pool information from the user’s friends’ preferences.
     </span>
     <span class="koboSpan" id="kobo.698.4">
      The representations should capture this pooling idea
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.699.1">
       as well.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.700.1">
       Capturing long-range dependencies
      </span>
     </strong>
     <span class="koboSpan" id="kobo.701.1">
      : GNNs need to capture long-range dependencies in graphs.
     </span>
     <span class="koboSpan" id="kobo.701.2">
      Unlike sequential data in
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.702.1">
       recurrent neural networks
      </span>
     </strong>
     <span class="koboSpan" id="kobo.703.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.704.1">
       RNNs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.705.1">
      ), where
     </span>
     <a id="_idIndexMarker086">
     </a>
     <span class="koboSpan" id="kobo.706.1">
      dependencies are often local, graphs may have dependencies that span
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.707.1">
       long distances.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.708.1">
       Interpretable representations
      </span>
     </strong>
     <span class="koboSpan" id="kobo.709.1">
      : Understanding and interpreting the learned representations in GNNs is crucial, especially in applications where interpretability is essential.
     </span>
     <span class="koboSpan" id="kobo.709.2">
      Interpretability is crucial in medical diagnosis with electronic health records.
     </span>
     <span class="koboSpan" id="kobo.709.3">
      GNNs can be used to analyze patient records where nodes represent different health parameters.
     </span>
     <span class="koboSpan" id="kobo.709.4">
      Interpretable representations are crucial for healthcare professionals to understand and trust the model’s decision-making process in diagnosing diseases or predicting
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.710.1">
       patient outcomes.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.711.1">
     GNNs provide a lot of the benefits that machine learning approaches have in terms of boosting our capabilities with tabular data, but in terms of graph data.
    </span>
    <span class="koboSpan" id="kobo.711.2">
     There are several important implications
    </span>
    <a id="_idIndexMarker087">
    </a>
    <span class="koboSpan" id="kobo.712.1">
     of
    </span>
    <a id="_idIndexMarker088">
    </a>
    <span class="koboSpan" id="kobo.713.1">
     using GNNs as an intermediary step to solve relevant problems related to graphs.
    </span>
    <span class="koboSpan" id="kobo.713.2">
     We’ll explore more such topics in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.714.1">
      coming chapters.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-38">
    <a id="_idTextAnchor041">
    </a>
    <span class="koboSpan" id="kobo.715.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.716.1">
     In this chapter, we covered the foundational concepts in graph learning and representation.
    </span>
    <span class="koboSpan" id="kobo.716.2">
     We began with motivating examples of how graph structures naturally capture relationships between entities, making them a powerful data representation.
    </span>
    <span class="koboSpan" id="kobo.716.3">
     Then, formal definitions of graphs, common graph types, and key properties were discussed.
    </span>
    <span class="koboSpan" id="kobo.716.4">
     We also looked at popular graph algorithms such as searching, partitioning, and path optimization, along with their real-world
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.717.1">
      use cases.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.718.1">
     A key idea presented here was the need for representation learning on graphs.
    </span>
    <span class="koboSpan" id="kobo.718.2">
     Converting graph data into vector embeddings allows us to leverage the capabilities of machine learning models.
    </span>
    <span class="koboSpan" id="kobo.718.3">
     Benefits such as scalability, flexibility, and robustness make graph embeddings an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.719.1">
      enabling technique.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.720.1">
     Finally, we justified the need for specialized GNN architectures.
    </span>
    <span class="koboSpan" id="kobo.720.2">
     Factors such as irregular structure, permutation invariance, and complex operations such as aggregation and pooling necessitate tailored solutions.
    </span>
    <span class="koboSpan" id="kobo.720.3">
     GNNs open up new possibilities for learning from relational data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.721.1">
      across domains.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.722.1">
     In the next chapter, we’ll discuss how graph learning is applied in practice.
    </span>
    <span class="koboSpan" id="kobo.722.2">
     There are several levels to graph learning and representation, and all of them have business and academic significance.
    </span>
    <span class="koboSpan" id="kobo.722.3">
     The topics covered here will act as a foundation for your understanding of the concepts in the chapters
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.723.1">
      that follow.
     </span>
    </span>
   </p>
  </div>
 </body></html>