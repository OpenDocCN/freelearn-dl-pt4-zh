["```py\ndef fibonacci(n):\n    \"\"\"\n    Returns the n-th number in the Fibonacci sequence.\n\n    Parameters\n    ----------\n    n: int\n       The n-th number in the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n```", "```py\nfibonacci(5) = fibonacci(4) + fibonacci(3)\nfibonacci(5) = (fibonacci(3) + fibonacci(2)) + (fibonacci(2) + fibonacci(1))\nfibonacci(5) = ((fibonacci(2) + fibonacci(1)) + (fibonacci(1) + fibonacci(0))) + ((fibonacci(1) + fibonacci(0)) + fibonacci(1))\nfibonacci(5) = (((fibonacci(1) + fibonacci(0)) + fibonacci(1)) + (fibonacci(1) + fibonacci(0))) + ((fibonacci(1) + fibonacci(0)) + fibonacci(1))\n```", "```py\ncache = {0: 0, 1: 1} # Initialize the first two values.\ndef fibonacci(n):\n    \"\"\"\n    Returns the n-th number in the Fibonacci sequence.\n\n    Parameters\n    ----------\n    n: int\n       The n-th number in the Fibonacci sequence.\n    \"\"\"\n     try:\n         return cache[n]\n     except KeyError:\n         fib = fibonacci(n-1) + fibonacci(n-2)\n         cache[n] = fib \n         return fib\n```", "```py\ncache = [0, 1]   # Initialize with the first two terms of Fibonacci series.\ndef fibonacci(n):\n    \"\"\"\n    Returns the n-th number in the Fibonacci sequence.\n\n    Parameters\n    ----------\n    n: int\n       The n-th number in the Fibonacci sequence.\n    \"\"\"\n    for i in range(2, n):\n        cache.append(cache[i-1] + cache[i-2])\n    return cache[-1]\n```", "```py\nimport numpy as np\n\ntransition_matrix = np.array([[0.33, 0.33,    0,    0,    0, 0.33,    0,    0,    0,    0,    0,    0,    0],\n              [0.33, 0.33, 0.33,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0],\n              [   0, 0.25, 0.25, 0.25,    0,    0, 0.25,    0,    0,    0,    0,    0,    0],\n              [   0,    0, 0.33, 0.33, 0.33,    0,    0,    0,    0,    0,    0,    0,    0],\n              [   0,    0,    0, 0.33, 0.33,    0,    0, 0.33,    0,    0,    0,    0,    0],\n              [0.33,    0,    0,    0,    0, 0.33,    0,    0, 0.33,    0,    0,    0,    0],\n              [   0,    0, 0.33,    0,    0,    0, 0.33,    0,    0,    0, 0.33,    0,    0],\n              [   0,    0,    0,    0, 0.33,    0,    0, 0.33,    0,    0,    0,    0, 0.33],\n              [   0,    0,    0,    0,    0, 0.33,    0,    0, 0.33, 0.33,    0,    0,    0],\n              [   0,    0,    0,    0,    0,    0,    0,    0, 0.33, 0.33, 0.33,    0,    0],\n              [   0,    0,    0,    0,    0,    0,    0,    0,    0, 0.33, 0.33, 0.33,    0],\n              [   0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 0.33, 0.33, 0.33],\n              [   0,    0,    0,    0,    0,    0,    0, 0.33,    0,    0,    0, 0.33, 0.33]])\n```", "```py\nemission = np.array([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])\n```", "```py\ninit_prob = np.array([0.077, 0.077, 0.077, 0.077, 0.077, 0.077, 0.077,\n                      0.077, 0.077, 0.077, 0.077, 0.077, 0.077])\n```", "```py\ndef forward(obs, transition, emission, init):\n    \"\"\"\n    Runs forward algorithm on the HMM.\n\n    Parameters\n    ----------\n    obs:        1D list, array-like\n                The list of observed states.\n\n    transition: 2D array-like\n                The transition probability of the HMM.\n                size = {n_states x n_states}\n\n    emission:   1D array-like\n                The emission probability of the HMM.\n                size = {n_states}\n\n    init:       1D array-like\n                The initial probability of HMM.\n                size = {n_states}\n\n    Returns\n    -------\n    float: Probability value for the obs to occur.\n    \"\"\"\n    n_states = transition.shape[0]\n    fwd = [{}]\n\n    for i in range(n_states):\n        fwd[0][y] = init[i] * emission[obs[0]]\n    for t in range(1, len(obs)):\n        fwd.append({})\n        for i in range(n_states):\n            fwd[t][i] = sum((fwd[t-1][y0] * transition[y0][i] * emission[obs[t]]) for y0 in \n                                    range(n_states))\n    prob = sum((fwd[len(obs) - 1][s]) for s in range(n_states))\n    return prob\n```", "```py\n>>> obs = [0, 0, 0, 0] # Staying in the same location\n>>> forward(obs, transition_matrix, emission, init_prob)\n0.97381776799999997\n\n>>> obs = [0, 10, 8, 6] # Should be 0 because can't jump from state 0 to 10.\n>>> forward(obs, transition_matrix, emission, init_prob)\n0.0\n```", "```py\ndef backward(obs, transition, emission, init):\n    \"\"\"\n    Runs backward algorithm on the HMM.\n\n    Parameters\n    ----------\n    obs:        1D list, array-like\n                The list of observed states.\n\n    transition: 2D array-like\n                The transition probability of the HMM.\n                size = {n_states x n_states}\n\n    emission:   1D array-like\n                The emission probabilitiy of the HMM.\n                size = {n_states}\n\n    init:       1D array-like\n                The initial probability of HMM.\n                size = {n_states}\n\n    Returns\n    -------\n    float: Probability value for the obs to occur.\n    \"\"\"\n    n_states = transition.shape[0]\n    bkw = [{} for t in range(len(obs))]\n    T = len(obs)\n\n    for y in range(n_states):\n        bkw[T-1][y] = 1\n    for t in reversed(range(T-1)):\n        for y in range(n_states):\n            bkw[t][y] = sum((bkw[t+1][y1] * transition[y][y1] * emission[obs[t+1]]) for y1 in \n                                    range(n_states))\n    prob = sum((init[y] * emission[obs[0]] * bkw[0][y]) for y in range(n_states))\n    return prob\n```", "```py\n>>> obs = [0, 0, 0, 0] # Staying in the same location\n>>> backward(obs, transition_matrix, emission, init_prob)\n0.97381776799999997\n\n>>> obs = [0, 10, 8, 6] # Should be 0 because can't jump from state 0 to 10.\n>>> backward(obs, transition_matrix, emission, init_prob)\n0.0\n```", "```py\nimport numpy as np\n\ndef viterbi(obs, transition, emission, init=None):\n    \"\"\"\n    Return the MAP estimate of state trajectory of Hidden Markov Model.\n\n    Parameters\n    ----------\n    y : array (T,)\n        Observation state sequence. int dtype.\n\n    transition : array (K, K)\n        State transition matrix. See HiddenMarkovModel.state_transition for\n        details.\n\n    emission : array (K,)\n        Emission matrix. See HiddenMarkovModel.emission for details.\n\n    init: optional, (K,)\n        Initial state probabilities: Pi[i] is the probability x[0] == i. If\n        None, uniform initial distribution is assumed (Pi[:] == 1/K).\n\n    Returns\n    -------\n    x : array (T,)\n        Maximum a posteriori probability estimate of hidden state trajectory,\n        conditioned on observation sequence y under the model parameters.\n\n    T1: array (K, T)\n        the probability of the most likely path so far\n\n    T2: array (K, T)\n        the x_j-1 of the most likely path so far\n    \"\"\"\n    # Cardinality of the state space\n    K = transition.shape[0]\n\n    emission = np.repeat(emission[np.newaxis, :], K, axis=0)\n\n    # Initialize the priors with default (uniform dist) if not given by caller\n    init = init if init is not None else np.full(K, 1 / K)\n    T = len(obs)\n    T1 = np.empty((K, T), 'd')\n    T2 = np.empty((K, T), 'B')\n\n    # Initilaize the tracking tables from first observation\n    T1[:, 0] = init * emission[:, obs[0]]\n    T2[:, 0] = 0\n\n    # Iterate throught the observations updating the tracking tables\n    for i in range(1, T):\n        T1[:, i] = np.max(T1[:, i - 1] * transition.T * emission[np.newaxis, :, obs[i]].T, 1)\n        T2[:, i] = np.argmax(T1[:, i - 1] * transition.T, 1)\n\n    # Build the output, optimal model trajectory\n    x = np.empty(T, 'B')\n    x[-1] = np.argmax(T1[:, T - 1])\n    for i in reversed(range(1, T)):\n        x[i - 1] = T2[x[i], i]\n\n    return x, T1, T2\n```", "```py\n>>> x, T1, T2 = viterbi([0, 0, 0, 0], transition_matrix, emission, init_prob)\n>>> print(x)\narray([0, 0, 0, 0], dtype=uint8)\n>>> print(T1)\narray([[ 0.077, 0.02541, 0.0083853, 0.00276715],\n       [ 0.077, 0.02541, 0.0083853, 0.00276715],\n       [ 0.077, 0.02541, 0.0083853, 0.00276715],\n       [ 0.077, 0.02541, 0.0083853, 0.00276715],\n       [ 0.077, 0.02541, 0.0083853, 0.00276715],\n       [ 0.077, 0.02541, 0.0083853, 0.00276715],\n       [ 0.077, 0.02541, 0.0083853, 0.00276715],\n       [ 0.077, 0.02541, 0.0083853, 0.00276715],\n       [ 0.077, 0.02541, 0.0083853, 0.00276715],\n       [ 0.077, 0.02541, 0.0083853, 0.00276715],\n       [ 0.077, 0.02541, 0.0083853, 0.00276715],\n       [ 0.077, 0.02541, 0.0083853, 0.00276715],\n       [ 0.077, 0.02541, 0.0083853, 0.00276715]])\n>>> print(T2)\narray([[ 0, 0, 0, 0],\n       [ 0, 0, 0, 0],\n       [ 0, 1, 1, 1],\n       [ 0, 3, 3, 3],\n       [ 0, 3, 3, 3],\n       [ 0, 0, 0, 0],\n       [ 0, 6, 6, 6],\n       [ 0, 4, 4, 4],\n       [ 0, 5, 5, 5],\n       [ 0, 8, 8, 8],\n       [ 0, 6, 6, 6],\n       [ 0, 10, 10, 10],\n       [ 0, 7, 7, 7]], dtype=uint8)\n\n>>> x, T1, T2 = viterbi([0, 10, 8, 6], transition_matrix, emission, init_prob)\n>>> print(x)\narray([0, 0, 0, 0], dtype=uint8)\n>>> print(T1)\narray([[ 0.077, 0., 0., 0\\. ],\n       [ 0.077, 0., 0., 0\\. ],\n       [ 0.077, 0., 0., 0\\. ],\n       [ 0.077, 0., 0., 0\\. ],\n       [ 0.077, 0., 0., 0\\. ],\n       [ 0.077, 0., 0., 0\\. ],\n       [ 0.077, 0., 0., 0\\. ],\n       [ 0.077, 0., 0., 0\\. ],\n       [ 0.077, 0., 0., 0\\. ],\n       [ 0.077, 0., 0., 0\\. ],\n       [ 0.077, 0., 0., 0\\. ],\n       [ 0.077, 0., 0., 0\\. ],\n       [ 0.077, 0., 0., 0\\. ]])\n\n>>> print(T2)\narray([[ 0, 0, 0, 0],\n       [ 0, 0, 0, 0],\n       [ 0, 1, 0, 0],\n       [ 0, 3, 0, 0],\n       [ 0, 3, 0, 0],\n       [ 0, 0, 0, 0],\n       [ 0, 6, 0, 0],\n       [ 0, 4, 0, 0],\n       [ 0, 5, 0, 0],\n       [ 0, 8, 0, 0],\n       [ 0, 6, 0, 0],\n       [ 0, 10, 0, 0],\n       [ 0, 7, 0, 0]], dtype=uint8)\n```"]