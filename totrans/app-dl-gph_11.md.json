["```py\n        def construct_graph(network_data):\n            # devices, users, IP addresses\n            nodes = create_nodes(network_data)\n            # communications, access events\n            edges = create_edges(network_data)\n            for node in nodes:\n                # device type, software, user role\n                node.features = extract_node_features(node)\n            for edge in edges:\n                # protocol, data volume, timestamp\n                edge.features = extract_edge_features(edge)\n            return Graph(nodes, edges)\n        ```", "```py\n        class APTDetectionGNN(nn.Module):\n            def __init__(self, in_features, hidden_features,\n                         num_layers):\n                super().__init__()\n                self.gat_layers = nn.ModuleList([\n                    GATConv(in_features if i == 0 else hidden_features, \n                            hidden_features\n                    )for i in range(num_layers)\n                ])\n                self.gru = nn.GRU(hidden_features, hidden_features)\n                self.output = nn.Linear(hidden_features, 1)\n            def forward(self, x, edge_index, edge_attr):\n                for gat in self.gat_layers:\n                    x = F.relu(gat(x, edge_index, edge_attr))\n                x, _ = self.gru(x.unsqueeze(0))\n                return self.output(x.squeeze(0)).squeeze(-1)\n        ```", "```py\n    def train_model(model, labeled_data, unlabeled_data, \n                    num_epochs=10):\n        optimizer = torch.optim.Adam(model.parameters())\n\n        for epoch in range(num_epochs):\n            model.train()\n\n            # Supervised learning\n            optimizer.zero_grad()\n            x, edge_index, edge_attr, y = labeled_data\n            out = model(x, edge_index, edge_attr)\n            loss = F.binary_cross_entropy_with_logits(out, y)\n            loss.backward()\n            optimizer.step()\n\n            # Print training progress\n            if epoch % 2 == 0:\n                print(f\"Epoch {epoch}, Loss: {loss.item():.4f}\")\n    ```", "```py\n        def detect_apts(model, graph, threshold=0.5):\n            model.eval()\n            with torch.no_grad():\n                x, edge_index, edge_attr, _ = graph\n                anomaly_scores = torch.sigmoid(model(\n                    x, edge_index, edge_attr))\n                suspicious_nodes = (\n                    anomaly_scores > threshold\n                ).nonzero().flatten()\n\n                results = []\n                for node in suspicious_nodes:\n                    attention_weights = model.get_attention_ weights(\n                        node)\n                    results.append({\n                        'node': node.item(),\n                        'score': anomaly_scores[node].item(),\n                        'attention': attention_weights\n                    })\n\n                return results\n        ```"]