["```py\nInstall.packages(\"reticulate\") \n\n```", "```py\nuse_condaenv(\"python27\") \nmidi <- import_from_path(\"midi\",path=\"C:/ProgramData/Anaconda2/Lib/site-packages\") \nnp <- import(\"numpy\") \nmsgpack <- import_from_path(\"msgpack\",path=\"C:/ProgramData/Anaconda2/Lib/site-packages\") \npsys <- import(\"sys\") \ntqdm <- import_from_path(\"tqdm\",path=\"C:/ProgramData/Anaconda2/Lib/site-packages\") \nmidi_manipulation_updated <- import_from_path(\"midi_manipulation_updated\",path=\"C:/Music_RBM\") \nglob <- import(\"glob\") \n\n```", "```py\nget_input_songs <- function(path){ \n  files = glob$glob(paste0(path,\"/*mid*\")) \n  songs <- list() \n  count <- 1 \n  for(f in files){ \n    songs[[count]] <- np$array(midi_manipulation_updated$midiToNoteStateMatrix(f)) \n    count <- count+1 \n  } \n  return(songs) \n} \npath <- 'Pop_Music_Midi' \ninput_songs <- get_input_songs(path) \n\n```", "```py\nlowest_note = 24L \nhighest_note = 102L \nnote_range = highest_note-lowest_note \n\n```", "```py\nnum_timesteps  = 15L \nnum_input      = 2L*note_range*num_timesteps \nnum_hidden       = 50L \n\n```", "```py\nalpha<-0.1 \n\n```", "```py\nvb <- tf$placeholder(tf$float32, shape = shape(num_input)) \nhb <- tf$placeholder(tf$float32, shape = shape(num_hidden)) \nW <- tf$placeholder(tf$float32, shape = shape(num_input, num_hidden)) \n\n```", "```py\nX = tf$placeholder(tf$float32, shape=shape(NULL, num_input)) \nprob_h0= tf$nn$sigmoid(tf$matmul(X, W) + hb)   \nh0 = tf$nn$relu(tf$sign(prob_h0 - tf$random_uniform(tf$shape(prob_h0)))) \n\n```", "```py\nprob_v1 = tf$matmul(h0, tf$transpose(W)) + vb \nv1 = prob_v1 + tf$random_normal(tf$shape(prob_v1), mean=0.0, stddev=1.0, dtype=tf$float32) \nh1 = tf$nn$sigmoid(tf$matmul(v1, W) + hb)     \n\n```", "```py\nw_pos_grad = tf$matmul(tf$transpose(X), h0) \nw_neg_grad = tf$matmul(tf$transpose(v1), h1) \nCD = (w_pos_grad - w_neg_grad) / tf$to_float(tf$shape(X)[0]) \nupdate_w = W + alpha * CD \nupdate_vb = vb + alpha * tf$reduce_mean(X - v1) \nupdate_hb = hb + alpha * tf$reduce_mean(h0 - h1) \n\n```", "```py\nerr = tf$reduce_mean(tf$square(X - v1)) \n\n```", "```py\ncur_w = tf$Variable(tf$zeros(shape = shape(num_input, num_hidden), dtype=tf$float32)) \ncur_vb = tf$Variable(tf$zeros(shape = shape(num_input), dtype=tf$float32)) \ncur_hb = tf$Variable(tf$zeros(shape = shape(num_hidden), dtype=tf$float32)) \nprv_w = tf$Variable(tf$random_normal(shape=shape(num_input, num_hidden), stddev=0.01, dtype=tf$float32)) \nprv_vb = tf$Variable(tf$zeros(shape = shape(num_input), dtype=tf$float32)) \nprv_hb = tf$Variable(tf$zeros(shape = shape(num_hidden), dtype=tf$float32)) \n\n```", "```py\nsess$run(tf$global_variables_initializer()) \nsong = np$array(trainX) \nsong = song[1:(np$floor(dim(song)[1]/num_timesteps)*num_timesteps),] \nsong = np$reshape(song, newshape=shape(dim(song)[1]/num_timesteps, dim(song)[2]*num_timesteps)) \noutput <- sess$run(list(update_w, update_vb, update_hb), feed_dict = dict(X=song, \n                                                                          W = prv_w$eval(), \n                                                                          vb = prv_vb$eval(), \n                                                                          hb = prv_hb$eval())) \nprv_w <- output[[1]]  \nprv_vb <- output[[2]] \nprv_hb <-  output[[3]] \nsess$run(err, feed_dict=dict(X= song, W= prv_w, vb= prv_vb, hb= prv_hb)) \n\n```", "```py\nepochs=200 \nerrors <- list() \nweights <- list() \nu=1 \nfor(ep in 1:epochs){ \n  for(i in seq(0,(dim(song)[1]-100),100)){ \n    batchX <- song[(i+1):(i+100),] \n    output <- sess$run(list(update_w, update_vb, update_hb), feed_dict = dict(X=batchX, \n                                                                              W = prv_w, \n                                                                              vb = prv_vb, \n                                                                              hb = prv_hb)) \n    prv_w <- output[[1]]  \n    prv_vb <- output[[2]] \n    prv_hb <-  output[[3]] \n    if(i%%500 == 0){ \n      errors[[u]] <- sess$run(err, feed_dict=dict(X= song, W= prv_w, vb= prv_vb, hb= prv_hb)) \n      weights[[u]] <- output[[1]] \n      u <- u+1 \n      cat(i , \" : \") \n    } \n  } \n  cat(\"epoch :\", ep, \" : reconstruction error : \", errors[length(errors)][[1]],\"\\n\") \n} \n\n```", "```py\nhh0 = tf$nn$sigmoid(tf$matmul(X, W) + hb) \nvv1 = tf$nn$sigmoid(tf$matmul(hh0, tf$transpose(W)) + vb) \nfeed = sess$run(hh0, feed_dict=dict( X= sample_image, W= prv_w, hb= prv_hb)) \nrec = sess$run(vv1, feed_dict=dict( hh0= feed, W= prv_w, vb= prv_vb)) \nS = np$reshape(rec[1,],newshape=shape(num_timesteps,2*note_range)) \n\n```", "```py\nmidi_manipulation$noteStateMatrixToMidi(S, name=paste0(\"generated_chord_1\")) \ngenerated_chord_1 \n\n```"]