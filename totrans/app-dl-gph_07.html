<html><head></head><body>
  <div id="_idContainer286">
   <h1 class="chapter-number" id="_idParaDest-128">
    <a id="_idTextAnchor131">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     7
    </span>
   </h1>
   <h1 id="_idParaDest-129">
    <a id="_idTextAnchor132">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Graph Deep Learning in Practice
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     Having explored the theoretical aspects of graph deep learning in the previous chapters, now is a good time to get our hands dirty by diving into its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      practical applications.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     Social networks have become an integral part of our digital lives, generating vast amounts of data that can provide valuable insights into human behavior, relationships, and social dynamics.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     Graph deep learning offers powerful tools to analyze and extract meaningful information from these complex networks.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     In this chapter, we will explore practical applications of graph deep learning techniques to social network analysis
    </span>
    <a id="_idIndexMarker459">
    </a>
    <span class="koboSpan" id="kobo.6.1">
     using
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.7.1">
      PyTorch
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.8.1">
       Geometric
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.9.1">
      (
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.10.1">
       PyG
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.11.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.12.1">
     Here, we will focus on a hypothetical dataset representing a social network of university students.
    </span>
    <span class="koboSpan" id="kobo.12.2">
     This example will demonstrate how graph-based machine learning can be applied to real-world scenarios, such as predicting user interests, recommending new connections, and identifying
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.13.1">
      community structures.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.14.1">
     Our dataset consists of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.15.1">
      following elements:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.16.1">
       Nodes
      </span>
     </strong>
     <span class="koboSpan" id="kobo.17.1">
      : Each node
     </span>
     <a id="_idIndexMarker460">
     </a>
     <span class="koboSpan" id="kobo.18.1">
      represents a student in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.19.1">
       the university.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.20.1">
       Edges
      </span>
     </strong>
     <span class="koboSpan" id="kobo.21.1">
      : Edges between nodes represent friendships or connections
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.22.1">
       between students.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.23.1">
       Node features
      </span>
     </strong>
     <span class="koboSpan" id="kobo.24.1">
      : Each student (node) has associated features, including
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       the following:
      </span>
     </span>
     <ul>
      <li>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.26.1">
         Age
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.27.1">
        Year
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.28.1">
         of study
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.29.1">
        Academic major (encoded as a
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.30.1">
         one-hot vector)
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.31.1">
       Node labels
      </span>
     </strong>
     <span class="koboSpan" id="kobo.32.1">
      : Each student is assigned to one of five interest groups, which we’ll use for our node
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.33.1">
       classification task.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.34.1">
     Throughout this chapter, we will tackle two
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.35.1">
      main tasks:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.36.1">
       Node classification
      </span>
     </strong>
     <span class="koboSpan" id="kobo.37.1">
      : We’ll predict student interests based on their features and connections within the network.
     </span>
     <span class="koboSpan" id="kobo.37.2">
      This task demonstrates how
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.38.1">
       graph neural networks
      </span>
     </strong>
     <span class="koboSpan" id="kobo.39.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.40.1">
       GNNs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.41.1">
      ) can
     </span>
     <a id="_idIndexMarker461">
     </a>
     <span class="koboSpan" id="kobo.42.1">
      leverage both node attributes and network structure to make predictions about
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.43.1">
       individual nodes.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.44.1">
       Link prediction
      </span>
     </strong>
     <span class="koboSpan" id="kobo.45.1">
      : We’ll develop a model to recommend new friendships by predicting potential edges in the graph.
     </span>
     <span class="koboSpan" id="kobo.45.2">
      This showcases how graph deep learning can be used for recommendation systems and network
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.46.1">
       growth prediction.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     We’ll implement these tasks using state-of-the-art GNN architectures.
    </span>
    <span class="koboSpan" id="kobo.47.2">
     Additionally, we’ll visualize our results to gain intuitive insights into the network structure and our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.48.1">
      model’s performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.49.1">
     By the end of this chapter, you’ll have a practical understanding of how to apply graph deep learning techniques to social network data, interpret the results, and adapt these methods to your own projects.
    </span>
    <span class="koboSpan" id="kobo.49.2">
     While we use a synthetic dataset for demonstration, the techniques covered here can be readily applied to real-world social
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      network data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.51.1">
     Let’s begin our journey into the practical world of graph deep learning for social network analysis!
    </span>
    <span class="koboSpan" id="kobo.51.2">
     We will be exploring the following topics
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.52.1">
      at length:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.53.1">
      Setting up
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.54.1">
       the environment
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.55.1">
      Creating the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.56.1">
       graph dataset
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.57.1">
      Node classification – predicting
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.58.1">
       student interests
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.59.1">
      Link prediction – recommending
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.60.1">
       new friendships
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-130">
    <a id="_idTextAnchor133">
    </a>
    <span class="koboSpan" id="kobo.61.1">
     Setting up the environment
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.62.1">
     Before we dive into
    </span>
    <a id="_idIndexMarker462">
    </a>
    <span class="koboSpan" id="kobo.63.1">
     the implementation of our graph deep learning models, it’s crucial to set up our development environment with the necessary libraries and tools.
    </span>
    <span class="koboSpan" id="kobo.63.2">
     In this section, we’ll cover the essential imports and explain their roles in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.64.1">
      our project.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     First, let’s start by importing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.66.1">
      required libraries:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.67.1">
import torch
import torch_geometric
from torch_geometric.data import Data
from torch_geometric.nn import GCNConv, GAE
from torch_geometric.utils import train_test_split_edges
from torch_geometric.transforms import RandomLinkSplit
from sklearn.manifold import TSNE
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import networkx as nx
from sklearn.metrics import roc_auc_score</span></pre>
   <p>
    <span class="koboSpan" id="kobo.68.1">
     Let’s break down these imports
    </span>
    <a id="_idIndexMarker463">
    </a>
    <span class="koboSpan" id="kobo.69.1">
     and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.70.1">
      their purposes:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.71.1">
       torch
      </span>
     </strong>
     <span class="koboSpan" id="kobo.72.1">
      : The core PyTorch library used for tensor operations and building
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.73.1">
       neural networks
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.74.1">
       torch_geometric
      </span>
     </strong>
     <span class="koboSpan" id="kobo.75.1">
      : PyG, an extension library to PyTorch for deep learning on graphs and other
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.76.1">
       irregular structures
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.77.1">
       torch_geometric.data.Data
      </span>
     </strong>
     <span class="koboSpan" id="kobo.78.1">
      : A class used to create graph data objects in PyG that hold node features, edge indices,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.79.1">
       and labels
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.80.1">
       torch_geometric.nn.GCNConv
      </span>
     </strong>
     <span class="koboSpan" id="kobo.81.1">
      : The
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.82.1">
       graph convolutional network
      </span>
     </strong>
     <span class="koboSpan" id="kobo.83.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.84.1">
       GCN
      </span>
     </strong>
     <span class="koboSpan" id="kobo.85.1">
      ) layer, used for
     </span>
     <a id="_idIndexMarker464">
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.86.1">
       node classification
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.87.1">
       torch_geometric.nn.GAE
      </span>
     </strong>
     <span class="koboSpan" id="kobo.88.1">
      : The
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.89.1">
       graph autoencoder
      </span>
     </strong>
     <span class="koboSpan" id="kobo.90.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.91.1">
       GAE
      </span>
     </strong>
     <span class="koboSpan" id="kobo.92.1">
      ), used
     </span>
     <a id="_idIndexMarker465">
     </a>
     <span class="koboSpan" id="kobo.93.1">
      for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.94.1">
       link prediction
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.95.1">
       torch_geometric.utils.train_test_split_edges
      </span>
     </strong>
     <span class="koboSpan" id="kobo.96.1">
      : A utility function that helps split the graph data for link
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.97.1">
       prediction tasks
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.98.1">
       torch_geometric.transforms.RandomLinkSplit
      </span>
     </strong>
     <span class="koboSpan" id="kobo.99.1">
      : A transform used to prepare the data for link prediction by splitting it into train, validation, and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.100.1">
       test sets
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.101.1">
       sklearn.manifold.TSNE
      </span>
     </strong>
     <span class="koboSpan" id="kobo.102.1">
      :
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.103.1">
       t-Distributed Stochastic Neighbor Embedding
      </span>
     </strong>
     <span class="koboSpan" id="kobo.104.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.105.1">
       t-SNE
      </span>
     </strong>
     <span class="koboSpan" id="kobo.106.1">
      ), used for
     </span>
     <a id="_idIndexMarker466">
     </a>
     <span class="koboSpan" id="kobo.107.1">
      dimensionality reduction when visualizing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.108.1">
       node embeddings
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.109.1">
       sklearn.cluster.KMeans
      </span>
     </strong>
     <span class="koboSpan" id="kobo.110.1">
      : Used for clustering node embeddings to identify
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.111.1">
       social groups
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.112.1">
       matplotlib.pyplot
      </span>
     </strong>
     <span class="koboSpan" id="kobo.113.1">
      : A library used for creating visualizations of graphs
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.114.1">
       and results
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.115.1">
       networkx
      </span>
     </strong>
     <span class="koboSpan" id="kobo.116.1">
      : A library providing additional tools for working with graphs, used for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.117.1">
       some visualizations
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.118.1">
     Make sure you have all these libraries installed in your Python environment.
    </span>
    <span class="koboSpan" id="kobo.118.2">
     You can install them
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.119.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.120.1">
       pip
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.121.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.122.1">
pip install torch torch_geometric scikit-learn matplotlib networkx</span></pre>
   <p>
    <span class="koboSpan" id="kobo.123.1">
     Note that the installation of PyG (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.124.1">
      torch_geometric
     </span>
    </strong>
    <span class="koboSpan" id="kobo.125.1">
     ) might require additional steps depending on your system and CUDA version.
    </span>
    <span class="koboSpan" id="kobo.125.2">
     Please refer to the official documentation for detailed installation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.126.1">
      instructions:
     </span>
    </span>
    <a href="https://pytorch-geometric.readthedocs.io/en/latest/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.127.1">
       https://pytorch-geometric.readthedocs.io/en/latest/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.128.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.129.1">
     With these libraries
    </span>
    <a id="_idIndexMarker467">
    </a>
    <span class="koboSpan" id="kobo.130.1">
     imported, we’re now ready to start working with our social network data and implementing our graph deep
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.131.1">
      learning models.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-131">
    <a id="_idTextAnchor134">
    </a>
    <span class="koboSpan" id="kobo.132.1">
     Creating the graph dataset
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.133.1">
     The next step is to
    </span>
    <a id="_idIndexMarker468">
    </a>
    <span class="koboSpan" id="kobo.134.1">
     create a synthetic social network dataset to demonstrate our graph deep learning techniques.
    </span>
    <span class="koboSpan" id="kobo.134.2">
     While real-world data would be ideal, using synthetic data allows us to focus on the implementation and understanding of the algorithms without the complexities of data acquisition
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.135.1">
      and preprocessing.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.136.1">
     Here, we will create a social network dataset representing university students.
    </span>
    <span class="koboSpan" id="kobo.136.2">
     The complete code can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.137.1">
      at
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Applied-Deep-Learning-on-Graphs">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.138.1">
       https://github.com/PacktPublishing/Applied-Deep-Learning-on-Graphs
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.139.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.140.1">
     Let’s break down this code and explain
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      each part.
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.142.1">
      We set a random seed
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.143.1">
       for reproducibility:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.144.1">
torch.manual_seed(42)</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.145.1">
       This ensures that we generate the same “random” data each time we run
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.146.1">
        the code.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.147.1">
      We define our
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.148.1">
       dataset parameters:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.149.1">
num_nodes = 1000
num_features = 10
num_classes = 5</span></pre>
     <ul>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.150.1">
         num_nodes
        </span>
       </strong>
       <span class="koboSpan" id="kobo.151.1">
        is the number of students (nodes) in
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.152.1">
         our network.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.153.1">
         num_features
        </span>
       </strong>
       <span class="koboSpan" id="kobo.154.1">
        is the number of features for each student.
       </span>
       <span class="koboSpan" id="kobo.154.2">
        We’re using 10 features to represent age, year of study, and 8 possible
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.155.1">
         academic majors.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.156.1">
         num_classes
        </span>
       </strong>
       <span class="koboSpan" id="kobo.157.1">
        is the number of different interest groups, which will be our target for
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.158.1">
         node classification.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <span class="koboSpan" id="kobo.159.1">
      We create node
     </span>
     <a id="_idIndexMarker469">
     </a>
     <span class="koboSpan" id="kobo.160.1">
      features (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.161.1">
       x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.162.1">
      )
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.163.1">
       using
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.164.1">
        torch.randn()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.165.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.166.1">
x = torch.randn((num_nodes, num_features))</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.167.1">
       This generates a tensor of size
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.168.1">
        (num_nodes, num_features)
       </span>
      </strong>
      <span class="koboSpan" id="kobo.169.1">
       filled with random values from a standard normal distribution.
      </span>
      <span class="koboSpan" id="kobo.169.2">
       In a real dataset, these features would be actual attributes of
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.170.1">
        the students.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.171.1">
      We create edges (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.172.1">
       edge_index
      </span>
     </strong>
     <span class="koboSpan" id="kobo.173.1">
      )
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.174.1">
       using
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.175.1">
        torch.randint()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.176.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.177.1">
edge_index = torch.randint(0, num_nodes, (2, 5000))</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.178.1">
       This generates 5,000 random edges between nodes.
      </span>
      <span class="koboSpan" id="kobo.178.2">
       The
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.179.1">
        edge_index
       </span>
      </strong>
      <span class="koboSpan" id="kobo.180.1">
       tensor has the shape
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.181.1">
        (2, 5000)
       </span>
      </strong>
      <span class="koboSpan" id="kobo.182.1">
       , where each column represents an edge with
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.183.1">
        [
       </span>
      </strong>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.184.1">
         source_node, target_node]
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.185.1">
        .
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.186.1">
      We create node labels (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.187.1">
       y
      </span>
     </strong>
     <span class="koboSpan" id="kobo.188.1">
      )
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.189.1">
       using
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.190.1">
        torch.randint()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.191.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.192.1">
y = torch.randint(0, num_classes, (num_nodes,))</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.193.1">
       This assigns each node (student) to one of the five interest
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.194.1">
        groups randomly.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.195.1">
      We create a PyG
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.196.1">
       Data
      </span>
     </strong>
     <span class="koboSpan" id="kobo.197.1">
      object, which efficiently holds our graph data.
     </span>
     <span class="koboSpan" id="kobo.197.2">
      We pass in our node features (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.198.1">
       x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.199.1">
      ), edge indices (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.200.1">
       edge_index
      </span>
     </strong>
     <span class="koboSpan" id="kobo.201.1">
      ), and node
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.202.1">
       labels (
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.203.1">
        y
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.204.1">
       ):
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.205.1">
data = Data(x=x, edge_index=edge_index, y=y)
data.num_classes = num_classes</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.206.1">
      Finally, we print some information about our dataset to verify
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.207.1">
       its structure:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.208.1">
print(f"Number of nodes: {data.num_nodes}")
print(f"Number of edges: {data.num_edges}")
print(f"Number of node features: {data.num_node_features}")
print(f"Number of classes: {data.num_classes}")</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.209.1">
     This synthetic dataset
    </span>
    <a id="_idIndexMarker470">
    </a>
    <span class="koboSpan" id="kobo.210.1">
     now represents a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.211.1">
      social network:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.212.1">
      Each
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.213.1">
       node
      </span>
     </em>
     <span class="koboSpan" id="kobo.214.1">
      is a student with 10 features (representing attributes such as age, year,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.215.1">
       and major).
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.216.1">
       Edges
      </span>
     </em>
     <span class="koboSpan" id="kobo.217.1">
      represent friendships
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.218.1">
       between students.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.219.1">
      Each student belongs to one of five
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.220.1">
       interest groups.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.221.1">
     The output of the code will be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.222.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.223.1">
Number of nodes: 1000
Number of edges: 5000
Number of node features: 10
Number of classes: 5</span></pre>
   <p>
    <span class="koboSpan" id="kobo.224.1">
     In a real-world scenario, you would typically load your data from files or databases and preprocess it to fit this structure.
    </span>
    <span class="koboSpan" id="kobo.224.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.225.1">
      Data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.226.1">
     object we’ve created is now ready to be used with PyG’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.227.1">
      GNN
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker471">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.228.1">
      models.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.229.1">
     In the next sections, we’ll use this dataset to perform node classification, link prediction, and graph
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.230.1">
      clustering tasks.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-132">
    <a id="_idTextAnchor135">
    </a>
    <span class="koboSpan" id="kobo.231.1">
     Node classification – predicting student interests
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.232.1">
     In this section, we’ll implement
    </span>
    <a id="_idIndexMarker472">
    </a>
    <span class="koboSpan" id="kobo.233.1">
     a GCN to predict
    </span>
    <a id="_idIndexMarker473">
    </a>
    <span class="koboSpan" id="kobo.234.1">
     student interests based on their features and connections in the social network.
    </span>
    <span class="koboSpan" id="kobo.234.2">
     This task demonstrates how GNNs can leverage both node attributes and network structure to make predictions about
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.235.1">
      individual nodes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.236.1">
     Let’s start by defining our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.237.1">
      GCN model:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.238.1">
class GCN(torch.nn.Module):
    def __init__(self, in_channels, hidden_channels, out_channels):
        super().__init__()
        self.conv1 = GCNConv(in_channels, hidden_channels)
        self.conv2 = GCNConv(hidden_channels, out_channels)
    def forward(self, x, edge_index):
        x = self.conv1(x, edge_index).relu()
        x = self.conv2(x, edge_index)
        return x
# Initialize the model
model = GCN(in_channels=num_features,
            hidden_channels=16,
            out_channels=num_classes)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.239.1">
     As you can see, our GCN model consists of two graph convolutional layers.
    </span>
    <span class="koboSpan" id="kobo.239.2">
     The first layer takes the input features and produces hidden representations, while the second layer produces the final
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.240.1">
      class predictions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     Now, let’s train the model.
    </span>
    <span class="koboSpan" id="kobo.241.2">
     You can view the complete code at
    </span>
    <a href="https://github.com/PacktPublishing/Applied-Deep-Learning-on-Graphs">
     <span class="koboSpan" id="kobo.242.1">
      https://github.com/PacktPublishing/Applied-Deep-Learning-on-Graphs
     </span>
    </a>
    <span class="koboSpan" id="kobo.243.1">
     .
    </span>
    <span class="koboSpan" id="kobo.243.2">
     Let’s break down the training
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.244.1">
      process here:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.245.1">
      We define an optimizer (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.246.1">
       Adam
      </span>
     </strong>
     <span class="koboSpan" id="kobo.247.1">
      ) and a loss function (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.248.1">
       CrossEntropyLoss
      </span>
     </strong>
     <span class="koboSpan" id="kobo.249.1">
      ) for training
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.250.1">
       our model:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.251.1">
optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
criterion = torch.nn.CrossEntropyLoss()</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.252.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.253.1">
       train()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.254.1">
      function performs one step
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.255.1">
       of training:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.256.1">
def train():
    model.train()
    optimizer.zero_grad()
    out = model(data.x, data.edge_index)
    loss = criterion(out, data.y)
    loss.backward()
    optimizer.step()
    return loss</span></pre>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.257.1">
        It sets the
       </span>
       <a id="_idIndexMarker474">
       </a>
       <span class="koboSpan" id="kobo.258.1">
        model to
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.259.1">
         training
        </span>
       </span>
       <span class="No-Break">
        <a id="_idIndexMarker475">
        </a>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.260.1">
         mode.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.261.1">
        It computes the forward pass of
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.262.1">
         the model.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.263.1">
        It calculates the loss between predictions and
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.264.1">
         true labels.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.265.1">
        It performs backpropagation and updates the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.266.1">
         model parameters.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <span class="koboSpan" id="kobo.267.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.268.1">
       test()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.269.1">
      function evaluates the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.270.1">
       model’s performance:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.271.1">
def test():
    model.eval()
    out = model(data.x, data.edge_index)
    pred = out.argmax(dim=1)
    correct = (pred == data.y).sum()
    acc = int(correct) / int(data.num_nodes)
    return acc</span></pre>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.272.1">
        It sets the model to
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.273.1">
         evaluation mode.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.274.1">
        It computes the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.275.1">
         forward pass.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.276.1">
        It calculates the accuracy
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.277.1">
         of predictions.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <span class="koboSpan" id="kobo.278.1">
      We train the model for
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.279.1">
       200
      </span>
     </strong>
     <span class="koboSpan" id="kobo.280.1">
      epochs, printing the loss and accuracy every
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.281.1">
        10
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.282.1">
       epochs:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.283.1">
for epoch in range(200):
    loss = train()
    if epoch % 10 == 0:
        acc = test()
        print(f'Epoch: {epoch:03d}, Loss: {loss:.4f}, \
              Accuracy: {acc:.4f}')</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.284.1">
      Finally, we
     </span>
     <a id="_idIndexMarker476">
     </a>
     <span class="koboSpan" id="kobo.285.1">
      evaluate the model one
     </span>
     <a id="_idIndexMarker477">
     </a>
     <span class="koboSpan" id="kobo.286.1">
      last time to get the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.287.1">
       final accuracy:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.288.1">
final_acc = test()
print(f"Final Accuracy: {final_acc:.4f}")</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.289.1">
     To visualize how well our model is performing, let’s create a function to plot the predicted versus true
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.290.1">
      interest groups:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.291.1">
def visualize_predictions(model, data):
    model.eval()
    out = model(data.x, data.edge_index)
    pred = out.argmax(dim=1)
    plt.figure(figsize=(10, 5))
    plt.subplot(121)
    plt.title("True Interests")
    plt.scatter(
        data.x[:, 0], data.x[:, 1], c=data.y, cmap='viridis')
    plt.colorbar()
    plt.subplot(122)
    plt.title("Predicted Interests")
    plt.scatter(
        data.x[:, 0], data.x[:, 1], c=pred, cmap='viridis')
    plt.colorbar()
    plt.tight_layout()
    plt.show()
visualize_predictions(model, data)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.292.1">
     This function
    </span>
    <a id="_idIndexMarker478">
    </a>
    <span class="koboSpan" id="kobo.293.1">
     creates
    </span>
    <a id="_idIndexMarker479">
    </a>
    <span class="koboSpan" id="kobo.294.1">
     two scatter plots: one showing the true interest groups and another showing the predicted
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.295.1">
      interest groups.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer285">
     <span class="koboSpan" id="kobo.296.1">
      <img alt="Figure 7.1: Model performance: true versus predicted interests" src="image/B22118_07_1.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.297.1">
     Figure 7.1: Model performance: true versus predicted interests
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.298.1">
     In
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.299.1">
       Figure 7
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.300.1">
      .1
     </span>
    </em>
    <span class="koboSpan" id="kobo.301.1">
     , each point represents a student, positioned based on their first two features.
    </span>
    <span class="koboSpan" id="kobo.301.2">
     The visualization consists of two scatter plots labeled
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.302.1">
      True Interests
     </span>
    </strong>
    <span class="koboSpan" id="kobo.303.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.304.1">
      Predicted Interests
     </span>
    </strong>
    <span class="koboSpan" id="kobo.305.1">
     .
    </span>
    <span class="koboSpan" id="kobo.305.2">
     Each point in these plots represents one of the students.
    </span>
    <span class="koboSpan" id="kobo.305.3">
     The colors in both plots, ranging from purple (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.306.1">
      0.0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.307.1">
     ) to yellow (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.308.1">
      4.0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.309.1">
     ), indicate different interest groups.
    </span>
    <span class="koboSpan" id="kobo.309.2">
     The left plot shows the actual or “true” interest groups of the students, while the right plot displays the model’s predictions of these interest groups.
    </span>
    <span class="koboSpan" id="kobo.309.3">
     The similarity between the distributions conveys the effectiveness of graph learning techniques in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.310.1">
      such predictions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.311.1">
     In a real-world application, this node classification task could be used to predict student interests based on their profile information and social connections.
    </span>
    <span class="koboSpan" id="kobo.311.2">
     This could be valuable for personalized content recommendations, targeted advertising, or improving student engagement in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.312.1">
      university activities.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.313.1">
     Remember that while our synthetic dataset provides a clean example, real-world data often requires
    </span>
    <a id="_idIndexMarker480">
    </a>
    <span class="koboSpan" id="kobo.314.1">
     more
    </span>
    <a id="_idIndexMarker481">
    </a>
    <span class="koboSpan" id="kobo.315.1">
     preprocessing, handling of missing values, and careful consideration of privacy and ethical concerns when working with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.316.1">
      personal data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.317.1">
     Another aspect of graph learning is the task of link prediction.
    </span>
    <span class="koboSpan" id="kobo.317.2">
     This comes up in a lot of real-world scenarios, especially ones where we are trying to predict
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.318.1">
      certain connections.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-133">
    <a id="_idTextAnchor136">
    </a>
    <span class="koboSpan" id="kobo.319.1">
     Link prediction – recommending new friendships
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.320.1">
     In this section, we’ll implement
    </span>
    <a id="_idIndexMarker482">
    </a>
    <span class="koboSpan" id="kobo.321.1">
     a GAE for link prediction.
    </span>
    <span class="koboSpan" id="kobo.321.2">
     This task
    </span>
    <a id="_idIndexMarker483">
    </a>
    <span class="koboSpan" id="kobo.322.1">
     aims to predict potential new connections in the network, which can be used to recommend new friendships
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.323.1">
      among students.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.324.1">
     First, let’s define our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.325.1">
      GAE model:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.326.1">
class LinkPredictor(torch.nn.Module):
    def __init__(self, in_channels, hidden_channels):
        super().__init__()
        self.encoder = GCNConv(in_channels, hidden_channels)
    def encode(self, x, edge_index):
        return self.encoder(x, edge_index).relu()
    def decode(self, z, edge_label_index):
        return (
            z[edge_label_index[0]] * z[edge_label_index[1]]
        ).sum(dim=-1)
    def forward(self, x, edge_index, edge_label_index):
        z = self.encode(x, edge_index)
        return self.decode(z, edge_label_index)
# Initialize the model
model = LinkPredictor(in_channels=num_features, hidden_channels=64)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.327.1">
     Our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.328.1">
      LinkPredictor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.329.1">
     model uses a GCN layer for encoding node features into embeddings, and a simple dot product operation for decoding (
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.330.1">
      predicting links).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.331.1">
     Now, let’s prepare our data for link prediction using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.332.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.333.1">
from torch_geometric.transforms import RandomLinkSplit
# Prepare data for link prediction
transform = RandomLinkSplit(
    num_val=0.1, num_test=0.1, is_undirected=True,
    add_negative_train_samples=False
)
train_data, val_data, test_data = transform(data)
# Define optimizer
optimizer = torch.optim.Adam(model.parameters(), lr=0.01)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.334.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.335.1">
      RandomLinkSplit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.336.1">
     transform splits our graph into training, validation, and test sets for link prediction.
    </span>
    <span class="koboSpan" id="kobo.336.2">
     It removes some edges for validation and testing and generates negative samples (
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.337.1">
      non-existent edges).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.338.1">
     Now, let’s
    </span>
    <a id="_idIndexMarker484">
    </a>
    <span class="koboSpan" id="kobo.339.1">
     define
    </span>
    <a id="_idIndexMarker485">
    </a>
    <span class="koboSpan" id="kobo.340.1">
     our training and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.341.1">
      evaluation functions:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.342.1">
      Initialize the training process, prepare the optimizer, and encode the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.343.1">
       input data:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.344.1">
def train_link_predictor():
    model.train()
    optimizer.zero_grad()
    z = model.encode(train_data.x, train_data.edge_index)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.345.1">
      Now, we define positive edges and generate negative edges
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.346.1">
       for training:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.347.1">
    pos_edge_index = train_data.edge_index
    neg_edge_index = torch_geometric.utils.negative_sampling(
        edge_index=pos_edge_index,
        num_nodes=train_data.num_nodes,
        num_neg_samples=pos_edge_index.size(1),
    )</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.348.1">
      Combine positive and negative edges and create
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.349.1">
       corresponding labels:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.350.1">
    edge_label_index = torch.cat([
        pos_edge_index, neg_edge_index], dim=-1)
    edge_label = torch.cat([
        torch.ones(pos_edge_index.size(1)),
        torch.zeros(neg_edge_index.size(1))
    ], dim=0)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.351.1">
      The model makes predictions, calculates the loss, performs backpropagation, and updates the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.352.1">
       model parameters:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.353.1">
    out = model.decode(z, edge_label_index)
    loss = torch.nn.BCEWithLogitsLoss()(out, edge_label)
    loss.backward()
    optimizer.step()
    return loss</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.354.1">
      This begins the
     </span>
     <a id="_idIndexMarker486">
     </a>
     <span class="koboSpan" id="kobo.355.1">
      testing function, setting the
     </span>
     <a id="_idIndexMarker487">
     </a>
     <span class="koboSpan" id="kobo.356.1">
      model to evaluation mode and making predictions without
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.357.1">
       gradient calculation:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.358.1">
def test_link_predictor(data):
    model.eval()
    with torch.no_grad():
        z = model.encode(data.x, data.edge_index)
        out = model.decode(z, data.edge_label_index)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.359.1">
      Finally, we convert the predictions to NumPy arrays and calculate the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.360.1">
       Area Under the Receiver Operating Characteristic Curve
      </span>
     </strong>
     <span class="koboSpan" id="kobo.361.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.362.1">
       ROC AUC)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.363.1">
      score to evaluate
     </span>
     <a id="_idIndexMarker488">
     </a>
     <span class="koboSpan" id="kobo.364.1">
      the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.365.1">
       model’s performance:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.366.1">
    y_true = data.edge_label.cpu().numpy()
    y_pred = out.cpu().numpy()
    return roc_auc_score(y_true, y_pred)</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.367.1">
     Now, let’s write the training and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.368.1">
      prediction modules:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.369.1">
      We train the model for
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.370.1">
       100
      </span>
     </strong>
     <span class="koboSpan" id="kobo.371.1">
      epochs, printing the loss and validation AUC every
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.372.1">
        10
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.373.1">
       epochs:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.374.1">
for epoch in range(100):
    loss = train_link_predictor()
    if epoch % 10 == 0:</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.375.1">
       The
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.376.1">
        train_link_predictor()
       </span>
      </strong>
      <span class="koboSpan" id="kobo.377.1">
       function encodes the node features, predicts links
      </span>
      <a id="_idIndexMarker489">
      </a>
      <span class="koboSpan" id="kobo.378.1">
       for both positive and negative
      </span>
      <a id="_idIndexMarker490">
      </a>
      <span class="koboSpan" id="kobo.379.1">
       samples, and computes the binary
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.380.1">
        cross-entropy loss.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.381.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.382.1">
       test_link_predictor()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.383.1">
      function evaluates the model’s performance using the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.384.1">
       AUC metric:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.385.1">
        val_auc = test_link_predictor(val_data)
        print(f'Epoch: {epoch:03d}, Loss: {loss:.4f}, \
              Val AUC: {val_auc:.4f}')</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.386.1">
      Finally, we evaluate the model on the test set to get the final
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.387.1">
       AUC score:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.388.1">
test_auc = test_link_predictor(test_data)
print(f"Test AUC: {test_auc:.4f}")</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.389.1">
       Here is the
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.390.1">
        code output:
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.391.1">Epoch: 000, Loss: 0.6911, Val AUC: 0.5528
Epoch: 010, Loss: 0.6779, Val AUC: 0.5297
Epoch: 020, Loss: 0.6732, Val AUC: 0.5068
Epoch: 030, Loss: 0.6696, Val AUC: 0.5156
Epoch: 040, Loss: 0.6666, Val AUC: 0.5172
Epoch: 050, Loss: 0.6668, Val AUC: 0.5139
Epoch: 060, Loss: 0.6642, Val AUC: 0.5142
Epoch: 070, Loss: 0.6631, Val AUC: 0.5132
Epoch: 080, Loss: 0.6611, Val AUC: 0.5130
Epoch: 090, Loss: 0.6600, Val AUC: 0.5135
Test AUC: 0.4843</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.392.1">
     To demonstrate how we can use this model to recommend new friendships, let’s create a function that predicts the most likely new connections for a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.393.1">
      given student:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.394.1">
      Define the
     </span>
     <a id="_idIndexMarker491">
     </a>
     <span class="koboSpan" id="kobo.395.1">
      function, set the model to evaluation
     </span>
     <a id="_idIndexMarker492">
     </a>
     <span class="koboSpan" id="kobo.396.1">
      mode, and encode the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.397.1">
       graph data:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.398.1">
def recommend_friends(student_id, top_k=5):
    model.eval()
    with torch.no_grad():
        z = model.encode(data.x, data.edge_index)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.399.1">
      Here, we create an edge index for all possible connections between the given student and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.400.1">
       other students:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.401.1">
        other_students = torch.arange(data.num_nodes)
        other_students = other_students[
            other_students != student_id]
        edge_index = torch.stack([
            torch.full_like(other_students, student_id),
            other_students
        ])</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.402.1">
      This code predicts scores for all possible connections and selects the top
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.403.1">
       k
      </span>
     </em>
     <span class="koboSpan" id="kobo.404.1">
      recommendations based on
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.405.1">
       these scores:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.406.1">
        scores = model.decode(z, edge_index)
        top_scores, top_indices = scores.topk(top_k)
        recommended_friends = other_students[top_indices]</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.407.1">
      Finally, the function returns the recommended friends and their corresponding scores, as
     </span>
     <a id="_idIndexMarker493">
     </a>
     <span class="koboSpan" id="kobo.408.1">
      you
     </span>
     <a id="_idIndexMarker494">
     </a>
     <span class="koboSpan" id="kobo.409.1">
      can see in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.410.1">
       following example:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.411.1">
    return recommended_friends, top_scores
# Example usage
student_id = 42  # Example student ID
recommended_friends, scores = recommend_friends(student_id)
print(f"Top 5 friend recommendations for student {student_id}:")
for friend, score in zip(recommended_friends, scores):
    print(f"Student {friend.item()}: Score {score:.4f}")</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.412.1">
       The code output is
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.413.1">
        as follows:
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.414.1">Top 5 friend recommendations for student 42:
Student 381: Score 1.8088
Student 91: Score 1.6567
Student 662: Score 1.5878
Student 467: Score 1.5143
Student 870: Score 1.4449</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.415.1">
     This
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.416.1">
      recommend_friends
     </span>
    </strong>
    <span class="koboSpan" id="kobo.417.1">
     function takes a student ID and returns the top
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.418.1">
      k
     </span>
    </em>
    <span class="koboSpan" id="kobo.419.1">
     recommended new connections based on the link
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.420.1">
      prediction model.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.421.1">
     In a real-world application, this link prediction model could be used to power a friend recommendation system in a university’s social network platform.
    </span>
    <span class="koboSpan" id="kobo.421.2">
     It could help students expand their social circles based on shared characteristics and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.422.1">
      network structure.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.423.1">
     The link prediction model’s applications extend far beyond just university social networks, encompassing diverse domains such as professional networking platforms such as LinkedIn for career connections and business collaborations, academic research networks for finding potential co-authors and research partners, business applications for supply chain partner matching and B2B networking, healthcare networks for patient referrals and provider collaborations, community building through interest-based group recommendations and event participant matching, and content recommendation systems for discovering similar resources and expert-content matching.
    </span>
    <span class="koboSpan" id="kobo.423.2">
     These applications demonstrate the model’s versatility in enhancing connectivity and collaboration opportunities across various sectors and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.424.1">
      use cases.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.425.1">
     Remember
    </span>
    <a id="_idIndexMarker495">
    </a>
    <span class="koboSpan" id="kobo.426.1">
     that
    </span>
    <a id="_idIndexMarker496">
    </a>
    <span class="koboSpan" id="kobo.427.1">
     when implementing such systems with real user data, it’s crucial to consider privacy implications and potentially incorporate additional factors (such as user preferences or mutual friends) into the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.428.1">
      recommendation algorithm.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-134">
    <a id="_idTextAnchor137">
    </a>
    <span class="koboSpan" id="kobo.429.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.430.1">
     In this chapter, we covered the practical applications of graph deep learning in social network analysis using PyG.
    </span>
    <span class="koboSpan" id="kobo.430.2">
     We focused on a hypothetical dataset representing a university student social network, demonstrating how graph-based machine learning can be applied to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.431.1">
      real-world scenarios.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.432.1">
     Together, we achieved two main tasks: node classification for predicting user interests and link prediction for recommending new connections.
    </span>
    <span class="koboSpan" id="kobo.432.2">
     By following step-by-step instructions, you learned how to create a synthetic dataset, implement GCNs for node classification, and use GAEs for link prediction.
    </span>
    <span class="koboSpan" id="kobo.432.3">
     We broke down our code into snippets in relation to data preparation, model training, evaluation, and visualization, allowing you to understand the practical aspects of applying graph deep learning techniques to social
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.433.1">
      network data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.434.1">
     In the upcoming chapters, we will explore how graph deep learning is being applied to various domains, starting with natural
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.435.1">
      language processing.
     </span>
    </span>
   </p>
  </div>
 </body></html>