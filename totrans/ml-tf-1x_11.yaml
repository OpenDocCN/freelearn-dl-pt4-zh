- en: Going Further - 21 Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to introduce 21 real life problems that you can
    use deep learning and TensorFlow to tackle. We will start by talking about some
    public large-scale datasets and competitions. Then, we will show some awesome
    TensorFlow projects on Github. We will also introduce some interesting projects
    that have been done in other deep learning frameworks so that you can get inspired
    and implement your own TensorFlow solution. Finally, we will work through a simple
    technique to convert a Caffe model to a TensorFlow model and introduce using a
    high-level TensorFlow library, TensorFlow-Slim.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Large-scale, public datasets and competitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awesome TensorFlow projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some inspired deep learning projects from other frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a Caffe model to TensorFlow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing TensorFlow-Slim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dataset and challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you some popular datasets and competitions.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 1 - ImageNet dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [http://image-net.org/](http://image-net.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**ImageNet** is a large scale visual recognition challenge that has runs annually
    since 2010\. The dataset is organized according to the WorkNet hierarchy. There
    are over ten million URLs of images with hand-annotated labels to indicate what
    objects are in the picture. There are at least one million images that have bounding
    boxes included.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ImageNet challenge is held every year to evaluate algorithms for the following
    three problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Object localization for 1,000 categories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object detection for 200 fully-labeled categories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object detection from video for 30 fully labeled categories. In July 17, 2017,
    the results of the 2017 challenge were announced with many advanced and interesting
    algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problem 2 - COCO dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [http://mscoco.org/](http://mscoco.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: COCO is a dataset for image recognition, segmentation, and captioning sponsored
    by Microsoft. There are 80 object categories in this dataset with more than 300,000
    images and two million instances. There are also challenges for detections, captions,
    and key-points every year.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 3 - Open Images dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://github.com/openimages/dataset](https://github.com/openimages/dataset)'
  prefs: []
  type: TYPE_NORMAL
- en: Open Images is a new dataset from Google, with over nine million URLs spanning
    over 6000 categories. Each image is processed by Google's vision model and verified
    by a human. As of July 20, 2017, there are also over two million bounding box
    annotations spanning over 600 objects.
  prefs: []
  type: TYPE_NORMAL
- en: The difference is that Open Images covers more real-life objects than others,
    which can be very useful when developing real-life applications.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 4 - YouTube-8M dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://research.google.com/youtube8m/](https://research.google.com/youtube8m/)'
  prefs: []
  type: TYPE_NORMAL
- en: YouTube-8M is a large-scale video dataset from Google with 7 million video URLs
    over 4,716 classes and 450,000 hours of video. Google also provides pre-computed,
    state-of-the-art audio-visual features, so that one can build their model based
    on these features with ease. Training from raw videos may take weeks, which is
    not reasonable in normal situations. This dataset's goal is to achieve video understanding,
    representation learning, noisy data modeling, transfer learning, and domain adaptation
    for videos.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 5 - AudioSet dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://research.google.com/audioset/](https://research.google.com/audioset/)'
  prefs: []
  type: TYPE_NORMAL
- en: AudioSet is a large-scale audio events dataset from Google with 632 audio event
    classes and a collection of over 2.1 million manually annotated sound clips. Audio
    classes span from human and animal sounds to musical instruments and common, everyday
    environmental sounds. Using this dataset, you can create a system to recognize
    audio events for audio understanding, security applications, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 6 - LSUN challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [http://lsun.cs.princeton.edu/2017/](http://lsun.cs.princeton.edu/2017/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'LSUN challenge provides a large scale scene understanding dataset covering
    three major problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segmentation task on street images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saliency prediction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In scene classification problems, the expected output of the algorithm is the
    top most likely scene category in the image. At the time of writing, there are
    10 different classes such as bedroom, classroom, and restaurant. In the segmentation
    problem, you can try to solve the pixel-level segmentation and instance-specific
    segmentation. In saliency prediction problems, the goal is to predict where a
    human looks in a scene image.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 7 - MegaFace dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [http://megaface.cs.washington.edu/](http://megaface.cs.washington.edu/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'MegaFace provides a large scale dataset for face recognition. The MegaFace
    dataset is divided into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Training set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distractors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Training set** contains 4.7 million photos of over 672,057 unique identities.
    The **test set** contains the images from the FaceScrub and FGNet dataset. The
    **distractors** contain one million photos of 690,572 unique users. Currently,
    there are two challenges in the MegaFace website. In challenge 1, you can train
    using any dataset and test your method with the one million distractors. Your
    method needs to discriminate between a set of known people while classifying the
    distractors as unknown people. In challenge 2, you will train using the training
    set with 672K unique identities and test with 1 million distractors. MegaFace
    is currently the largest dataset for face recognition at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 8 - Data Science Bowl 2017 challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://www.kaggle.com/c/data-science-bowl-2017](https://www.kaggle.com/c/data-science-bowl-2017)'
  prefs: []
  type: TYPE_NORMAL
- en: Data Science Bowl 2017 is a one million dollar challenge focused on lung cancer
    detection. In the dataset, you will be given over a thousand CT images of high-risk
    patients. The goal of this challenge is to create an automatic system that can
    determine whether a patient will be diagnosed with lung cancer within one year.
    This is a very interesting and important project to work on that will save thousands
    of people in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 9 - StarCraft Game dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://github.com/TorchCraft/StarData](https://github.com/TorchCraft/StarData)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the largest StarCraft--Brood War replay dataset at the time of writing
    this book. This dataset contains more than 60,000 games in 365GB, 1535 million
    frames, and 496 million player actions. This dataset is best suit for those who
    want to research about AI game playing.
  prefs: []
  type: TYPE_NORMAL
- en: TensorFlow-based Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce you to several problems that are implemented
    in TensorFlow and open-source on Github. We suggest that you take a look at these
    projects and learn how to improve your TensorFlow skills.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 10 - Human Pose Estimation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project Link: [https://github.com/eldar/pose-tensorflow](https://github.com/eldar/pose-tensorflow)'
  prefs: []
  type: TYPE_NORMAL
- en: This project is the open-source implementation of Deep Cut and ArtTrack in human
    body pose estimation. The goal of this project is to jointly solve the tasks of
    detection and pose estimation. We can use this method for various applications
    such as person detection in security or human action understanding. This project
    also provides great starting points for a lot of further research on human shape
    estimation with applications for virtual-try-on or garment recommendation.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 11 - Object Detection - YOLO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://github.com/thtrieu/darkflow](https://github.com/thtrieu/darkflow)'
  prefs: []
  type: TYPE_NORMAL
- en: Object detection is an interesting problem in Computer Vision. There are lots
    of methods to solve this problem. YOLO, by Joseph Redmon and others, is one of
    the state-of-the-art techniques. YOLO provides real-time object detection using
    deep neural networks. Version 2 of YOLO can recognize up to 9,000 different objects
    with high accuracy in real time. The original YOLO project is programmed in the
    darknet framework.
  prefs: []
  type: TYPE_NORMAL
- en: In TensorFlow, there is a great implementation of YOLO, called **darkflow**.
    The darkflow repository even has the utility that can allow you to export the
    model and serve on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 12 - Object Detection - Faster RCNN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://github.com/smallcorgi/Faster-RCNN_TF](https://github.com/smallcorgi/Faster-RCNN_TF)'
  prefs: []
  type: TYPE_NORMAL
- en: Faster RCNN is another state-of-the-art method for Object Detection. This method
    offers high precision on the result and also inspires lots of methods for many
    other problems. The inference speed of Faster RCNN is not as fast as YOLO. However,
    if you need high precision on the detection results, you may want to consider
    Faster RCNN.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 13 - Person Detection - tensorbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://github.com/Russell91/TensorBox](https://github.com/Russell91/TensorBox)'
  prefs: []
  type: TYPE_NORMAL
- en: Tensorbox is a TensorFlow implementation of the method by Russell Stewart and
    Mykhaylo Andriluka. The goal of this method is a bit different from the preceding
    methods. Tensorbox focuses on solving the problem of crowd person detection. They
    use a recurrent LSTM layer for sequence generation of the bounding boxes and define
    a new loss function that operates of the set of detection results.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 14 - Magenta
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://github.com/tensorflow/magenta](https://github.com/tensorflow/magenta)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Magenta is a project from the Google Brain team that focuses on Music and Art
    Generation using Deep Learning. This is a very active repository with many implementations
    of interesting problems such as image stylization, melody generation, or generating
    sketches. You can visit the following link to have access to Magenta''s models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/tensorflow/magenta/tree/master/magenta/models](https://github.com/tensorflow/magenta/tree/master/magenta/models)'
  prefs: []
  type: TYPE_NORMAL
- en: Problem 15 - Wavenet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://github.com/ibab/tensorflow-wavenet](https://github.com/ibab/tensorflow-wavenet)'
  prefs: []
  type: TYPE_NORMAL
- en: WaveNet is a neural network architecture for audio generation from Google Deep
    Mind. WaveNet is trained to generate raw audio waveform and has shown good results
    for text-to-speech and audio generation. According to Deep Mind, WaveNet reduced
    the gap between the previous methods and human-level performance by over 50% in
    text-to-speech problems for both US English and Mandarin Chinese.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 16 - Deep Speech
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://github.com/mozilla/DeepSpeech](https://github.com/mozilla/DeepSpeech)'
  prefs: []
  type: TYPE_NORMAL
- en: Deep Speech is an open source speech-to-text engine, based on a research paper
    from Baidu. Speech-to-text is a very interesting problem and Deep Speech is one
    of the state-of-the-art methods for solving it. With the TensorFlow implementation
    of Mozilla, you can even learn how to use TensorFlow across more than one machine.
    However, there is still a problem that personal researchers can't access the same
    large scale speech-to-text datasets as a large company. So, even though we can
    use Deep Speech or implement it ourselves, it is still hard to have a good model
    for production.
  prefs: []
  type: TYPE_NORMAL
- en: Interesting Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you some interesting projects that are implemented
    in other deep learning frameworks. These projects give significant results over
    very difficult problems. You may want to challenge yourself to implement these
    methods in TensorFlow.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 17 - Interactive Deep Colorization - iDeepColor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://richzhang.github.io/ideepcolor/](https://richzhang.github.io/ideepcolor/)'
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Deep Colorization is research being carried out by Richard Zhang
    and Jun-Yan Zun, and others, for user-guided image colorization. In this system,
    users can give the network a few hints of colors for some points in the image
    and the network will propagate user inputs along with semantic information learned
    from large scale data. The colorization can be performed in real time with one
    single forward pass.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 18 - Tiny face detector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://github.com/peiyunh/tiny](https://github.com/peiyunh/tiny)'
  prefs: []
  type: TYPE_NORMAL
- en: This project is a face detector that focuses on finding the small faces in the
    image by Peiyun Hu and Deva Ramanan. While most face detectors only focus on large
    objects in the image, this tiny face detector method can work with very small
    faces, but still, reduce the error by a factor of two compared with prior methods
    on the WIDER FACE dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 19 - People search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://github.com/ShuangLI59/person_search](https://github.com/ShuangLI59/person_search)'
  prefs: []
  type: TYPE_NORMAL
- en: This project is the implementation of the paper by Tong Xiao, and others that
    focuses on the problem of person detection and re-identification. This project
    can be used in video surveillance. The existing person re-identification methods
    mainly assume that the person is cropped and aligned. However, in real-world scenarios,
    the person detection algorithm may fail to extract the perfect crop region of
    the person and lower the identification accuracy. In this project, the authors
    solve detection and identification jointly in a novel architecture inspired by
    Faster RCNN. The current project is implemented in the Caffe Deep Learning Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 20 - Face Recognition - MobileID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://github.com/liuziwei7/mobile-id](https://github.com/liuziwei7/mobile-id)'
  prefs: []
  type: TYPE_NORMAL
- en: This project provides an extremely fast face recognition system that can run
    in 250 FPS with high accuracy. The model is learned by using the output of the
    state-of-the-art face recognition DeepID. However, the mobile ID model can perform
    so fast that it can be used in situations where processing and memory are limited.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 21 - Question answering - DrQA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project link: [https://github.com/facebookresearch/DrQA](https://github.com/facebookresearch/DrQA)'
  prefs: []
  type: TYPE_NORMAL
- en: DrQA is a system for open-domain question answering from Facebook. DrQA focuses
    on solving the task of *machine reading* where the model will try to understand
    the Wikipedia documents and give the answer for any question from users. The current
    project is implemented in PyTorch. You may find it interesting to implement our
    own solution in TensorFlow.
  prefs: []
  type: TYPE_NORMAL
- en: Caffe to TensorFlow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you how to take advantage of many pre-trained
    models from Caffe Model Zoo ([https://github.com/BVLC/caffe/wiki/Model-Zoo](https://github.com/BVLC/caffe/wiki/Model-Zoo)).
    There are lots of Caffe models for different tasks with all kinds of architectures.
    After converting these models to TensorFlow, you can use it as a part of your
    architectures or you can fine-tune our model for different tasks. Using these
    pre-trained models as initial weights is an effective approach for training instead
    of training from scratch. We will show you how to use a `caffe-to-tensorflow` approach
    from Saumitro Dasgupta at [https://github.com/ethereon/caffe-tensorflow](https://github.com/ethereon/caffe-tensorflow).
  prefs: []
  type: TYPE_NORMAL
- en: However, there are lots of differences between Caffe and TensorFlow. This technique
    only supports a subset of layer types from Caffe. Even though there are some Caffe
    architectures that are verified by the author of this project such as ResNet,
    VGG, and GoogLeNet.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to clone the `caffe-tensorflow` repository using the `git clone` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to change the directory to the `caffe-to-tensorflow` directory
    and run the convert python script to see some help messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: According to this help message, we can know the parameters of the `convert.py`
    script. In summary, we will use this `convert.py` to create the network architecture
    in TensorFlow with the flag code-output-path and convert the pre-trained weights
    with the flag data-output-path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start converting the models, we need to get some pull requests from
    contributors of this project. There are some issues with the current master branch
    that we can''t use the latest TensorFlow (version 1.3 at the time of writing)
    and python-protobuf (version 3.4.0 at the time of writing). Therefore, we will
    get the code using the following pull requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ethereon/caffe-tensorflow/pull/105](https://github.com/ethereon/caffe-tensorflow/pull/105)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ethereon/caffe-tensorflow/pull/133](https://github.com/ethereon/caffe-tensorflow/pull/133)'
  prefs: []
  type: TYPE_NORMAL
- en: You need to open the preceding links to see if the pull requests are merged
    or not. If it is still in `open` status, you will need to follow the next part.
    Otherwise, you can skip the merged `pull` requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will get the code from pull request `105`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from pull request `133`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are some conflicts in the `kaffe/tensorflow/network.py`
    file. We will show you how to resolve these `conflicts`, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will solve the conflict at line 137:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cbf68bc-d3f7-4fb7-997b-3f6daa91a467.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We remove the HEAD part from line 137 to line 140\. The final result will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24ec3b97-1597-4c60-87e7-ea065ad10bcc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will solve the conflict at line 185:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e98bcebb-7236-47f4-8628-55673a01f83a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also remove the HEAD part from line 185 to line 187\. The final result will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/699ebeba-5219-4f3e-851c-c7970784f55e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the `caffe-to-tensorflow` directory, there is a directory named examples
    that contains the code and data for the MNIST and ImageNet challenge. We will
    show you how to work with the MNIST model. The ImageNet challenge is not much
    different.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will convert the MNIST architecture from Caffe to TensorFlow using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will convert the MNIST pre-trained Caffe model at `examples/mnist/lenet_iter_10000.caffemodel`
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, these commands will create a python file named `mynet.py` and
    a `numpy` file named `mynet.npy` in the current directory. We also need to add
    the current directory to the `PYTHONPATH` to allow the further code to import
    `mynet.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The last two numbers in each line is the loss and accuracy of the fine-tune
    process. You can see that the fine-tune process can easily achieve 100% accuracy
    with the pre-trained weights from the Caffe model.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will take a look at the `finetune_mnist.py` file to see how the pre-trained
    weights are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, they import the `mynet` python with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, they create some placeholders for `images` and `labels` and compute the
    `loss` using the layers `ip2` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After that, the fine-tune process is independent from the Caffe framework.
  prefs: []
  type: TYPE_NORMAL
- en: TensorFlow-Slim
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TensorFlow-Slim is a light-weight library for defining, training, and evaluating
    complex models in TensorFlow. With the TensorFlow-Slim library, we can build,
    train, and evaluate the model easier by providing lots of high-level layers, variables,
    and regularizers. We recommend that you take a look at the TensorFlow-Slim library
    at the following link: [https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/slim](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/slim)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also lots of pre-trained models that are provided using TensorFlow-Slim.
    You can take advantage of high-level TensorFlow layers and models at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/slim](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/slim)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have provided lots of interesting challenges and problems
    that you can try to solve and learn from to improve your TensorFlow skills. At
    the end of this chapter, we also guided you to convert the Caffe model to TensorFlow and
    introduced you to the high-level TensorFlow library, TensorFlow-Slim.
  prefs: []
  type: TYPE_NORMAL
