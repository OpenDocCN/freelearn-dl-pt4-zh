<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deploying Models to Web and Mobile</h1>
                
            
            <article>
                
<p class="calibre2">For companies that depend on machine learning, it is very important to deploy their models in a scalable fashion. The models should work in the same manner that they were working in when the model was created. Deploying fastText models, both supervised and unsupervised, can be done in a variety of ways. The choice of methodology would depend on your individual needs.</p>
<p class="calibre2">In this chapter, we will focus on how to deploy fastText models in web and mobile scenarios. The topics are the following:</p>
<ul class="calibre10">
<li class="calibre11">Deploying to the web</li>
<li class="calibre11">Flask</li>
<li class="calibre11">FastText functions</li>
<li class="calibre11">Flask endpoints</li>
<li class="calibre11">Deploying to smaller devices</li>
<li class="calibre11">Prerequisites – Completing the Google tutorial</li>
<li class="calibre11">App considerations</li>
<li class="calibre11">Adding the fastText model</li>
<li class="calibre11">FastText in Java</li>
<li class="calibre11">Adding library dependencies to Android</li>
<li class="calibre11">Using library dependencies in Android</li>
<li class="calibre11">Finally, the app</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deploying to the web</h1>
                
            
            <article>
                
<p class="calibre2">Now that you have the ways and means to create your own fastText models, you will probably need to deploy them to production so that those models can be utilized to create applications and endpoints to use. There are a lot of frameworks in Python that can be used to create such web apps. Flask, Django, and Pyramid are some popular Python web frameworks. In this section, we will take the example of flask and build a simple web nearest neighbor search application in flask.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Flask</h1>
                
            
            <article>
                
<p class="calibre2">Flask is a popular web framework, and it is classified as a microframework as it does not require any external tools or libraries. There are no database abstraction layers, or form validation, or other components built into flask. The advantage of this is that you can build a simple web app in flask with minimal lines of code. This helps fast prototyping and helps you to focus on the application code itself.</p>
<p class="calibre2">For code that is discussed in this section, take a look at the <kbd class="calibre12">chapter 7</kbd> folder in the repository. You will find two files, <kbd class="calibre12">ft_server.py</kbd> and <kbd class="calibre12">ft_utils.py</kbd>. The <kbd class="calibre12">ft_utils.py</kbd> module has the code related to the fastText server, and <kbd class="calibre12">ft_server.py</kbd> has the code related to the flask endpoints.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The fastText functions</h1>
                
            
            <article>
                
<p class="calibre2">If you take a look at the code, we are loading the fastText module from the <kbd class="calibre12">FT_MODEL</kbd> environment variable. This model is loaded as a global variable so that it can be utilized in the functions as well. Another advantage is that when the flask app is initialized, the model will also be loaded into memory. Loading the model into memory is computationally expensive and hence if we defer that operation to the initialization phase, that will improve the response timings:</p>
<pre class="calibre17">print('loading the model')<br class="title-page-name"/>FT_MODEL = os.environ.get('FT_MODEL')<br class="title-page-name"/>if not FT_MODEL:<br class="title-page-name"/>    raise ValueError('No fasttext model has been linked.')<br class="title-page-name"/>FT_MODEL = fastText.load_model(FT_MODEL)<br class="title-page-name"/>print('model is loaded')</pre>
<p class="calibre2">Now, we will also get the most common words in the vocabulary, based on a threshold, and keep it in memory. We will keep the word vectors, again as a global variable, so that the computation of the word vectors is done during the initiation of the app, similar to before:</p>
<pre class="calibre17"># Gets words with associated frequency sorted by default by descending order<br class="title-page-name"/>words, freq = FT_MODEL.get_words(include_freq=True)<br class="title-page-name"/>words = words[:threshold]<br class="title-page-name"/>vectors = np.zeros((len(words), FT_MODEL.get_dimension()), dtype=float)<br class="title-page-name"/>for i in range(len(words)):<br class="title-page-name"/>    wv = FT_MODEL.get_word_vector(words[i])<br class="title-page-name"/>    wv = wv / np.linalg.norm(wv)<br class="title-page-name"/>    vectors[i] = wv<br class="title-page-name"/><br class="title-page-name"/># For efficiency preallocate the memory to calculate cosine similarities<br class="title-page-name"/>cossims = np.zeros(len(words), dtype=float)</pre>
<p class="calibre2">The next two functions are basically how to get the nearest words, based on the distances between the word vector for the question word and the word vectors of the other words as well. These functions have also been discussed in <a target="_blank" href="part0115.html#3DLGM0-05950c18a75943d0a581d9ddc51f2755" class="calibre9">Chapter 5</a>, <em class="calibre16">FastText in Python</em> as well.</p>
<p class="calibre2">You should be able to run the module by itself. Also, notice the time required to run the whole module.</p>
<p class="calibre2">Running the whole code takes around 10 seconds on my laptop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The flask endpoints</h1>
                
            
            <article>
                
<p class="calibre2">For reasons of brevity, there is only one endpoint that is discussed in this app. Basically, it is used to take the incoming question word, get the answers from the <kbd class="calibre12">nn</kbd> function defined in the <kbd class="calibre12">ft_utils.py</kbd> file, and then serve the answers in JSON format:</p>
<pre class="calibre17">@app.route('/nn/&lt;question_word&gt;')<br class="title-page-name"/>def nearest_neighbours(question_word):<br class="title-page-name"/>    answers = [a for a in nn(FT_MODEL, question_word, k=5)]<br class="title-page-name"/>    return jsonify(dict(question=question_word, answers=answers))</pre>
<p class="calibre2">Now, run the app in development mode and so that you can debug it:</p>
<pre class="calibre17"><strong class="calibre1">$ export FLASK_APP=ft_server.py</strong><br class="title-page-name"/><strong class="calibre1">$ export FLASK_ENV=development</strong><br class="title-page-name"/><strong class="calibre1">$ export FT_MODEL=wiki.simple.bin</strong><br class="title-page-name"/><strong class="calibre1">$ flask run</strong></pre>
<p class="calibre2">Open a new terminal and send a curl request; you should be able to see the response in the Terminal. You can see that the response is also fast:</p>
<pre class="calibre17"><strong class="calibre1">$ time curl http://127.0.0.1:5000/nn/dog</strong><br class="title-page-name"/><strong class="calibre1"> {</strong><br class="title-page-name"/><strong class="calibre1">     "answers": [</strong><br class="title-page-name"/><strong class="calibre1">         "dogs",</strong><br class="title-page-name"/><strong class="calibre1">         "catdog",</strong><br class="title-page-name"/><strong class="calibre1">         "sheepdog",</strong><br class="title-page-name"/><strong class="calibre1">         "sheepdogs",</strong><br class="title-page-name"/><strong class="calibre1">         "breed"</strong><br class="title-page-name"/><strong class="calibre1">     ],</strong><br class="title-page-name"/><strong class="calibre1">     "question": "dog"</strong><br class="title-page-name"/><strong class="calibre1"> }</strong><br class="title-page-name"/><strong class="calibre1">$ curl http://127.0.0.1:5000/nn/dog 0.01s user 0.00s system 9% cpu 0.105 total</strong></pre>
<p class="calibre2">We are able to have very fast responses as part of the Flask app as we tried to shift the computationally expensive portions of the code to the app initiation phase as much as possible. This is generally a good idea. As part of the web app, only do what is absolutely necessary and keep the amount of computation as part of serving the request to the minimum. This will ensure that you are building effective and useful web apps to for deploying fastText models and machine learning apps in general.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deploying to smaller devices</h1>
                
            
            <article>
                
<p class="calibre2">As you saw in <a target="_blank" href="part0036.html#12AK80-05950c18a75943d0a581d9ddc51f2755" class="calibre9">Chapter 2</a>, <em class="calibre16">Creating Models Using FastText Command Line</em>, you can create a compressed fastText model from a whole model using a command similar to this one:</p>
<pre class="calibre17"><strong class="calibre1">$ ./fasttext quantize -output &lt;model prefix&gt; -input &lt;training file&gt; -qnorm -retrain -epoch &lt;number of epochs&gt; -cutoff &lt;number of words to consider&gt;</strong></pre>
<p class="calibre2">In <a target="_blank" href="part0098.html#2TEN40-05950c18a75943d0a581d9ddc51f2755" class="calibre9">Chapter 4</a>, <em class="calibre16">Sentence Classification in FastText</em>, we also revisited the concept of having compressed models and how compression was achieved without much loss in performance.</p>
<p class="calibre2">This enables you to deploy machines in smaller devices as well. One of the first things that comes to mind is whether the files can be packaged with an Android app and deployed in an Android application.</p>
<p class="calibre2">In this section, I will put into place all the requirements and dependencies that should enable you to deploy an Android fastText application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Prerequisites – Completing the Google tutorial</h1>
                
            
            <article>
                
<p class="calibre2">One of the best examples to consider is the example Android app in the Google tutorial. In case you are new to Android, go to <a href="https://developer.android.com/training/basics/firstapp/" class="calibre9">https://developer.android.com/training/basics/firstapp/</a> and complete the tutorial there. We will not go into the details here, so in summary, the steps are:</p>
<ol class="calibre13">
<li value="1" class="calibre11">Install Android Studio</li>
<li value="2" class="calibre11">Create some simple user interfaces</li>
<li value="3" class="calibre11">Create the activities and define the intents</li>
<li value="4" class="calibre11">Build and create the APK files</li>
</ol>
<p class="calibre2">For our app, we will be working along similar lines. The name of the project in our case is <kbd class="calibre12">Fasttext application</kbd>. So, download the latest Android Studio and fire it up:</p>
<div class="cdpaligncenter"><img src="../images/00090.jpeg" class="calibre57"/></div>
<p class="calibre2">Keep on clicking <span class="calibre5">Next</span>,<span class="calibre5"> </span>select empty activity, and click <span class="calibre5">Finish</span>. You should be taken to a new project window, which has a lot of boilerplate code for Android already done for you. Now, open up the Google tutorial and follow all the steps in the tutorial. If you are already an experienced Android developer, then you can open the project from the GitHub repository. First, do a <kbd class="calibre12">git fetch</kbd> and check out the <kbd class="calibre12">android_starting</kbd> branch:</p>
<pre class="calibre17"><strong class="calibre1">git fetch</strong><br class="title-page-name"/><strong class="calibre1">git checkout android_starting</strong></pre>
<p class="calibre2">Now, if you compile the app and create an APK, you should be able to get the following screen. Or if you have ADB set up, you can just select <span class="calibre5">Run</span> and see the app in your emulator.</p>
<p class="calibre2">To build an APK, you can click the <span class="calibre5">Build APK(s)</span> button in your Android Studio:</p>
<div class="cdpaligncenter"><img src="../images/00091.jpeg" class="calibre58"/></div>
<p class="calibre2">Please go through the steps written in <span class="calibre5">Build a simple User interface</span> in the Google Android tutorial so that you finally get a simple app running, similar to this one:</p>
<div class="cdpaligncenter"><img src="../images/00092.jpeg" class="calibre59"/></div>
<p class="calibre2">Now, go through the <span class="calibre5">Start another activity</span> tutorial and complete the creation of another activity. The aim of this tutorial is so that you can have a separate activity triggered from the first activity:</p>
<div class="cdpaligncenter"><img src="../images/00093.jpeg" class="calibre60"/>           =&gt;              <img src="../images/00094.jpeg" class="calibre61"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">App considerations</h1>
                
            
            <article>
                
<p class="calibre2">Now that you have two activities, you might have guessed the aim of our fastText application. We will input our text label in the first activity, and it should give us the labels in the second activity.</p>
<p class="calibre2">To achieve that, you will need to do two things:</p>
<ol class="calibre13">
<li value="1" class="calibre11">Add a prebuilt fastText model to the Android app</li>
<li value="2" class="calibre11">Add a library that will parse the fastText model and give us the predictions</li>
</ol>
<p class="calibre2">There are some points that I would like to mention here. We are going to use the fastText FTZ models here. You can argue as we had seen, fastText models are built using product quantization using methods such as nearest neighbor centroid estimations, pruning of vocabularies and hashing. This results in loss of information, although it is argued that there is no significant loss in performance. But if you are not convinced, you have the option of creating the web app as discussed in the previous section and accessing the results from your Android app, which means having the Android app as a view-only, and deferring all the computation to the server. That is a fair course to take, but is more of an engineering challenge and not within the scope of this book. In this section, we are more interested in finding out whether we can leverage the capabilities of fastText to create really small models, deploy them in mobile devices, and use them in our applications.</p>
<p class="calibre2">Now before we go ahead, build the APK and take note of the present size of the application, since size is an important matter for users if you want users to download and use the application. You probably don't want your users to uninstall the application because the memory is full, or the user is in a place where the internet is really slow and it will take a long time to download the application. So, keep the application size always in mind when designing applications for smaller devices.</p>
<p class="calibre2">Right now, the build is taking up only 1.5 MB of memory:</p>
<pre class="calibre17"><strong class="calibre1">$ du -sh app-debug.apk</strong><br class="title-page-name"/><strong class="calibre1">1.6M app-debug.apk</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding the fastText model</h1>
                
            
            <article>
                
<p class="calibre2">Moving ahead, now you will need to add a fastText model to the application. Android has an asset management system which can be used for this.</p>
<p class="calibre2">First of all, download or create an FTZ model. I downloaded the <kbd class="calibre12">dbpedia.ftz</kbd> file from the supervised models section of the fastText website. The file is around 1.6 MB in size and hence should not bump up the APK size in the final build.</p>
<p class="calibre2"/>
<p class="calibre2">Android has a resource management system and you can use that for this purpose. Create an assets folder under the main folder and copy/paste your FTZ file there:</p>
<div class="cdpaligncenter"><img src="../images/00095.jpeg" class="calibre62"/></div>
<p class="calibre2">You should be able to see the file, as shown here:</p>
<div class="cdpaligncenter"><img src="../images/00096.jpeg" class="calibre63"/></div>
<p class="calibre2">Once done, add the code to access the file using the resource manager. Since we are making the predictions in the second activity, let's access this file in the <kbd class="calibre12">DisplayMessageActivity.java</kbd> file.</p>
<p class="calibre2">In the <kbd class="calibre12">onCreate</kbd> method, create an <kbd class="calibre12">AssetManager</kbd> instance to access the asset files, and create an <kbd class="calibre12">InputStream</kbd> instance so that the file can be converted to a stream. The data will be read and manipulated from this stream, shown as follows:</p>
<pre class="calibre17"><span>public class </span>DisplayMessageActivity <span>extends </span>AppCompatActivity {<br class="title-page-name"/><br class="title-page-name"/>    <span>@Override<br class="title-page-name"/></span><span>    </span><span>protected void </span><span>onCreate</span>(Bundle savedInstanceState) {<br class="title-page-name"/>        <span>super</span>.onCreate(savedInstanceState)<span>;<br class="title-page-name"/></span><span>        </span>setContentView(R.layout.<span>activity_display_message</span>)<span>;<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>        </span><span>// Get the Intent that started this activity and extract the string<br class="title-page-name"/></span><span>        </span>Intent intent = getIntent()<span>;<br class="title-page-name"/></span><span>        </span>String message = intent.getStringExtra(MainActivity.<span>EXTRA_MESSAGE</span>)<span>;<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>        </span><span>// Get the assets from the asset manager.<br class="title-page-name"/></span><span>        </span>AssetManager assetManager = getAssets()<span>;<br class="title-page-name"/></span><span>        </span>InputStream inputStream = <span>null;<br class="title-page-name"/></span><span>        try </span>{<br class="title-page-name"/>            inputStream = assetManager.open(<span>"dbpedia.ftz"</span>)<span>;<br class="title-page-name"/></span><span>        </span>} <span>catch </span>(IOException e) {<br class="title-page-name"/>            e.printStackTrace()<span>;<br class="title-page-name"/></span><span>        </span>}<br class="title-page-name"/><br class="title-page-name"/>        <span>// Capture the layout's TextView and set the string as its text<br class="title-page-name"/></span><span>        </span>TextView textView = findViewById(R.id.<span>textView</span>)<span>;<br class="title-page-name"/></span><span>        </span>textView.setText(message)<span>;<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>    </span>}</pre>
<p class="calibre2">Press <em class="calibre16">Alt</em> + <em class="calibre16">Enter</em> (or <em class="calibre16">Option</em> + <em class="calibre16">Enter</em> on a Mac) to import missing classes. Your imports should end up as the following:</p>
<pre class="calibre17"><span>import </span>android.content.Intent<span>;<br class="title-page-name"/></span><span>import </span>android.content.res.AssetManager<span>;<br class="title-page-name"/></span><span>import </span>android.support.v7.app.AppCompatActivity<span>;<br class="title-page-name"/></span><span>import </span>android.os.Bundle<span>;<br class="title-page-name"/></span><span>import </span>android.widget.TextView<span>;<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>import </span>java.io.IOException<span>;<br class="title-page-name"/></span><span>import </span>java.io.InputStream<span>;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">FastText in Java</h1>
                
            
            <article>
                
<p class="calibre2">Now that you have the fastText model deployed in the Android app, you will need a way to access the file and serve the predictions. One way that you can do this is that you can write Java custom code using the fastText GitHub repository as a reference. The advantage of this approach is that you have more control over the code, and that might be the only option if you are writing an enterprise application, since the code of fastText is given under the BSD license. Another option is to take the fastText code and compile the code as part of the Android library, but there are a lot of issues with serving native code and it may not work on all devices. The best approach for me when adding external dependencies is if you can find core Java libraries that do the work for you.</p>
<p class="calibre2">Fortunately in this case, we have one that fits the bill. <kbd class="calibre12">fastText4j</kbd> is an excellent Java library by <kbd class="calibre12">linkfluence</kbd> on GitHub that has all the code in Java and is able to load and parse Java libraries as well. Apart from the ability to read bin and FTZ files, we also have the ability read and create Java memory mapped files, although we will not be using it here. Use the following repository to clone the repository that is a clone of the original <kbd class="calibre12">linkfluence</kbd> one:</p>
<pre class="calibre17"><strong class="calibre1">$ git clone https://github.com/infinite-Joy/fastText4j.git</strong><br class="title-page-name"/><strong class="calibre1">$ cd fastText4j</strong><br class="title-page-name"/><strong class="calibre1">$ mvn clean</strong></pre>
<p class="calibre2">Also compile the package to an app as we will need that for testing and compilation purposes. Unzip the file that is created as a result:</p>
<pre class="calibre17"><strong class="calibre1">$ mvn install -Papp</strong><br class="title-page-name"/><strong class="calibre1">$ unzip app/fasttext4j-app.zip</strong><br class="title-page-name"/><strong class="calibre1">$ cp target/fasttext4j-0.2.1-SNAPSHOT.jar lib/fasttext4j-0.2.1-SNAPSHOT.jar</strong></pre>
<p class="calibre2">This should copy a <kbd class="calibre12">lib/</kbd> folder and <kbd class="calibre12">fasttext-mmap.sh</kbd> file to your present directory. The last copy stage is not really necessary now, but this is just to show you this step is needed when you make changes to this repository and recompile the JAR again. For now, the file will have a slightly different command line. Change the <kbd class="calibre12">main</kbd> method in <kbd class="calibre12">src/main/java/fasttext/FastText.java</kbd>:</p>
<pre class="calibre17">  public static void main(String[] args) throws Exception {<br class="title-page-name"/><br class="title-page-name"/>    Options options = new Options();<br class="title-page-name"/><br class="title-page-name"/>    Option input = new Option("i", "input", true, "input model path");<br class="title-page-name"/>    input.setRequired(true);<br class="title-page-name"/>    options.addOption(input);<br class="title-page-name"/><br class="title-page-name"/>    CommandLineParser parser = new DefaultParser();<br class="title-page-name"/>    HelpFormatter formatter = new HelpFormatter();<br class="title-page-name"/>    CommandLine cmd;<br class="title-page-name"/><br class="title-page-name"/>    try {<br class="title-page-name"/>      cmd = parser.parse(options, args);<br class="title-page-name"/>    } catch (ParseException e) {<br class="title-page-name"/>      System.out.println(e.getMessage());<br class="title-page-name"/>      formatter.printHelp("fasttext.FastText", options);<br class="title-page-name"/><br class="title-page-name"/>      System.exit(1);<br class="title-page-name"/>      return;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    String inputModelPath = cmd.getOptionValue("input");<br class="title-page-name"/><br class="title-page-name"/>    logger.info("Loading fastText model to convert...");<br class="title-page-name"/>    FastText model = FastText.loadModel(inputModelPath);<br class="title-page-name"/>    FastTextPrediction label = model.predict("Good restaurant");<br class="title-page-name"/>    System.out.println(label.label());<br class="title-page-name"/>  }</pre>
<p class="calibre2">The output args are removed and we are giving a model as input and getting the parameters. Compile this and also copy the path to the FTZ model that we downloaded. We will test the library now:</p>
<pre class="calibre17"><strong class="calibre1">$ mvn clean package</strong><br class="title-page-name"/><strong class="calibre1">$ cp target/fasttext4j-0.2.1-SNAPSHOT.jar lib/fasttext4j-0.2.1-SNAPSHOT.jar</strong><br class="title-page-name"/><strong class="calibre1">$ time bash fasttext-mmap.sh -i &lt;path to&gt;/dbpedia.ftz</strong><br class="title-page-name"/><strong class="calibre1">__label__7</strong><br class="title-page-name"/><strong class="calibre1">bash fasttext-mmap.sh -i 0.64s user 0.11s system 168% cpu 0.444 total</strong></pre>
<p class="calibre2">There will be a lot of logs as part of the output commands. We are not showing them here for now. Just check whether there are any error messages in the logs, which will probably mark the missing dependency libraries. Also, as you can see, loading and serving predictions from the FTZ file is quite fast on my local machine. The assumption is that it will be performant in a low-performing Android app as well.</p>
<p class="calibre2">Now that we have established that the library works and is able to give predictions, remove the <kbd class="calibre12">main</kbd> method as we won't be needing it in the Android app itself. Compile the JAR and place it in the <kbd class="calibre12">lib</kbd> folder:</p>
<pre class="calibre17"><strong class="calibre1">$ mvn clean package</strong><br class="title-page-name"/><strong class="calibre1">$ mvn install -Papp</strong><br class="title-page-name"/><strong class="calibre1">$ unzip app/fasttext4j-app.zip</strong><br class="title-page-name"/><strong class="calibre1">$ cp target/fasttext4j-0.2.1-SNAPSHOT.jar lib/fasttext4j-0.2.1-SNAPSHOT.jar</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding the library dependencies to Android</h1>
                
            
            <article>
                
<p class="calibre2">Check in the <kbd class="calibre12">lib</kbd> folder. There will be placed all the libraries that are the dependencies for this project. We will need to add these dependencies to our Android application if we want to use this library.</p>
<p class="calibre2">Open <span class="calibre5">File</span> | <span class="calibre5">New</span> | <span class="calibre5">New Module...</span>:</p>
<div class="cdpaligncenter"><img src="../images/00097.jpeg" class="calibre64"/></div>
<p class="calibre2">Import the JAR/AAR package:</p>
<div class="cdpaligncenter"><img src="../images/00098.jpeg" class="calibre65"/></div>
<p class="calibre2">Now, add all the libraries in the <kbd class="calibre12">lib</kbd> folder to as dependencies. Now, your project structure should list the libraries as dependencies. Now, click on <span class="calibre5">app</span> | <span class="calibre5">dependencies</span> and add them as dependencies for the app as well. Add the library files as module dependencies:</p>
<div class="cdpaligncenter"><img src="../images/00099.jpeg" class="calibre66"/></div>
<p class="calibre2">Now that the dependencies are there, we can start using the library in our activity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using library dependencies in Android</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre5">To use the library in Android, change <kbd class="calibre12">DisplayMessageActivity.java</kbd> and write the same code that you saw in the library testing phase.</span></p>
<p class="calibre2">Before compiling, add the <kbd class="calibre12">guav<span><span>a</span></span></kbd> dependency in your <kbd class="calibre12">gradle.build</kbd> file as the <kbd class="calibre12">UnsignedLong</kbd> dependencies in the <kbd class="calibre12">guava</kbd> library:</p>
<pre class="calibre17">compile <span>'com.google.guava:guava:21.0'</span></pre>
<p class="calibre2">Also, add the compile version so that it's able to compile the Java code:</p>
<pre class="calibre17">apply <span>plugin</span>: <span>'com.android.application'<br class="title-page-name"/></span><span><br class="title-page-name"/></span>android {<br class="title-page-name"/>    compileSdkVersion <span>28<br class="title-page-name"/></span><span>    </span>defaultConfig {<br class="title-page-name"/>        ...<span><br class="title-page-name"/></span><span>    </span>}<br class="title-page-name"/>    buildTypes {<br class="title-page-name"/>        ...<br class="title-page-name"/>    }<br class="title-page-name"/>    compileOptions {<br class="title-page-name"/>        sourceCompatibility JavaVersion.<span>VERSION_1_8<br class="title-page-name"/></span><span>        </span>targetCompatibility JavaVersion.<span>VERSION_1_8<br class="title-page-name"/></span><span>    </span>}<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>dependencies {<br class="title-page-name"/>    ...<br class="title-page-name"/>    compile <span>'com.google.guava:guava:21.0'<br class="title-page-name"/></span>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Finally the app</h1>
                
            
            <article>
                
<p class="calibre2">Now, compile the app and run it on your phone. You should be able to get the changes:</p>
<div class="cdpaligncenter"><img src="../images/00100.jpeg" class="calibre67"/>     =&gt;    <img src="../images/00101.jpeg" class="calibre68"/></div>
<p class="calibre2">Lets also take a look at the APK that was created. On my machine, the app size has changed to 4.6 MB. Small enough? I will leave it to you to be the judge of that:</p>
<pre class="calibre17"><strong class="calibre1">$du -sh app-debug.apk</strong><br class="title-page-name"/><strong class="calibre1">4.6M app-debug.apk</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we took a look at the methodologies to implement fastText in a web and mobile context, focusing specifically on Android. We also took a look at the different considerations that you need to bear in mind, depending on whether you need to deploy on web or mobile. This should help you to create good applications and integrate fastText into your mobile applications.</p>


            </article>

            
        </section>
    </body></html>