<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Time Series Predicting</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we discussed <strong>Hidden Markov Models</strong> (<strong>HMMs</strong>) and various algorithms associated with inference in great theoretical detail. From this chapter onward, we will be discussing the use of HMMs.</p>
<p>HMMs are capable of predicting and analyzing time-based phenomena. Because of this, they can be used in fields such as speech recognition, natural language processing, and financial market prediction. In this chapter, we will be looking into applications of HMMs in the field of financial market analysis, mainly stock price prediction.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stock price prediction using HMM</h1>
                </header>
            
            <article>
                
<p>Stock market prediction has been one of the more active research areas in the past, given the obvious interest of a lot of major companies. Historically, various machine learning algorithms have been applied with varying degrees of success. However, stock forecasting is still severely limited due to its non-stationary, seasonal, and unpredictable nature. Predicting forecasts from just the previous stock data is an even more challenging task since it ignores several outlying factors.</p>
<p>As seen previously, HMMs are capable of modeling hidden state transitions from the sequential observed data. The problem of stock prediction can also be thought as following the same pattern. The price of the stock depends upon a multitude of factors which generally remain invisible to the investor (hidden variables). The transition between the underlaying factors change based on company policy and decisions, its financial conditions, and management decisions, and these affect the price of the stock (observed data). So HMMs are a natural fit to the problem of price prediction.</p>
<p>In this chapter, we will try to predict the stock prices for Alphabet Inc. (GOOGL), <strong>Facebook</strong> (<strong>FB</strong>), and <strong>Apple Inc.</strong> (<strong>AAPL</strong>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collecting stock price data</h1>
                </header>
            
            <article>
                
<p>We will use pystock data (<a href="http://data.pystock.com" target="_blank">http://data.pystock.com</a>) to get the historical stock prices data. Every day, before the US stock exchanges open at 9:30 EST/EDT, the pystock crawler collects the stock prices and financial reports, and pushes the data, such as the previous day's opening price, closing price, highest price, and lowest price for a given stock, to the repository. This data is day-based, meaning we won't be having any hour or minute-level data.</p>
<p>Let's try to download the <kbd>pystock</kbd> data for a given year. As the dataset is large, we will create a Python script to download the data for a given year and we can run the program simultaneously for three different years to download all the data in parallel:</p>
<pre><span>"""<br/></span><span>Usage: get_data.py --year=&lt;year&gt;<br/></span><span>"""<br/></span><span>import </span>requests<br/><span>import </span>os<br/><span>from </span>docopt <span>import </span>docopt<br/><br/># docopt helps parsing the command line argument in<br/># a simple manner (http://docopt.org/)<br/>args = docopt(<span>doc</span>=__doc__<span>, </span><span>argv</span>=<span>None,<br/></span><span>              </span><span>help</span>=<span>True, </span><span>version</span>=<span>None,<br/></span><span>              </span><span>options_first</span>=<span>False</span>)<br/><br/>year = args[<span>'--year'</span>]<br/><br/><span># Create directory if not present<br/></span>year_directory_name = <span>'data/{year}'</span>.format(<span>year</span>=year)<br/><span>if not </span>os.path.exists(year_directory_name):<br/>    os.makedirs(year_directory_name)<br/><br/><span># Fetching file list for the corresponding year<br/></span>year_data_files = requests.get(<br/>    <span>'http://data.pystock.com/{year}/index.txt'</span>.format(<span>year</span>=year)<br/>).text.strip().split(<span>'</span><span>\n</span><span>'</span>)<br/><br/><span>for </span>data_file_name <span>in </span>year_data_files:<br/>    file_location = <span>'{year_directory_name}/{data_file_name}'</span>.format(<br/>        <span>year_directory_name</span>=year_directory_name<span>,<br/></span><span>        </span><span>data_file_name</span>=data_file_name)<br/><br/>    <span>with </span><span>open</span>(file_location<span>, </span><span>'wb+'</span>) <span>as </span>data_file:<br/>        <span>print</span>(<span>'&gt;&gt;&gt; Downloading </span><span>\t</span><span> {file_location}'</span>.format(<span>file_location</span>=file_location))<br/>        data_file_content = requests.get(<br/>            <span>'http://data.pystock.com/{year}/{data_file_name}'</span>.format(<span>year</span>=year<span>, </span><span>data_file_name</span>=data_file_name)<br/>        ).content<br/>        <span>print</span>(<span>'&lt;&lt;&lt; Download Completed </span><span>\t</span><span> {file_location}'</span>.format(<span>file_location</span>=file_location))<br/>        data_file.write(data_file_content)</pre>
<p>Run the following scripts simultaneously for three different years:</p>
<pre>python get_data.py --year 2015<br/>python get_data.py --year 2016<br/>python get_data.py --year 2017</pre>
<p>Once the data is downloaded, let's try to get all the data for each of the preceding stated stocks by combining data corresponding to all the years:</p>
<pre><span>"""<br/></span><span>Usage: parse_data.py --company=&lt;company&gt;<br/></span><span>"""<br/></span><span>import </span>os<br/><span>import </span>tarfile<br/><span>import </span>pandas <span>as </span>pd<br/><span>from </span>pandas <span>import </span>errors <span>as </span>pd_errors<br/><span>from </span>functools <span>import </span>reduce<br/><span>from </span>docopt <span>import </span>docopt<br/><br/>args = docopt(<span>doc</span>=__doc__<span>, </span><span>argv</span>=<span>None,<br/></span><span>              </span><span>help</span>=<span>True, </span><span>version</span>=<span>None,<br/></span><span>              </span><span>options_first</span>=<span>False</span>)<br/><br/>years = [<span>2015</span><span>, </span><span>2016</span><span>, </span><span>2017</span>]<br/>company = args[<span>'--company'</span>]<br/><br/><br/><span># Getting the data files list<br/></span>data_files_list = []<br/><span>for </span>year <span>in </span>years:<br/>    year_directory = <span>'data/{year}'</span>.format(<span>year</span>=year)<br/>    <span>for </span>file <span>in </span>os.listdir(year_directory):<br/>        data_files_list.append(<span>'{year_directory}/{file}'</span>.format(<span>year_directory</span>=year_directory<span>, </span><span>file</span>=file))<br/><br/><br/><span>def </span><span>parse_data</span>(file_name<span>, </span>company_symbol):<br/>    <span>"""<br/></span><span>    Returns data for the corresponding company<br/></span><span><br/></span><span>    </span><span>:param</span><span> file_name: name of the tar file<br/></span><span>    </span><span>:param</span><span> company_symbol: company symbol<br/></span><span>    </span><span>:type</span><span> file_name: str<br/></span><span>    </span><span>:type</span><span> company_symbol: str<br/></span><span>    </span><span>:return</span><span>: dataframe for the corresponding company data<br/></span><span>    </span><span>:rtype</span><span>: pd.DataFrame<br/></span><span>    """<br/></span><span>    </span>tar = tarfile.open(file_name)<br/>    <span>try</span>:<br/>        price_report = pd.read_csv(tar.extractfile(<span>'prices.csv'</span>))<br/>        company_price_data = price_report[price_report[<span>'symbol'</span>] == company_symbol]<br/>        <span>return </span>company_price_data<br/>    <span>except </span>(<span>KeyError</span><span>, </span>pd_errors.EmptyDataError):<br/>        <span>return </span>pd.DataFrame()<br/><br/><br/><span># Getting the complete data for a given company<br/></span>company_data = reduce(<span>lambda </span>df<span>, </span>file_name: df.append(parse_data(file_name<span>, </span>company))<span>,<br/></span><span>                      </span>data_files_list<span>,<br/></span><span>                      </span>pd.DataFrame())<br/>company_data = company_data.sort_values(<span>by</span>=[<span>'date'</span>])<br/><br/><span># Create folder for company data if does not exists<br/></span><span>if not </span>os.path.exists(<span>'data/company_data'</span>):<br/>    os.makedirs(<span>'data/company_data'</span>)<br/><br/><span># Write data to a CSV file<br/></span>company_data.to_csv(<span>'data/company_data/{company}.csv'</span>.format(<span>company</span>=company)<span>,<br/></span><span>                    </span><span>columns</span>=[<span>'date'</span><span>, </span><span>'open'</span><span>, </span><span>'high'</span><span>, </span><span>'low'</span><span>, </span><span>'close'</span><span>, </span><span>'volume'</span><span>, </span><span>'adj_close'</span>]<span>,<br/></span><span>                    </span><span>index</span>=<span>False</span>)</pre>
<p>Run the following scripts to create a <kbd>.csv</kbd> file containing all the historical data for the <kbd>GOOGL</kbd>, <kbd>FB</kbd>, and <kbd>AAPL</kbd> stocks:</p>
<pre>python parse_data.py --company GOOGL<br/>python parse_data.py --company FB<br/>python parse_data.py --company AAPL</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Features for stock price prediction</h1>
                </header>
            
            <article>
                
<p>Once we have the data for each of the stock prices, we want to predict the price of the stock. As we mentioned earlier, we have very limited features for each day, namely the opening price of stock for that day, closing price, highest price of stock, and lowest price of stock. So we are going to use them to compute the stock prices. Generally, we want to compute the closing stock price for a day, given the opening stock price for that day, and previous some <em>d</em><span> days</span> <span>data. Our predictor would have a latency of <em>d</em> </span><span>days. </span></p>
<p><span>Let's create a predictor called </span><kbd>StockPredictor</kbd><span>, which will contain all the logic to predict the stock price for a given company during a given day. </span></p>
<p>Instead of directly using the opening, closing, low, and high prices of a stock, let's try to extract the fractional changes in each of them that would be used to train our HMM. As we move further, the reason for choosing these features will become clearer. We could define three parameters as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/1d89e031-07e8-42b2-87a5-e2fc32b9878e.png" style="width:15.17em;height:3.08em;"/></div>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/d68767ff-b9f5-4035-950b-d4c4ed216795.png" style="width:14.33em;height:3.17em;"/></div>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/e4f4c3df-861b-4997-83ac-96eb04e46704.png" style="width:13.25em;height:3.17em;"/></div>
<p>So, for the stock price predictor HMM, we can represent a single observation as a vector these parameters, namely <em>X<sub>t</sub> = &lt; frac<sub>change</sub>, frac<sub>high</sub>, frac<sub>low</sub> &gt;</em>:</p>
<pre>import pandas as pd<br/><br/>class StockPredictor(object):<br/>    def __init__(self, company, n_latency_days=10):<br/>        self._init_logger()<br/><br/>        self.company = company<br/>        self.n_latency_days = n_latency_days<br/>        self.data = pd.read_csv(<br/>            'data/company_data/{company}.csv'.format(company=self.company))<br/><br/><br/>    def _init_logger(self):<br/>        self._logger = logging.getLogger(__name__)<br/>        handler = logging.StreamHandler()<br/>        formatter = logging.Formatter(<br/>            '%(asctime)s %(name)-12s %(levelname)-8s %(message)s')<br/>        handler.setFormatter(formatter)<br/>        self._logger.addHandler(handler)<br/>        self._logger.setLevel(logging.DEBUG)<br/><br/><br/>    @staticmethod<br/>    def _extract_features(data):<br/>        open_price = np.array(data['open'])<br/>        close_price = np.array(data['close'])<br/>        high_price = np.array(data['high'])<br/>        low_price = np.array(data['low'])<br/><br/>        # Compute the fraction change in close, high and low prices<br/>        # which would be used a feature<br/>        frac_change = (close_price - open_price) / open_price<br/>        frac_high = (high_price - open_price) / open_price<br/>        frac_low = (open_price - low_price) / open_price<br/><br/>        return np.column_stack((frac_change, frac_high, frac_low))<br/><br/><br/># Predictor for GOOGL stocks<br/>stock_predictor = StockPredictor(company='GOOGL')</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Predicting price using HMM</h1>
                </header>
            
            <article>
                
<p>Once we extract the features from the data, we can now move on to predicting the price of the stock. We want to predict the closing price of a stock on a particular day, given the opening price of the stock on that day and stock prices of previous days. </p>
<p>The first step would be to train an HMM to compute the parameters from the given sequence of observations that we computed earlier. As the observations are a vector of continuous random variables, we have to assume that the emission probability distribution is continuous. For simplicity, let's assume that it is a multinomial Gaussian distribution with parameters (<em>μ</em> and <em>Σ</em>). So we have to determine the following parameters for the transition matrix, <em>A</em>, prior probabilities, <em>π</em>, along with <em>μ</em><span> and <em>Σ</em></span> which represent the multinomial Gaussian distribution. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>For now, let's assume that we have four hidden states. In the coming sections, we will look into ways of finding the optimal number of hidden states. We will use the <kbd>GaussianHMM</kbd> class provided by the <kbd>hmmlearn</kbd> package as our HMM, and we will try to perform parameter estimation using the <kbd>fit()</kbd> method provided by it:</p>
<pre>from hmmlearn.hmm import GaussianHMM<br/><br/><br/>class StockPredictor(object):<br/>    def __init__(self, company, n_latency_days=10, n_hidden_states=4):<br/>        self._init_logger()<br/><br/>        self.company = company<br/>        self.n_latency_days = n_latency_days<br/><br/>        self.hmm = GaussianHMM(n_components=n_hidden_states)<br/><br/>        self.data = pd.read_csv(<br/>            'data/company_data/{company}.csv'.format(company=self.company))<br/><br/>    def fit(self):<br/>        self._logger.info('&gt;&gt;&gt; Extracting Features')<br/>        feature_vector = StockPredictor._extract_features(self.data)<br/>        self._logger.info('Features extraction Completed &lt;&lt;&lt;')<br/><br/>        self.hmm.fit(feature_vector)</pre>
<p>In machine learning, we divide the entire dataset into two categories. The first set, the training dataset, is used to train the model. The second set, the test dataset, is used to provide an unbiased evaluation of a final model fit on the training dataset. Separating the training dataset from the test dataset prevents us from overfitting the data to the model. So, in our case, we would also split the dataset into two categories, <kbd>train_data</kbd> for training the model and <kbd>test_data</kbd> for evaluating the model. To do so, we will use the <kbd>train_test_split</kbd> method provided by the <kbd>sklearn.model_selection</kbd> module:</p>
<div class="packt_infobox"><kbd>train_test_split</kbd> can split arrays or matrices into random train and test subsets. As we are training our HMM with sequential data, we do not want to randomly split the data. To prevent random splitting of the test and train data, pass <kbd>shuffle=False</kbd> as the argument.</div>
<pre>from sklearn.model_selection import train_test_split<br/><br/><br/>class StockPredictor(object):<br/>    def __init__(self, company, test_size=0.33,<br/>                 n_latency_days=10, n_hidden_states=4):<br/>        self._init_logger()<br/><br/>        self.company = company<br/>        self.n_latency_days = n_latency_days<br/><br/>        self.hmm = GaussianHMM(n_components=n_hidden_states)<br/><br/>        self._split_train_test_data(test_size)<br/><br/>    def _split_train_test_data(self, test_size):<br/>        data = pd.read_csv(<br/>            'data/company_data/{company}.csv'.format(company=self.company))<br/>        _train_data, test_data = train_test_split(<br/>            data, test_size=test_size, shuffle=False)<br/><br/>        self._train_data = _train_data<br/>        self._test_data = test_data<br/><br/>    def fit(self):<br/>        self._logger.info('&gt;&gt;&gt; Extracting Features')<br/>        feature_vector = StockPredictor._extract_features(self._train_data)<br/>        self._logger.info('Features extraction Completed &lt;&lt;&lt;')<br/><br/>        self.hmm.fit(feature_vector)</pre>
<p>Once your model is trained, we need to predict the stock closing price. As we mentioned earlier, we want to predict the stock closing price for a day given that we know the opening price. This means that if we are able to predict <em>frac<sub>change</sub></em> for a given day, we can compute the closing price as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c2bdedc6-f140-4774-a837-75e59d9f45a3.png" style="width:19.00em;height:1.58em;"/></div>
<p>Thus our problem boils down to computing the <em>X<sub>t+1</sub><span> </span>= &lt; frac<sub>change</sub>, frac<sub>high</sub>, frac<sub>low</sub><span> </span>&gt;</em> observation vector for a day given the observation data for <em>t</em> days, <em>x<sub>1</sub>,...,x<sub>t</sub></em>, and the parameters of the HMM <img class="fm-editor-equation" src="assets/fb2a521e-09bf-4fc6-985d-87900072e99f.png" style="width:5.67em;height:1.17em;"/>, which is finding the value of <em>X<sub>t+1</sub></em> that maximizes the posterior probability <em>P(X<sub>t+1</sub>|X<sub>1</sub>,...,X<sub>t</sub>,θ)</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/29e89e8c-b429-4529-a14e-3c1f8e0c6f31.png" style="width:21.75em;height:7.25em;"/></div>
<p>As you can see, once you remove all the parameters that are i<span>ndependent of <em>X<sub>t+1</sub></em></span> from the maximization equation, we are left with the problem of finding the value of <em>X<sub>t+1</sub></em>, which optimizes the probability of <em>P(X<sub>1</sub>,...,X<sub>t+1</sub>|θ)</em>. We came across this problem in <a href="8d06a68a-e427-4f7d-9472-9be25b5351c0.xhtml" target="_blank">Chapter 4</a>, <em>Parameter Learning using Maximum Likelihood</em>, while evaluating the probability of a sequence given the model parameters. It can be computed efficiently using the forward-backward algorithm. </p>
<p>If we assume <em>frac<sub>change </sub></em>is a continuous variable, the optimization of the problem would be computationally difficult. So we can divide these fractional changes into some discrete values ranging between two finite variables (as stated in the following table) and try to find a set of fractional changes, <em>&lt; frac<sub>change</sub>, frac<sub>high</sub>, frac<sub>low</sub><span> </span>&gt;</em>, that would maximize the probability, <em>P(X<sub>1</sub>,...,X<sub>t+1</sub>|θ)</em>:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p class="mce-root"><strong>Observation</strong></p>
</td>
<td><strong>Minimum value</strong></td>
<td><strong>Maximum value</strong></td>
<td><strong>Number of points</strong></td>
</tr>
<tr>
<td><em>frac<sub>change</sub></em></td>
<td>-0.1</td>
<td>0.1</td>
<td>20</td>
</tr>
<tr>
<td><em>frac<sub>high</sub></em></td>
<td>0</td>
<td>0.1</td>
<td>10</td>
</tr>
<tr>
<td><em>frac<sub>low</sub></em></td>
<td>0</td>
<td>0.1</td>
<td>10</td>
</tr>
</tbody>
</table>
<p> </p>
<p>So, with the preceding discrete set of values, we need to run (20 x 10 x 10 =) 2,000 operations:</p>
<pre>def _compute_all_possible_outcomes(self, n_steps_frac_change,<br/>                                       n_steps_frac_high, n_steps_frac_low):<br/>        frac_change_range = np.linspace(-0.1, 0.1, n_steps_frac_change)<br/>        frac_high_range = np.linspace(0, 0.1, n_steps_frac_high)<br/>        frac_low_range = np.linspace(0, 0.1, n_steps_frac_low)<br/><br/>        self._possible_outcomes = np.array(list(itertools.product(<br/>            frac_change_range, frac_high_range, frac_low_range)))</pre>
<p>Now we can implement the method to predict the closing price, as follows:</p>
<pre>def _get_most_probable_outcome(self, day_index):<br/>        previous_data_start_index = max(0, day_index - self.n_latency_days)<br/>        previous_data_end_index = max(0, day_index - 1)<br/>        previous_data = self._test_data.iloc[previous_data_end_index: previous_data_start_index]<br/>        previous_data_features = StockPredictor._extract_features(<br/>            previous_data)<br/><br/>        outcome_score = []<br/>        for possible_outcome in self._possible_outcomes:<br/>            total_data = np.row_stack(<br/>                (previous_data_features, possible_outcome))<br/>            outcome_score.append(self.hmm.score(total_data))<br/>        most_probable_outcome = self._possible_outcomes[np.argmax(<br/>            outcome_score)]<br/><br/>        return most_probable_outcome<br/><br/>    def predict_close_price(self, day_index):<br/>        open_price = self._test_data.iloc[day_index]['open']<br/>        predicted_frac_change, _, _ = self._get_most_probable_outcome(<br/>            day_index)<br/>        return open_price * (1 + predicted_frac_change)</pre>
<p>Let's try to predict the closing price for a some days and plot both the curves:</p>
<pre>"""<br/>Usage: analyse_data.py --company=&lt;company&gt;<br/>"""<br/>import warnings<br/>import logging<br/>import itertools<br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from hmmlearn.hmm import GaussianHMM<br/>from sklearn.model_selection import train_test_split<br/>from tqdm import tqdm<br/>from docopt import docopt<br/><br/>args = docopt(doc=__doc__, argv=None, help=True,<br/>              version=None, options_first=False)<br/><br/># Supress warning in hmmlearn<br/>warnings.filterwarnings("ignore")<br/># Change plot style to ggplot (for better and more aesthetic visualisation)<br/>plt.style.use('ggplot')<br/><br/><br/>class StockPredictor(object):<br/>    def __init__(self, company, test_size=0.33,<br/>                 n_hidden_states=4, n_latency_days=10,<br/>                 n_steps_frac_change=50, n_steps_frac_high=10,<br/>                 n_steps_frac_low=10):<br/>        self._init_logger()<br/><br/>        self.company = company<br/>        self.n_latency_days = n_latency_days<br/><br/>        self.hmm = GaussianHMM(n_components=n_hidden_states)<br/><br/>        self._split_train_test_data(test_size)<br/><br/>        self._compute_all_possible_outcomes(<br/>            n_steps_frac_change, n_steps_frac_high, n_steps_frac_low)<br/><br/>    def _init_logger(self):<br/>        self._logger = logging.getLogger(__name__)<br/>        handler = logging.StreamHandler()<br/>        formatter = logging.Formatter(<br/>            '%(asctime)s %(name)-12s %(levelname)-8s %(message)s')<br/>        handler.setFormatter(formatter)<br/>        self._logger.addHandler(handler)<br/>        self._logger.setLevel(logging.DEBUG)<br/><br/>    def _split_train_test_data(self, test_size):<br/>        data = pd.read_csv(<br/>            'data/company_data/{company}.csv'.format(company=self.company))<br/>        _train_data, test_data = train_test_split(<br/>            data, test_size=test_size, shuffle=False)<br/><br/>        self._train_data = _train_data<br/>        self._test_data = test_data<br/><br/>    @staticmethod<br/>    def _extract_features(data):<br/>        open_price = np.array(data['open'])<br/>        close_price = np.array(data['close'])<br/>        high_price = np.array(data['high'])<br/>        low_price = np.array(data['low'])<br/><br/>        # Compute the fraction change in close, high and low prices<br/>        # which would be used a feature<br/>        frac_change = (close_price - open_price) / open_price<br/>        frac_high = (high_price - open_price) / open_price<br/>        frac_low = (open_price - low_price) / open_price<br/><br/>        return np.column_stack((frac_change, frac_high, frac_low))<br/><br/>    def fit(self):<br/>        self._logger.info('&gt;&gt;&gt; Extracting Features')<br/>        feature_vector = StockPredictor._extract_features(self._train_data)<br/>        self._logger.info('Features extraction Completed &lt;&lt;&lt;')<br/><br/>        self.hmm.fit(feature_vector)<br/><br/>    def _compute_all_possible_outcomes(self, n_steps_frac_change,<br/>                                       n_steps_frac_high, n_steps_frac_low):<br/>        frac_change_range = np.linspace(-0.1, 0.1, n_steps_frac_change)<br/>        frac_high_range = np.linspace(0, 0.1, n_steps_frac_high)<br/>        frac_low_range = np.linspace(0, 0.1, n_steps_frac_low)<br/><br/>        self._possible_outcomes = np.array(list(itertools.product(<br/>            frac_change_range, frac_high_range, frac_low_range)))<br/><br/>    def _get_most_probable_outcome(self, day_index):<br/>        previous_data_start_index = max(0, day_index - self.n_latency_days)<br/>        previous_data_end_index = max(0, day_index - 1)<br/>        previous_data = self._test_data.iloc[previous_data_end_index: previous_data_start_index]<br/>        previous_data_features = StockPredictor._extract_features(<br/>            previous_data)<br/><br/>        outcome_score = []<br/>        for possible_outcome in self._possible_outcomes:<br/>            total_data = np.row_stack(<br/>                (previous_data_features, possible_outcome))<br/>            outcome_score.append(self.hmm.score(total_data))<br/>        most_probable_outcome = self._possible_outcomes[np.argmax(<br/>            outcome_score)]<br/><br/>        return most_probable_outcome<br/><br/>    def predict_close_price(self, day_index):<br/>        open_price = self._test_data.iloc[day_index]['open']<br/>        predicted_frac_change, _, _ = self._get_most_probable_outcome(<br/>            day_index)<br/>        return open_price * (1 + predicted_frac_change)<br/><br/>    def predict_close_prices_for_days(self, days, with_plot=False):<br/>        predicted_close_prices = []<br/>        for day_index in tqdm(range(days)):<br/>            predicted_close_prices.append(self.predict_close_price(day_index))<br/><br/>        if with_plot:<br/>            test_data = self._test_data[0: days]<br/>            days = np.array(test_data['date'], dtype="datetime64[ms]")<br/>            actual_close_prices = test_data['close']<br/><br/>            fig = plt.figure()<br/><br/>            axes = fig.add_subplot(111)<br/>            axes.plot(days, actual_close_prices, 'bo-', label="actual")<br/>            axes.plot(days, predicted_close_prices, 'r+-', label="predicted")<br/>            axes.set_title('{company}'.format(company=self.company))<br/><br/>            fig.autofmt_xdate()<br/><br/>            plt.legend()<br/>            plt.show()<br/><br/>        return predicted_close_prices<br/><br/><br/>stock_predictor = StockPredictor(company=args['--company'])<br/>stock_predictor.fit()<br/>stock_predictor.predict_close_prices_for_days(500, with_plot=True)</pre>
<p>The output is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/190f7477-da9b-4be8-9916-3f263cc2cbb8.png" style="width:51.50em;height:32.17em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we predicted the price of stocks using HMM. We applied the parameter-estimation and evaluation-of-model methods to determine the closing price of a stocks. Using HMM in stock market analysis is just another example of the application of HMM in analyzing time series data. </p>
<p>In the next chapter, we will look at an interesting application of HMM in the field of natural language processing. </p>


            </article>

            
        </section>
    </body></html>