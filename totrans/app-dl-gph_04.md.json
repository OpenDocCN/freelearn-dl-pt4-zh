["```py\nimport torch\nimport torch.nn.functional as F\nfrom torch_geometric.datasets import Planetoid\nfrom torch_geometric.nn import GCNConv\n# Load the Cora dataset\ndataset = Planetoid(root='data/Cora', name='Cora')\n```", "```py\n# Get the graph data\ndata = dataset[0]\n# Print some statistics about the graph\nprint(f'Number of nodes: {data.num_nodes}')\nprint(f'Number of edges: {data.num_edges}')\nprint(f'Number of features: {data.num_features}')\nprint(f'Number of classes: {dataset.num_classes}')\n```", "```py\nNumber of nodes: 2708\nNumber of edges: 10556\nNumber of features: 1433\nNumber of classes: 7\n```", "```py\n# Define the GCN model\nclass GCN(torch.nn.Module):\n    def __init__(self, in_channels, hidden_channels, out_channels):\n        super(GCN, self).__init__()\n        self.conv1 = GCNConv(in_channels, hidden_channels)\n        self.conv2 = GCNConv(hidden_channels, out_channels)\n    def forward(self, x, edge_index):\n        x = self.conv1(x, edge_index)\n        x = F.relu(x)\n        x = F.dropout(x, training=self.training)\n        x = self.conv2(x, edge_index)\n        return F.log_softmax(x, dim=1)\n```", "```py\n# Set the model parameters\nin_channels = dataset.num_node_features\nhidden_channels = 16\nout_channels = dataset.num_classes\n# Create an instance of the GCN model\nmodel = GCN(in_channels, hidden_channels, out_channels)\n```", "```py\n# Define the optimizer and loss function\noptimizer = torch.optim.Adam(\n    model.parameters(), lr=0.01, weight_decay=5e-4)\ncriterion = torch.nn.NLLLoss()\n# Train the model\nmodel.train()\nfor epoch in range(200):\n    optimizer.zero_grad()\n    out = model(data.x, data.edge_index)\n    loss = criterion(out[data.train_mask],\n                     data.y[data.train_mask])\n    loss.backward()\n    optimizer.step()\n```", "```py\n    # Evaluate the model\n    model.eval()\n    _, pred = model(data.x, data.edge_index).max(dim=1)\n    correct = float(pred[data.test_mask].eq(\n        data.y[data.test_mask]).sum().item())\n    accuracy = correct / data.test_mask.sum().item()\n    print(f'Accuracy: {accuracy:.4f}')\n    Accuracy: 0.8000\n    ```", "```py\n    from torch_geometric.nn import SAGEConv\n    ```", "```py\n    # Define the GraphSAGE model\n    class GraphSAGE(torch.nn.Module):\n        def __init__(self, in_channels, hidden_channels,\n                     out_channels):\n            super(GraphSAGE, self).__init__()\n            self.conv1 = SAGEConv(in_channels, hidden_channels)\n            self.conv2 = SAGEConv(hidden_channels, out_channels)\n        def forward(self, x, edge_index):\n            x = self.conv1(x, edge_index)\n            x = F.relu(x)\n            x = F.dropout(x, training=self.training)\n            x = self.conv2(x, edge_index)\n            return F.log_softmax(x, dim=1)\n    ```", "```py\n    # Create an instance of the GraphSAGE model\n    model = GraphSAGE(in_channels, hidden_channels, out_channels)\n    ```", "```py\nclass GAT(torch.nn.Module):\n    def __init__(self, in_channels, hidden_channels,\n                 out_channels, heads=8, dropout=0.6):\n        super(GAT, self).__init__()\n        self.conv1 = GATConv(\n            in_channels, hidden_channels,\n            heads=heads, dropout=dropout)\n        self.conv2 = GATConv(\n            hidden_channels * heads, out_channels,\n            heads=1, dropout=dropout)\n    def forward(self, x, edge_index):\n        x = self.conv1(x, edge_index)\n        x = F.elu(x)\n        x = F.dropout(x, training=self.training)\n        x = self.conv2(x, edge_index)\n        return F.log_softmax(x, dim=1)\n```"]