- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Demystifying Generated Code for Readability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delves into making LLM-generated code less ambiguous, and more
    accessible and comprehensible. We’ll explore techniques to enhance the explainability
    of code from LLMs, ensuring the logic and decision-making behind LLM-generated
    code are clear. By aiding a better understanding of code from LLMs, the chapter
    aims to promote transparency and trust in software development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has bad and good code and prompt examples.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you gain insights into strategies for improving the readability
    of code from LLMs, nurturing a collaborative and informed approach to leveraging
    these powerful language models in coding practices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: From this chapter, you should learn how to use LLMs/chatbots to generate more
    readable code and summarize lengthy code blocks for understanding by humans using
    LLMs to create documentation and comments to aid readability.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Generating more readable code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summarizing code for understanding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating documentation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you’ll need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Access to an LLM/chatbot such as GPT-4, Gemini, or Claude 3 – each requires
    a login. For GPT-4, you’ll need an OpenAI account, and for Gemini, you’ll need
    a Google account.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python IDE such as Spyder, IDLE, PyCharm, Eclipse, or Visual Studio. An online
    interpreter will not be good enough here.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An HTML interpreter, such as [https://htmledit.squarefree.com/](https://htmledit.squarefree.com/)
    , [https://onecompiler.com/html](https://onecompiler.com/html) , or [https://www.w3schools.com/tryit/](https://www.w3schools.com/tryit/)
    , or a website editor: Wix, GoDaddy, One.com, and so on.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get the code in this book here: [https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s find out how to use Claude, Gemini, and ChatGPT to start off well
    and write code that is very readable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Generating more readable code
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to generate code that others can easily
    read and get moving without them having to ponder its inner workings for hours.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: If we are writing code, we want it to be used and that means it should be understood
    by other people, especially if we want someone to expand upon it. They’re much
    more likely to bother if we make our code easy to read.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In the subsection *Code to compress data, written in Python 3.10* , we’ll ask
    an LLM for some code to compress data, but first, here’s an intro to what data
    compression is, so we know a bit more about what we’re doing. Data compression
    is important for using devices and the internet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to data compression methods
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s some background on what data compression is so that the following section
    is easier to understand.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Lossless data compression
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lossless data compression means the signal and the noise are compressed, nothing
    is lost, and everything can be re-created [ *Wiki_LZMA2* ].
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of lossless compression would be a dataset like this: [1,1,1,1,1,1,1….1,1,1,1,1,1,0,0,0,0,0,0…].'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: This dataset could have any number of ones and any number of zeros, but a value
    can be represented by just the count of each and the name of each. If there were
    213 ones and 789 zeros, the lossless compression method **Run-Length Encoding**
    ( **RLE** ) would call it [(213, 1), (789,0)]. The data is now just 4 numbers,
    not 213+789 = 1,002 numbers, which is a compression ratio of 1002/4 = 250.5 [
    *WikiDataComp* ]. This has managed a good compression ratio without losing anything.
    This could be real data, for example, the answer to the question, “Is the windscreen
    wiper on?”.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Use lossless compression when you have a signal that tends to be constant for
    a long while. If you use it for very precise or always varying data, it’ll, instead,
    take up more space on your drive!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: LZMA is another type of lossless compression method, which we shall use in a
    moment.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Lossy compression
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A second type of compression is called lossy compression, where the algorithm
    or method tries to keep the signal and eliminate some level of noise. For lossy
    compression, there can be different levels of compression, offering a trade-off
    of fidelity and file size: more compression means less fidelity – more of the
    signal and noise are thrown out or zeroed.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Examples of lossy compression include **Discrete Fourier Transforms** ( **DFTs**
    ), **Discrete Wavelet Transforms** ( **DWTs** ), or, best yet, **Discrete Cosine
    Transforms** ( **DCTs** ) [ *Wiki_Wavelets* ].
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: DCTs are used in a lot of standard compression methods for images ( **JPEG**
    ), video ( **MPEG** ), audio (Dolby Digital, MP3, AAC), digital television (HDTV,
    SDTV), and digital radio (AAC+, DAB) [Wiki_Cosine].
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'DCTs transform data from changing over time to being made up of lots of cosine
    waves of differing frequencies. It sounds ridiculously simple, but you can represent
    most things this way. I did simplify it. You generally keep the low-frequency
    waves and zero out the high-frequency waves, which are assumed to be noise. Then
    the signal is changed back to the original time-based form: varying over time.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: If you want more fidelity – a better signal – you’ll zero out fewer of the high-frequency
    waves but will have to suffer a file size that’s not reduced much. If you really
    need a small file size, you’ll zero out more waves but that’ll leave you with
    a worse signal, image, or sound. Another way to look at the compression ratio
    is the bit rate, measured in bits/second. A higher bit rate can give a higher
    quality stream of data (e.g., video or sound) and, if it’s stored in a file, this
    means larger file sizes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, instead of zeroing the values, you can quantize them. Here, rather
    than having highly precise values, you could turn them into less precise values
    – for example, 3.48724 could fit into the [3.4 to 3.5] bin or, even less precise,
    the [3 to 4] bin. The values become a histogram – discrete and not so continuous.
    This saves space.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以选择量化它们，而不是将值置零。在这里，值不再是精确的，而是变得不那么精确——例如，3.48724可以适合到[3.4到3.5]这个范围，甚至更不精确的[3到4]这个范围。值变成了一个直方图——离散的而不是连续的。这可以节省空间。
- en: To get the ideal compressed data, there needs to be a balance between good compression
    and a good quality of signal, image, or video.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得理想的压缩数据，需要在良好的压缩和良好的信号、图像或视频质量之间找到平衡。
- en: Learned compression or neural compression
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习压缩或神经压缩
- en: A third type of compression is learned compression, where an ML method tries
    to learn what the signal is and keep that, at the expense of the noise.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种压缩方式是学习压缩，在这种方法中，ML方法试图学习信号是什么，并保留它，同时牺牲噪声。
- en: The first two kinds of compression, lossless and lossy, are rule based, but
    in learned compression, neural networks are used to learn the patterns in the
    data and extract specific statistical properties. These learned methods are more
    adaptive [Gemini]. When I compressed tables or files of data with lossless and
    lossy methods, I had to try different methods and select the best method for each
    type of data [ *Taylor_2022* ]. This is an excellent method but is less adaptive
    than learned compression.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种压缩方式，无损压缩和有损压缩，都是基于规则的，但在学习压缩中，神经网络被用来学习数据中的模式并提取特定的统计属性。这些学习方法更具适应性 [Gemini]。当我用无损和有损方法压缩表格或数据文件时，我必须尝试不同的方法并为每种数据类型选择最佳的方法
    [*Taylor_2022*]。这是一种很好的方法，但比学习压缩的适应性差。
- en: Learned compression models are more adaptable and the model can continuously
    learn, thus improving with new data [ *Gemini* ].
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 学习压缩模型更具适应性，模型可以不断学习，因此随着新数据的加入而改进 [*Gemini*]。
- en: A method of learned compression is the **autoencoder** ( **AE** ). It is a palindromic
    or mirror-shaped neural network that takes in data, compresses it in a tiny space
    – a **latent space** , then reproduces the input data. The output layer looks
    like and is the same size as the input layer. These are the biggest layers, with
    layers reducing in size toward the middle, similar to two triangles, or perhaps
    a bowtie. This is useful because the latent space is a really compressed version
    of the data – there’s no space for excess! The first side or triangle is the encoder
    and the second side is the decoder. The encoder first compresses the data, then
    the decoder reconstructs the input data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一种学习压缩方法是**自编码器**（**AE**）。它是一个回文或镜像形状的神经网络，接受数据，将其压缩到一个小空间——**潜在空间**，然后再重建输入数据。输出层看起来与输入层相同，且大小相同。这些是最大的层，其他层在中间逐渐变小，类似两个三角形，或者像一个蝴蝶结。这很有用，因为潜在空间是数据的压缩版本——没有多余的空间！第一边或三角形是编码器，第二边是解码器。编码器首先压缩数据，然后解码器重建输入数据。
- en: In learned compression, the balance between good compression and good quality
    is the loss function [ *Ioijilai* ].
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习压缩中，良好的压缩与良好的质量之间的平衡是损失函数 [*Ioijilai*]。
- en: Advantages of learned compression
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 学习压缩的优势
- en: '**Adaptability** : Unlike more traditional compression methods, learned compression
    models can adapt to complex and diverse data types, such as scientific data, because
    of relationships between variables.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应性**：与更传统的压缩方法不同，学习压缩模型可以适应复杂和多样的数据类型，比如科学数据，因为变量之间存在关系。'
- en: '**Efficiency** : Learned compression models can sometimes compress better than
    older methods:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：学习压缩模型有时能比旧方法压缩得更好：'
- en: Learned models can learn the statistical properties of language and underlying
    structures in audio data, so can compress data more efficiently.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习型模型可以学习语言的统计特性和音频数据中的潜在结构，因此可以更高效地压缩数据。
- en: '**Convolutional Neural Networks** ( **CNNs** ) are especially adept at detecting
    patterns and redundancies in images and videos, so can compress more effectively
    than JPEG and MPEG. The effect is more pronounced in higher-resolution data.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷积神经网络**（**CNNs**）特别擅长检测图像和视频中的模式和冗余，因此比JPEG和MPEG压缩更有效。在更高分辨率的数据中，这种效果更加明显。'
- en: Overall, the higher possible complexity of ML models can enable the learning
    of more intricate structures, leading to better compression.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体来说，ML模型可能更高的复杂度能够学习更复杂的结构，从而实现更好的压缩。
- en: '**Generating data** : Decoders can create more data examples like the input
    data.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成数据**：解码器可以创建更多的数据示例，就像输入数据一样。'
- en: Disadvantages of learned compression
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 学习压缩的缺点
- en: '**Complexity** : It can be more effective, but it is also more difficult to
    understand.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：它可能更有效，但也更难理解。'
- en: '**Computational costs** : These ML models can be very expensive to train and
    run. This is a bigger disadvantage for applications that require real-time processing,
    such as autonomous vehicles. You might well have to deploy a simplified and optimized
    trained model to the edge or use specially designed hardware.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算成本**：这些 ML 模型可能非常昂贵，需要大量的训练和运行成本。这对于需要实时处理的应用程序（如自动驾驶车辆）是一个更大的劣势。您可能需要将简化和优化的训练模型部署到边缘或使用专门设计的硬件。'
- en: '**Lossy** : Learned compression can be lossy. This means the trade-off between
    quality and compression needs to be struck.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有损**：学习压缩可以是有损的。这意味着需要在质量和压缩之间达成平衡。'
- en: 'My background includes creating data compression software. Working with others
    at the University of Warwick, I created data compression software methodologies
    for Jaguar Land Rover and Onsemi, an American semiconductor manufacturer. If you
    want to know more, I’ve got a paper or two on compression, as well as other ML
    research here: [https://scholar.google.com/citations?user=9lCeU94AAAAJ&hl](https://scholar.google.com/citations?user=9lCeU94AAAAJ&hl)
    .'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我的背景包括创建数据压缩软件。与华威大学的其他人一起工作，我为捷豹路虎和安森美半导体制造商创建了数据压缩软件方法论。如果您想了解更多信息，我在压缩方面有一两篇论文，以及其他
    ML 研究，请访问此处：[https://scholar.google.com/citations?user=9lCeU94AAAAJ&hl](https://scholar.google.com/citations?user=9lCeU94AAAAJ&hl)。
- en: After compression, you can store or transmit data. But to get the data back,
    you’ll need to decompress it, usually.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩后，您可以存储或传输数据。但是要取回数据，通常需要解压缩。
- en: Now, let’s get some code to do compression ourselves.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取一些自行进行压缩的代码。
- en: Code to compress data, written in Python 3.10
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用Python 3.10编写的数据压缩代码
- en: 'There are at least three types of data compression: lossless compression, lossy
    compression, and learned compression.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有三种类型的数据压缩：无损压缩、有损压缩和学习压缩。
- en: Let’s try the following code (see “Claude 3 provides the following output”);
    this is to compress data and make it smaller on file with a commonly used compression
    algorithm called the **Lempel-Ziv-Markov chain algorithm** or **LZMA2** . For
    this code, we will use lossless data compression, courtesy of LZMA.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下代码（参见“克劳德 3 提供以下输出”）；这是使用一种常用的压缩算法**Lempel-Ziv-Markov 链算法**或**LZMA2**来压缩数据并使其在文件中变小。对于这段代码，我们将使用无损数据压缩，感谢LZMA。
- en: LZMA2 is more powerful than LZMA; it’s a container format for uncompressed and
    LZMA data, as well as the compression of data that’s partially incompressible
    [ *Wiki_LZMA2, Taylor_2022* ].
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: LZMA2比LZMA更强大；它是一个用于未压缩和LZMA数据的容器格式，以及部分无法压缩的数据的压缩[ *Wiki_LZMA2，Taylor_2022*
    ]。
- en: Anyway, the code here should compress data with LZMA2.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在这里的代码应该使用 LZMA2 压缩数据。
- en: The code is courtesy of the Claude 3 LLM.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码由克劳德 3 LLM 提供。
- en: Asking Claude 3 to write some bad code
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求克劳德 3 写一些糟糕的代码
- en: Let’s start with how to get code that works but is hard to read. This is to
    compare it with code that you might have already but could be more explainable.
    LLMs will hopefully never give you this kind of code unless you explicitly ask
    for poorly written code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从如何获得功能正常但难以阅读的代码开始。这是为了将其与您可能已经拥有但可能更易于解释的代码进行比较。希望 LLMs 永远不会给您这种类型的代码，除非您明确要求编写质量较差的代码。
- en: 'We will use the following prompt:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下提示：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Claude 3 provides the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 克劳德 3 提供以下输出：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can find this code in the **LZMAcompress_bad.py** file in our GitHub repo
    found here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的 GitHub 仓库中的**LZMAcompress_bad.py**文件中找到此代码，位置在这里：
- en: '[https://github.com/PacktPublishing/Coding-with-ChatGPT-and-Other-LLMs/tree/main/Chapter4//LZMAcompress_bad.py](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-Other-LLMs/tree/main/Chapter4//LZMAcompress_bad.py)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Coding-with-ChatGPT-and-Other-LLMs/tree/main/Chapter4//LZMAcompress_bad.py](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-Other-LLMs/tree/main/Chapter4//LZMAcompress_bad.py)'
- en: This code took a few rounds of debugging, but what you have here works for the
    little toy dataset given. Claude 3 was very helpful. It made one mistake not correcting
    a bug, but the whole process was very easy. You just need to mention the code
    again if the chatbot has already seen it or paste it into the chat field if it’s
    not been seen, then state the problem, giving the line the error message says
    the error is about. Then, the chatbot should give a better version of the code.
    Do this until the code works nicely for you, then test it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: There’s not much commenting. The variable and function names are really unclear.
    It sometimes does a great deal in one line, and in a **for** statement line at
    that! Conditional statements shouldn’t have calculations or string operations
    in them! It prints **G** at the end, whatever that is. Variables are sometimes
    single lowercase letters and sometimes single uppercase letters – no convention.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: I don’t really like that the ages are strings – couldn’t they be **ints** or
    at least **floats** ?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: It’s using **try/except** , which is good, and it’s using different functions,
    which are not large, so the code is not necessarily poor from an operation point
    of view.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: I’m not sure if **l()** will always return something.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: This code is really unclear. I would have to look at it for a while to figure
    out what’s going on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: It uses **for** statements, which are unpopular because they’re slow in languages
    like Python compared with vectorized ways.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Well, that’s what I caught from a quick look.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Here is what Claude 3 says about its own example of bad code
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The intentionally obfuscated and poorly written code that compresses tabular
    data using the LZMA2 algorithm in Python 3.10 exhibits several characteristics
    that make it hard to read and understand. Here are some of the main issues with
    the code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**Poor variable naming** : The code uses single-letter variable names such
    as **a, b, c, d, e, f, m, n, o, p, q, r, s, t, u, v, w, x, y,** and **z** , which
    provide no meaningful information about the purpose or content of the variables.
    This makes it extremely difficult to understand what each variable represents
    or what it’s being used for.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of comments** : The code is completely devoid of comments or docstrings,
    which would normally provide explanations of the code’s purpose, functionality,
    and logic. Without any comments, it becomes a guessing game to understand what
    the code is trying to accomplish.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convoluted logic** : The logic for compressing and decompressing the tabular
    data is spread across multiple functions ( **j, l,** and **k** ) and is unnecessarily
    complex. The code uses nested list comprehensions, unnecessary type conversions,
    and obscure operations that make it challenging to follow the flow of execution.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Violation of coding conventions** : The code violates several Python coding
    conventions and best practices, such as using meaningful variable names, proper
    indentation and formatting, and separation of concerns. This makes it harder for
    developers familiar with Python conventions to understand the code.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of error handling** : The code does not include any error handling mechanisms
    or exception handling, which can lead to unexpected behavior and crashes in the
    case of errors or edge cases.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixing of functionality** : The code mixes functionality related to compression,
    decompression, and data manipulation, making it harder to follow and maintain.
    Ideally, these concerns should be separated into distinct functions or modules.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Obscure type annotations** : While the code uses type annotations, the annotations
    themselves are obscure and unhelpful due to the poor variable naming conventions
    – for example, the type annotation **Any** is used for all variables, which defeats
    the purpose of type annotations.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unnecessary complexity** : The code introduces unnecessary complexity by
    using obscure techniques and terse expressions, sacrificing readability for brevity.
    This makes it harder for developers to understand and maintain the code, especially
    if they are unfamiliar with such techniques.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of modularity** : The code is not designed in a modular way, making
    it difficult to integrate or reuse in larger applications or libraries.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited extensibility** : Due to the obfuscated nature of the code and the
    lack of proper documentation or comments, it becomes challenging to extend or
    modify the code without risking unintended consequences or introducing new bugs.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the code exhibits numerous examples of poor coding practices and intentional
    obfuscation, making it extremely difficult to read, understand, and maintain.
    While this exercise is valuable for understanding the challenges of working with
    poorly written code, it serves as a reminder of the importance of writing clear,
    readable, and well-documented code in real-world software development scenarios.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: That was the end of the Claude 3 output.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Next, we must get some code that both works well and is easy to read, following
    good practices. Again, I went with the best coder LLM at the time, Claude 3.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some well-written code
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now ask Claude 3 for some good code like the preceding: data compression
    with Python:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Claude 3 gives us the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code executes successfully. You can find this code in the **LZMAcompress_good.py**
    file in the GitHub repo here: [https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4//LZMAcompress_good.py](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4//LZMAcompress_good.py)
    .'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: What Claude 3 says about its own good code
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This code is easy to read and understand for the following reasons:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '**Clear function names** : The function names **compress_tabular_data** and
    **decompress_tabular_data** clearly describe the purpose of each function'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰的函数名称**：函数名**compress_tabular_data**和**decompress_tabular_data**清楚地描述了每个函数的目的。'
- en: '**Type hints** : The code uses type hints to specify the expected types of
    function arguments and return values, making it easier to understand the input
    and output formats'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型提示**：代码使用类型提示来指定函数参数和返回值的预期类型，使得理解输入和输出格式更加容易。'
- en: '**Docstrings** : Each function has a docstring that provides a brief description
    of the function’s purpose, its arguments, and its return value'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档字符串**：每个函数都有一个文档字符串，简要描述了函数的目的、参数和返回值。'
- en: '**Meaningful variable names** : The variable names used in the code are descriptive
    and self-explanatory, making it easier to understand what each variable represents'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有意义的变量名**：代码中使用的变量名具有描述性，能够自解释，使得理解每个变量的含义变得更容易。'
- en: '**Separation of concerns** : The code separates the compression and decompression
    logic into two distinct functions, making it easier to maintain and extend'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：代码将压缩和解压缩逻辑分成了两个独立的函数，使得维护和扩展变得更加容易。'
- en: '**Proper indentation and formatting** : The code is properly indented and formatted,
    making it readable and visually appealing'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确的缩进和格式化**：代码的缩进和格式化正确，使得代码可读且视觉上令人愉悦。'
- en: '**Error handling** : While not explicitly shown in this example, the code can
    be extended to include error-handling mechanisms to handle potential exceptions
    or errors during compression or decompression.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：虽然在这个示例中没有明确显示，但代码可以扩展以包括错误处理机制，以处理在压缩或解压缩过程中可能出现的异常或错误。'
- en: '**Modular design** : The code is designed in a modular way, allowing for easy
    integration into larger applications or libraries.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化设计**：代码以模块化的方式设计，便于集成到更大的应用程序或库中。'
- en: '**Use of standard library** : The code uses the standard **lzma** module from
    the Python standard library, which is well-documented and widely used'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用标准库**：代码使用了 Python 标准库中的标准**lzma**模块，该模块有良好的文档支持并被广泛使用。'
- en: '**Example usage** : The code includes an example usage in the **if __name__
    == ''__main__''** block, making it easy to understand how to use the functions'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例用法**：代码在**if __name__ == ''__main__''**块中包含了一个示例用法，使得理解如何使用这些函数变得更加容易。'
- en: Overall, this code follows best practices for writing clean, readable, and maintainable
    Python code. It should be easy to understand for developers familiar with Python
    and the LZMA2 compression algorithm.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，这段代码遵循了编写干净、可读且易于维护的 Python 代码的最佳实践。对于熟悉 Python 和 LZMA2 压缩算法的开发者来说，应该很容易理解。
- en: That was the end of the Claude 3 output and our discussion of what is good about
    its more readable version of the LZMA compression code in Python.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Claude 3 输出的结束以及我们讨论其更具可读性版本的 Python LZMA 压缩代码的优点。
- en: Now, let’s get to specific points that make code easy or hard to read and understand.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看一些具体的因素，这些因素使得代码容易或难以阅读和理解。
- en: What makes code hard or easy to read?
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么因素使得代码容易或难以阅读？
- en: Let’s look at some practices that might lead to poor readability, and then we’ll
    look at how to get the readability as good as possible.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些可能导致可读性差的实践，然后再看看如何使可读性尽可能好。
- en: Why is reading code hard?
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么阅读代码会很难？
- en: 'Reading code is much harder than writing code for at least three reasons:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读代码比写代码要困难得多，至少有三个原因：
- en: When writing code, you have to keep in mind the variables, algorithms, data,
    and structure of the feature you’re writing only. When reading code, you must
    keep in mind all the information about wider functionality and potential functionalities
    that you’ve guessed from your reading of the code so far.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写代码时，你只需要关注你正在编写的功能的变量、算法、数据和结构。而阅读代码时，你必须记住所有关于更广泛功能和潜在功能的信息，这是你从阅读代码中猜测出来的。
- en: Thinking is easier than understanding someone else’s thinking – vastly easier.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思考比理解别人思考的过程要容易——要简单得多。
- en: It’s not your code – your baby, so it’s probably not as good as something you
    could write, or at least that’s the thinking of many programmers. That’s the emotional
    aspect. Alternatively, you might be thinking that the code is written by someone
    more intelligent and experienced, so you’ll not be able to understand it.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那不是你的代码——你的“孩子”，所以它可能不如你自己写的好，至少这是很多程序员的想法。这是情感方面的因素。或者，你可能会认为这段代码是由一个更聪明、更有经验的人编写的，所以你无法理解它。
- en: To understand someone else’s code, you need a working model of the code in your
    mind, as well as the aims of the project [ *GameDev_Dieterich* ].
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解别人的代码，你需要在脑中有一个代码的工作模型，并了解项目的目标 [ *GameDev_Dieterich* ]。
- en: Don’t be afraid to read other people’s code and get an understanding of it.
    You may well make good use of it and not have to re-write the code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕阅读他人的代码并理解它。你可能会很好地利用它，而不必重新编写代码。
- en: This reminds me of the time I had to read and use code from colleagues in Czechia.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想起了我曾经需要阅读并使用来自捷克同事的代码的时光。
- en: In addition to trying to understand the C code (when I would normally code in
    C#, R, or MATLAB) and learn some more physics, some of the variables were in Czech,
    which I don’t speak. So, I had to learn some Czech too. Fortunately, I enjoy learning
    languages and already know plenty about physics. Eventually, I understood the
    code and we worked together well, including visits to each other’s countries,
    UK and Czechia. We got some great products made.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了试图理解C代码（而我通常用C#、R或MATLAB编程）并学习一些物理知识外，其中一些变量是捷克语的，而我不懂捷克语。所以，我还得学一点捷克语。幸运的是，我喜欢学习语言，也已经对物理有一定了解。最终，我理解了代码，我们的合作也非常顺利，包括互访各自的国家，英国和捷克。我们做出了一些很棒的产品。
- en: Of course, if you can communicate with the original coder, you can ask them
    questions about it. Be polite – it’s their baby, which they might have taken a
    lot of time and energy to create.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你可以与原始编码者沟通，你可以向他们询问代码问题。要有礼貌——那是他们的心血结晶，他们可能花了很多时间和精力来创建它。
- en: Dos and don’ts of readable code – how to make readable code
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可读性代码的注意事项——如何编写可读的代码
- en: Looking at the opinions of coders, the following are factors that make code
    difficult or a joy to read.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 根据程序员的意见，以下是使代码难以或容易阅读的因素。
- en: Do not do these things
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要做这些事情
- en: Inconsistencies, such as multiple different tab/indentation styles in one file
    or group of files or checking for a null and later checking for a non-null pointer,
    can confuse the reader who is trying to understand the code and ensure it’s working
    properly. Keep naming conventions consistent too.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些不一致的地方，如在一个文件或一组文件中使用多种不同的制表符/缩进样式，或者先检查空指针后又检查非空指针，会让试图理解代码并确保其正常工作的读者感到困惑。命名规范也要保持一致。
- en: Use variable and function names that aren’t descriptive of what they are for,
    such as using celebrity names or movie titles even if the script has nothing to
    do with films!
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不具描述性的变量和函数名，比如使用名人名字或电影标题，即使脚本与电影毫无关系！
- en: Using very similar function names can make bugs extremely tough to track down,
    such as **functionl()** and **functionL()** . Make it easy enough for future coders
    (including yourself) to differentiate functions.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非常相似的函数名会让定位bug变得极其困难，例如**functionl()**和**functionL()**。使未来的程序员（包括你自己）能够轻松区分函数。
- en: '**switch** statement excess: when editing someone else’s code, don’t simply
    add a **switch** statement if your case is covered because that could lead to
    fall-through cases being dispersed randomly amongst the standard cases and make
    it a headache to read and understand [ *O’Reilly_Algo_Flow,* *Quora_Chen, StackOverflow_switch*
    ].'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**switch**语句的过度使用：当编辑他人的代码时，如果你的情况已经涵盖，不要仅仅添加一个**switch**语句，因为那可能导致穿透情况随机分布在标准情况之间，使代码难以阅读和理解
    [ *O’Reilly_Algo_Flow,* *Quora_Chen, StackOverflow_switch* ]。'
- en: 'Use too many nested statements/layers of **if** statements: If an **if** statement
    starts in the middle of the screen, there is probably too much nesting.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过多嵌套语句/层级的**if**语句：如果一个**if**语句出现在屏幕的中间，可能说明嵌套层次太多。
- en: Do these things
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 做这些事情
- en: 'Code should contain different functions and functions should be simple:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码应该包含不同的函数，并且函数应该简洁：
- en: 'Function names should reflect what they do, and functions should be very simple:
    one task for one function, not multiple tasks in one function. Having such simple
    functions makes them easy to understand.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名应反映它们的功能，且函数应该非常简洁：每个函数只负责一个任务，而不是多个任务。拥有这样的简单函数能使它们更易理解。
- en: An alternative to overusing **if** statements is to use **switch** statements.
    **switch** statements are usually much faster than **if/else** statements too,
    especially when the number of conditions is large [ *O’Reilly_Algo_Flow,* *Quora_Chen,
    StackOverflow_switch* ].
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度使用**if**语句的替代方案是使用**switch**语句。**switch**语句通常比**if/else**语句要快，特别是当条件较多时 [
    *O’Reilly_Algo_Flow,* *Quora_Chen, StackOverflow_switch* ]。
- en: Some strategies to effectively use LLMs for code generation
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些有效使用大语言模型（LLMs）进行代码生成的策略
- en: 'Provide clear and specific prompts:'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Be precise* : Clearly articulate the desired functionality or task.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Give context* : Provide relevant information about the project or code base.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specify language* : Indicate the programming language you want the code in
    and its version, such as Python 3.10.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Iterate and refine:'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Evaluate output* : Carefully review the generated code for correctness and
    readability.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Provide feedback* : If the code is incorrect or needs improvement, provide
    specific feedback to the LLM – for example, “This code works but please make it
    easier to read, especially in the **Xzy** function.”'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Iterate* : Continue refining the prompt and iterating until you get the desired
    outcome.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Leverage LLM capabilities:'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Code completion* : Use LLMs to suggest code snippets or complete unfinished
    lines.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Function generation* : Ask LLMs to generate entire functions based on a given
    description.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code explanation* : Have LLMs explain existing code to better understand its
    functionality.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider contextual information:'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Project structure* : Provide information about the project’s structure, dependencies,
    and conventions.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code style* : Specify preferred coding styles or guidelines.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Best practices* : Instruct the LLM to adhere to best practices and avoid common
    pitfalls.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Combine human expertise with LLM capabilities:'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Human oversight* : Always have a human developer review and validate the generated
    code.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain knowledge* : Leverage human expertise to ensure the code aligns with
    specific domain requirements.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example prompt:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the LLM response:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Python:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use code with caution.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: While this code is correct, a human developer might suggest improvements, such
    as adding type hints or using a more efficient iterative approach for larger values
    of n .
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Remember
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: LLMs are a valuable tool for code generation, but they should be used along
    with human expertise to ensure the highest quality and maintainability of the
    code. By following these guidelines and iteratively refining your prompts, you
    can effectively leverage LLMs to enhance your coding productivity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Learning to read code does take practice, so keep practicing, and you’ll find
    it easier and more productive with time and work. Collaboration is one of the
    most powerful tools we have to make amazing things!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has been about bad and best practices when writing or generating
    code with LLMs: don’t use too many **if** statements, don’t make the code overly
    complex or with no comments, and don’t just add things randomly; do go back and
    forth with the LLM, provide the desired language version and context, such as
    the project structure, evaluate the code yourself, write simple functions, use
    descriptive names, document the code nicely, follow coding standards and conventions,
    handle errors, and so on. We looked at some code that’s hard to understand and
    some that is easier to read and understand, and where to get the code from the
    Packt GitHub repo. The next section is on how to summarize code you don’t understand.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing code for understanding
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is about how to summarize code you’re given or find that is opaque
    to you, the functioning of which you can’t quite figure out. Alternatively, maybe
    you just don’t want to spend the time wracking your brain to figure it out when
    you can automate that process and save energy and time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I asked Gemini, from Alphabet, to give me some code I don’t understand:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the code from Gemini (+ Claude 3):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Important note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: I got Claude 3 Sonnet to debug this code as it wouldn’t run – this is the final
    version (Gemini + Claude), but the explanation was done before the debugging.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: In the code files, this is called **crypto_price_and_indicators.py** , which
    is what Claude called it, but that was extremely close to what I’d called it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: I don’t really want to run code that I don’t understand at all – it could be
    dangerous, theoretically, though I mostly trust Alphabet. So, let’s see what ChatGPT
    can tell us about this.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the prompt to pass to ChatGPT:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the response from ChatGPT:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ChatGPT broke down the functions for us and gave us a general overview, including
    what the main function does and even why those code libraries were imported. ChatGPT
    even explained what RSI is. This makes the reader feel rather confident about
    what the script does and what every element does. That looks pretty good to me.
    If you’re unsure that this was done well, you could copy the code and explanation
    into Claude or back into Gemini or another chatbot to check whether the explanation
    was correct in all parts.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Looking over the code myself, I think it is an accurate explanation from ChatGPT.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The code worked and produced this plot of Bitcoin (BTC) prices in US Dollars
    Tether (USDT – a cryptocurrency tethered to the USD) and SMA indicator. See *Figure
    4* *.1* .
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Bitcoin historical price (wiggly blue line) versus USDT and SMA
    indicator in smooth green. The BTC price is on the left vertical axis [30000 to
    70000]. The SMA is on the right vertical axis [-0.04 to 0.04].](img/B21009_04_1.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Bitcoin historical price (wiggly blue line) versus USDT and SMA
    indicator in smooth green. The BTC price is on the left vertical axis [30000 to
    70000]. The SMA is on the right vertical axis [-0.04 to 0.04].'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can have code explained to you, there’s probably only 1 more step
    up in complexity and explanation. Especially if you want to publish your code,
    you might well want to fully document it so other coders can really work well
    with it by reading the manual.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The next section is for when you need to document your code so others can know
    what it’s for, how to troubleshoot it, and the best ways to use your code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Generating documentation
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s see the difference between explaining the preceding code and the full
    documentation of the code here. Let’s get a direct comparison by using the preceding
    code for the documentation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: I asked Claude (because I believe it’s currently the best-performing LLM chatbot
    for code) to give me full documentation for the preceding code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for crypto_price_and_indicators.py
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Claude 3 Sonnet responded with this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That documentation was very structured and went into the library requirements;
    it detailed every function: the parameters, what is returned by each function,
    and of course, the overall summary of what it does (at the beginning). It even
    gave a note on how to improve the functionality.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Seriously, to say that this LLM technology is “revolutionary” would in no way
    be hyperbole! This technology makes coding and documenting amazingly easy and
    fast!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: This is so much easier than writing everything by hand! We are so lucky! Yes,
    the examples given in this book are short but there is so much heavy lifting done
    by LLMs, and it will improve too.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: As mind-blowing as this technology is, this is early 2024 technology and much
    more powerful, adaptable, and intelligent technology is coming at an accelerating
    rate. So, this will be old very soon.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '*Stay up to date! Keep looking for new* *coding tools.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for [*Chapter 4*](B21009_04.xhtml#_idTextAnchor100) – summary inbound.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how to use LLMs to produce more readable code,
    summarize and explain existing code, and generate documentation for existing code.
    Frankly, it was mind-blowing! Coding is so easy with LLMs!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B21009_05.xhtml#_idTextAnchor115) , we will be addressing biases
    and ethical concerns in LLM-generated code. Gemini caused some problems in February
    2024, which were not popular with the public. This is always a learning process,
    and hopefully, humans and AI will get better at generating world-changing AI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Bibliography
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*GameDev_Dieterich* : “Most Programmers Can’t Read Code,” Robert Dieterich,
    [https://www.gamedeveloper.com/programming/most-programmers-can-t-read-code#close-modal](https://www.gamedeveloper.com/programming/most-programmers-can-t-read-code#close-modal)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ioijilai* : “Neural/Learned Image Compression: An Overview,” Ioijilai, [https://medium.com/@loijilai_43024/learned-image-compression-an-overview-625f3ab709f2](mailto:https://medium.com/@loijilai_43024/learned-image-compression-an-overview-625f3ab709f2)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*O’Reilly_Algo_Flow* : “ChapterÂ 4.Â Algorithms and Flow Control,” Nicholas
    C. Zakas, [https://www.oreilly.com/library/view/high-performance-javascript/9781449382308/ch04.html#:~:text=As%20it%20turns%20out%2C%20the,than%20it%20is%20for%20switch%20](https://www.oreilly.com/library/view/high-performance-javascript/9781449382308/ch04.html#:~:text=As%20it%20turns%20out%2C%20the,than%20it%20is%20for%20switch%20)
    .'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quora_Chen* : “What makes some code hard to read and some code easy to read?”,
    Howard Chen, [https://www.quora.com/What-makes-some-code-hard-to-read-and-some-code-easy-to-read](https://www.quora.com/What-makes-some-code-hard-to-read-and-some-code-easy-to-read)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*StackOverflow_switch* : “When to use If-else if-else over switch statements
    and vice versa [duplicate]: concerning Readability:”, Sonu Oommen, [https://stackoverflow.com/questions/427760/when-to-use-if-else-if-else-over-switch-statements-and-vice-versa](https://stackoverflow.com/questions/427760/when-to-use-if-else-if-else-over-switch-statements-and-vice-versa)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Taylor_2022* : Phillip Taylor, Nathan Griffiths, Vince Hall, Zhou Xu, Alex
    Mouzakitis, “Feature selection for supervised learning and compression,“ [https://www.tandfonline.com/doi/full/10.1080/08839514.2022.2034293](https://www.tandfonline.com/doi/full/10.1080/08839514.2022.2034293)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wiki_Cosine* : “Discrete cosine transform,” Wikipedia, [https://en.wikipedia.org/wiki/Discrete_cosine_transform](https://en.wikipedia.org/wiki/Discrete_cosine_transform)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WikiDataComp* : “Data compression ratio,” [https://en.wikipedia.org/wiki/Data_compression_ratio#:~:text=Definition,-Data%20compression%20ratio&text=Thus%2C%20a%20representation%20that%20compresses,implicit%20ratio%2C%205%2F1](https://en.wikipedia.org/wiki/Data_compression_ratio#:~:text=Definition,-Data%20compression%20ratio&text=Thus%2C%20a%20representation%20that%20compresses,implicit%20ratio%2C%205%2F1)
    .'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wiki_LZMA2* : “Lempel–Ziv–Markov chain algorithm,” Wikipedia, [https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wiki_Wavelets* : “Wavelet transform,” [https://en.wikipedia.org/wiki/Wavelet_transform#Wavelet_compression](https://en.wikipedia.org/wiki/Wavelet_transform#Wavelet_compression)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
