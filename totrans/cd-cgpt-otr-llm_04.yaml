- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Demystifying Generated Code for Readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delves into making LLM-generated code less ambiguous, and more
    accessible and comprehensible. We’ll explore techniques to enhance the explainability
    of code from LLMs, ensuring the logic and decision-making behind LLM-generated
    code are clear. By aiding a better understanding of code from LLMs, the chapter
    aims to promote transparency and trust in software development.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has bad and good code and prompt examples.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you gain insights into strategies for improving the readability
    of code from LLMs, nurturing a collaborative and informed approach to leveraging
    these powerful language models in coding practices.
  prefs: []
  type: TYPE_NORMAL
- en: From this chapter, you should learn how to use LLMs/chatbots to generate more
    readable code and summarize lengthy code blocks for understanding by humans using
    LLMs to create documentation and comments to aid readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating more readable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summarizing code for understanding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to an LLM/chatbot such as GPT-4, Gemini, or Claude 3 – each requires
    a login. For GPT-4, you’ll need an OpenAI account, and for Gemini, you’ll need
    a Google account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python IDE such as Spyder, IDLE, PyCharm, Eclipse, or Visual Studio. An online
    interpreter will not be good enough here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An HTML interpreter, such as [https://htmledit.squarefree.com/](https://htmledit.squarefree.com/)
    , [https://onecompiler.com/html](https://onecompiler.com/html) , or [https://www.w3schools.com/tryit/](https://www.w3schools.com/tryit/)
    , or a website editor: Wix, GoDaddy, One.com, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get the code in this book here: [https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s find out how to use Claude, Gemini, and ChatGPT to start off well
    and write code that is very readable.
  prefs: []
  type: TYPE_NORMAL
- en: Generating more readable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to generate code that others can easily
    read and get moving without them having to ponder its inner workings for hours.
  prefs: []
  type: TYPE_NORMAL
- en: If we are writing code, we want it to be used and that means it should be understood
    by other people, especially if we want someone to expand upon it. They’re much
    more likely to bother if we make our code easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: In the subsection *Code to compress data, written in Python 3.10* , we’ll ask
    an LLM for some code to compress data, but first, here’s an intro to what data
    compression is, so we know a bit more about what we’re doing. Data compression
    is important for using devices and the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to data compression methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s some background on what data compression is so that the following section
    is easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Lossless data compression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lossless data compression means the signal and the noise are compressed, nothing
    is lost, and everything can be re-created [ *Wiki_LZMA2* ].
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of lossless compression would be a dataset like this: [1,1,1,1,1,1,1….1,1,1,1,1,1,0,0,0,0,0,0…].'
  prefs: []
  type: TYPE_NORMAL
- en: This dataset could have any number of ones and any number of zeros, but a value
    can be represented by just the count of each and the name of each. If there were
    213 ones and 789 zeros, the lossless compression method **Run-Length Encoding**
    ( **RLE** ) would call it [(213, 1), (789,0)]. The data is now just 4 numbers,
    not 213+789 = 1,002 numbers, which is a compression ratio of 1002/4 = 250.5 [
    *WikiDataComp* ]. This has managed a good compression ratio without losing anything.
    This could be real data, for example, the answer to the question, “Is the windscreen
    wiper on?”.
  prefs: []
  type: TYPE_NORMAL
- en: Use lossless compression when you have a signal that tends to be constant for
    a long while. If you use it for very precise or always varying data, it’ll, instead,
    take up more space on your drive!
  prefs: []
  type: TYPE_NORMAL
- en: LZMA is another type of lossless compression method, which we shall use in a
    moment.
  prefs: []
  type: TYPE_NORMAL
- en: Lossy compression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A second type of compression is called lossy compression, where the algorithm
    or method tries to keep the signal and eliminate some level of noise. For lossy
    compression, there can be different levels of compression, offering a trade-off
    of fidelity and file size: more compression means less fidelity – more of the
    signal and noise are thrown out or zeroed.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of lossy compression include **Discrete Fourier Transforms** ( **DFTs**
    ), **Discrete Wavelet Transforms** ( **DWTs** ), or, best yet, **Discrete Cosine
    Transforms** ( **DCTs** ) [ *Wiki_Wavelets* ].
  prefs: []
  type: TYPE_NORMAL
- en: DCTs are used in a lot of standard compression methods for images ( **JPEG**
    ), video ( **MPEG** ), audio (Dolby Digital, MP3, AAC), digital television (HDTV,
    SDTV), and digital radio (AAC+, DAB) [Wiki_Cosine].
  prefs: []
  type: TYPE_NORMAL
- en: 'DCTs transform data from changing over time to being made up of lots of cosine
    waves of differing frequencies. It sounds ridiculously simple, but you can represent
    most things this way. I did simplify it. You generally keep the low-frequency
    waves and zero out the high-frequency waves, which are assumed to be noise. Then
    the signal is changed back to the original time-based form: varying over time.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want more fidelity – a better signal – you’ll zero out fewer of the high-frequency
    waves but will have to suffer a file size that’s not reduced much. If you really
    need a small file size, you’ll zero out more waves but that’ll leave you with
    a worse signal, image, or sound. Another way to look at the compression ratio
    is the bit rate, measured in bits/second. A higher bit rate can give a higher
    quality stream of data (e.g., video or sound) and, if it’s stored in a file, this
    means larger file sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, instead of zeroing the values, you can quantize them. Here, rather
    than having highly precise values, you could turn them into less precise values
    – for example, 3.48724 could fit into the [3.4 to 3.5] bin or, even less precise,
    the [3 to 4] bin. The values become a histogram – discrete and not so continuous.
    This saves space.
  prefs: []
  type: TYPE_NORMAL
- en: To get the ideal compressed data, there needs to be a balance between good compression
    and a good quality of signal, image, or video.
  prefs: []
  type: TYPE_NORMAL
- en: Learned compression or neural compression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A third type of compression is learned compression, where an ML method tries
    to learn what the signal is and keep that, at the expense of the noise.
  prefs: []
  type: TYPE_NORMAL
- en: The first two kinds of compression, lossless and lossy, are rule based, but
    in learned compression, neural networks are used to learn the patterns in the
    data and extract specific statistical properties. These learned methods are more
    adaptive [Gemini]. When I compressed tables or files of data with lossless and
    lossy methods, I had to try different methods and select the best method for each
    type of data [ *Taylor_2022* ]. This is an excellent method but is less adaptive
    than learned compression.
  prefs: []
  type: TYPE_NORMAL
- en: Learned compression models are more adaptable and the model can continuously
    learn, thus improving with new data [ *Gemini* ].
  prefs: []
  type: TYPE_NORMAL
- en: A method of learned compression is the **autoencoder** ( **AE** ). It is a palindromic
    or mirror-shaped neural network that takes in data, compresses it in a tiny space
    – a **latent space** , then reproduces the input data. The output layer looks
    like and is the same size as the input layer. These are the biggest layers, with
    layers reducing in size toward the middle, similar to two triangles, or perhaps
    a bowtie. This is useful because the latent space is a really compressed version
    of the data – there’s no space for excess! The first side or triangle is the encoder
    and the second side is the decoder. The encoder first compresses the data, then
    the decoder reconstructs the input data.
  prefs: []
  type: TYPE_NORMAL
- en: In learned compression, the balance between good compression and good quality
    is the loss function [ *Ioijilai* ].
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of learned compression
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Adaptability** : Unlike more traditional compression methods, learned compression
    models can adapt to complex and diverse data types, such as scientific data, because
    of relationships between variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency** : Learned compression models can sometimes compress better than
    older methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned models can learn the statistical properties of language and underlying
    structures in audio data, so can compress data more efficiently.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convolutional Neural Networks** ( **CNNs** ) are especially adept at detecting
    patterns and redundancies in images and videos, so can compress more effectively
    than JPEG and MPEG. The effect is more pronounced in higher-resolution data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the higher possible complexity of ML models can enable the learning
    of more intricate structures, leading to better compression.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generating data** : Decoders can create more data examples like the input
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of learned compression
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Complexity** : It can be more effective, but it is also more difficult to
    understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Computational costs** : These ML models can be very expensive to train and
    run. This is a bigger disadvantage for applications that require real-time processing,
    such as autonomous vehicles. You might well have to deploy a simplified and optimized
    trained model to the edge or use specially designed hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lossy** : Learned compression can be lossy. This means the trade-off between
    quality and compression needs to be struck.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'My background includes creating data compression software. Working with others
    at the University of Warwick, I created data compression software methodologies
    for Jaguar Land Rover and Onsemi, an American semiconductor manufacturer. If you
    want to know more, I’ve got a paper or two on compression, as well as other ML
    research here: [https://scholar.google.com/citations?user=9lCeU94AAAAJ&hl](https://scholar.google.com/citations?user=9lCeU94AAAAJ&hl)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: After compression, you can store or transmit data. But to get the data back,
    you’ll need to decompress it, usually.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s get some code to do compression ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Code to compress data, written in Python 3.10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are at least three types of data compression: lossless compression, lossy
    compression, and learned compression.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try the following code (see “Claude 3 provides the following output”);
    this is to compress data and make it smaller on file with a commonly used compression
    algorithm called the **Lempel-Ziv-Markov chain algorithm** or **LZMA2** . For
    this code, we will use lossless data compression, courtesy of LZMA.
  prefs: []
  type: TYPE_NORMAL
- en: LZMA2 is more powerful than LZMA; it’s a container format for uncompressed and
    LZMA data, as well as the compression of data that’s partially incompressible
    [ *Wiki_LZMA2, Taylor_2022* ].
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, the code here should compress data with LZMA2.
  prefs: []
  type: TYPE_NORMAL
- en: The code is courtesy of the Claude 3 LLM.
  prefs: []
  type: TYPE_NORMAL
- en: Asking Claude 3 to write some bad code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with how to get code that works but is hard to read. This is to
    compare it with code that you might have already but could be more explainable.
    LLMs will hopefully never give you this kind of code unless you explicitly ask
    for poorly written code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Claude 3 provides the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find this code in the **LZMAcompress_bad.py** file in our GitHub repo
    found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Coding-with-ChatGPT-and-Other-LLMs/tree/main/Chapter4//LZMAcompress_bad.py](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-Other-LLMs/tree/main/Chapter4//LZMAcompress_bad.py)'
  prefs: []
  type: TYPE_NORMAL
- en: This code took a few rounds of debugging, but what you have here works for the
    little toy dataset given. Claude 3 was very helpful. It made one mistake not correcting
    a bug, but the whole process was very easy. You just need to mention the code
    again if the chatbot has already seen it or paste it into the chat field if it’s
    not been seen, then state the problem, giving the line the error message says
    the error is about. Then, the chatbot should give a better version of the code.
    Do this until the code works nicely for you, then test it.
  prefs: []
  type: TYPE_NORMAL
- en: There’s not much commenting. The variable and function names are really unclear.
    It sometimes does a great deal in one line, and in a **for** statement line at
    that! Conditional statements shouldn’t have calculations or string operations
    in them! It prints **G** at the end, whatever that is. Variables are sometimes
    single lowercase letters and sometimes single uppercase letters – no convention.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t really like that the ages are strings – couldn’t they be **ints** or
    at least **floats** ?
  prefs: []
  type: TYPE_NORMAL
- en: It’s using **try/except** , which is good, and it’s using different functions,
    which are not large, so the code is not necessarily poor from an operation point
    of view.
  prefs: []
  type: TYPE_NORMAL
- en: I’m not sure if **l()** will always return something.
  prefs: []
  type: TYPE_NORMAL
- en: This code is really unclear. I would have to look at it for a while to figure
    out what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: It uses **for** statements, which are unpopular because they’re slow in languages
    like Python compared with vectorized ways.
  prefs: []
  type: TYPE_NORMAL
- en: Well, that’s what I caught from a quick look.
  prefs: []
  type: TYPE_NORMAL
- en: Here is what Claude 3 says about its own example of bad code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The intentionally obfuscated and poorly written code that compresses tabular
    data using the LZMA2 algorithm in Python 3.10 exhibits several characteristics
    that make it hard to read and understand. Here are some of the main issues with
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Poor variable naming** : The code uses single-letter variable names such
    as **a, b, c, d, e, f, m, n, o, p, q, r, s, t, u, v, w, x, y,** and **z** , which
    provide no meaningful information about the purpose or content of the variables.
    This makes it extremely difficult to understand what each variable represents
    or what it’s being used for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of comments** : The code is completely devoid of comments or docstrings,
    which would normally provide explanations of the code’s purpose, functionality,
    and logic. Without any comments, it becomes a guessing game to understand what
    the code is trying to accomplish.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convoluted logic** : The logic for compressing and decompressing the tabular
    data is spread across multiple functions ( **j, l,** and **k** ) and is unnecessarily
    complex. The code uses nested list comprehensions, unnecessary type conversions,
    and obscure operations that make it challenging to follow the flow of execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Violation of coding conventions** : The code violates several Python coding
    conventions and best practices, such as using meaningful variable names, proper
    indentation and formatting, and separation of concerns. This makes it harder for
    developers familiar with Python conventions to understand the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of error handling** : The code does not include any error handling mechanisms
    or exception handling, which can lead to unexpected behavior and crashes in the
    case of errors or edge cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixing of functionality** : The code mixes functionality related to compression,
    decompression, and data manipulation, making it harder to follow and maintain.
    Ideally, these concerns should be separated into distinct functions or modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Obscure type annotations** : While the code uses type annotations, the annotations
    themselves are obscure and unhelpful due to the poor variable naming conventions
    – for example, the type annotation **Any** is used for all variables, which defeats
    the purpose of type annotations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unnecessary complexity** : The code introduces unnecessary complexity by
    using obscure techniques and terse expressions, sacrificing readability for brevity.
    This makes it harder for developers to understand and maintain the code, especially
    if they are unfamiliar with such techniques.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of modularity** : The code is not designed in a modular way, making
    it difficult to integrate or reuse in larger applications or libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited extensibility** : Due to the obfuscated nature of the code and the
    lack of proper documentation or comments, it becomes challenging to extend or
    modify the code without risking unintended consequences or introducing new bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the code exhibits numerous examples of poor coding practices and intentional
    obfuscation, making it extremely difficult to read, understand, and maintain.
    While this exercise is valuable for understanding the challenges of working with
    poorly written code, it serves as a reminder of the importance of writing clear,
    readable, and well-documented code in real-world software development scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: That was the end of the Claude 3 output.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we must get some code that both works well and is easy to read, following
    good practices. Again, I went with the best coder LLM at the time, Claude 3.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some well-written code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now ask Claude 3 for some good code like the preceding: data compression
    with Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Claude 3 gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code executes successfully. You can find this code in the **LZMAcompress_good.py**
    file in the GitHub repo here: [https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4//LZMAcompress_good.py](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4//LZMAcompress_good.py)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: What Claude 3 says about its own good code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This code is easy to read and understand for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clear function names** : The function names **compress_tabular_data** and
    **decompress_tabular_data** clearly describe the purpose of each function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type hints** : The code uses type hints to specify the expected types of
    function arguments and return values, making it easier to understand the input
    and output formats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docstrings** : Each function has a docstring that provides a brief description
    of the function’s purpose, its arguments, and its return value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meaningful variable names** : The variable names used in the code are descriptive
    and self-explanatory, making it easier to understand what each variable represents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of concerns** : The code separates the compression and decompression
    logic into two distinct functions, making it easier to maintain and extend'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proper indentation and formatting** : The code is properly indented and formatted,
    making it readable and visually appealing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling** : While not explicitly shown in this example, the code can
    be extended to include error-handling mechanisms to handle potential exceptions
    or errors during compression or decompression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modular design** : The code is designed in a modular way, allowing for easy
    integration into larger applications or libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use of standard library** : The code uses the standard **lzma** module from
    the Python standard library, which is well-documented and widely used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example usage** : The code includes an example usage in the **if __name__
    == ''__main__''** block, making it easy to understand how to use the functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, this code follows best practices for writing clean, readable, and maintainable
    Python code. It should be easy to understand for developers familiar with Python
    and the LZMA2 compression algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: That was the end of the Claude 3 output and our discussion of what is good about
    its more readable version of the LZMA compression code in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s get to specific points that make code easy or hard to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: What makes code hard or easy to read?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s look at some practices that might lead to poor readability, and then we’ll
    look at how to get the readability as good as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Why is reading code hard?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reading code is much harder than writing code for at least three reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: When writing code, you have to keep in mind the variables, algorithms, data,
    and structure of the feature you’re writing only. When reading code, you must
    keep in mind all the information about wider functionality and potential functionalities
    that you’ve guessed from your reading of the code so far.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thinking is easier than understanding someone else’s thinking – vastly easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not your code – your baby, so it’s probably not as good as something you
    could write, or at least that’s the thinking of many programmers. That’s the emotional
    aspect. Alternatively, you might be thinking that the code is written by someone
    more intelligent and experienced, so you’ll not be able to understand it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand someone else’s code, you need a working model of the code in your
    mind, as well as the aims of the project [ *GameDev_Dieterich* ].
  prefs: []
  type: TYPE_NORMAL
- en: Don’t be afraid to read other people’s code and get an understanding of it.
    You may well make good use of it and not have to re-write the code.
  prefs: []
  type: TYPE_NORMAL
- en: This reminds me of the time I had to read and use code from colleagues in Czechia.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to trying to understand the C code (when I would normally code in
    C#, R, or MATLAB) and learn some more physics, some of the variables were in Czech,
    which I don’t speak. So, I had to learn some Czech too. Fortunately, I enjoy learning
    languages and already know plenty about physics. Eventually, I understood the
    code and we worked together well, including visits to each other’s countries,
    UK and Czechia. We got some great products made.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you can communicate with the original coder, you can ask them
    questions about it. Be polite – it’s their baby, which they might have taken a
    lot of time and energy to create.
  prefs: []
  type: TYPE_NORMAL
- en: Dos and don’ts of readable code – how to make readable code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Looking at the opinions of coders, the following are factors that make code
    difficult or a joy to read.
  prefs: []
  type: TYPE_NORMAL
- en: Do not do these things
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inconsistencies, such as multiple different tab/indentation styles in one file
    or group of files or checking for a null and later checking for a non-null pointer,
    can confuse the reader who is trying to understand the code and ensure it’s working
    properly. Keep naming conventions consistent too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use variable and function names that aren’t descriptive of what they are for,
    such as using celebrity names or movie titles even if the script has nothing to
    do with films!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using very similar function names can make bugs extremely tough to track down,
    such as **functionl()** and **functionL()** . Make it easy enough for future coders
    (including yourself) to differentiate functions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**switch** statement excess: when editing someone else’s code, don’t simply
    add a **switch** statement if your case is covered because that could lead to
    fall-through cases being dispersed randomly amongst the standard cases and make
    it a headache to read and understand [ *O’Reilly_Algo_Flow,* *Quora_Chen, StackOverflow_switch*
    ].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use too many nested statements/layers of **if** statements: If an **if** statement
    starts in the middle of the screen, there is probably too much nesting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do these things
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Code should contain different functions and functions should be simple:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function names should reflect what they do, and functions should be very simple:
    one task for one function, not multiple tasks in one function. Having such simple
    functions makes them easy to understand.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative to overusing **if** statements is to use **switch** statements.
    **switch** statements are usually much faster than **if/else** statements too,
    especially when the number of conditions is large [ *O’Reilly_Algo_Flow,* *Quora_Chen,
    StackOverflow_switch* ].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some strategies to effectively use LLMs for code generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Provide clear and specific prompts:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Be precise* : Clearly articulate the desired functionality or task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Give context* : Provide relevant information about the project or code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specify language* : Indicate the programming language you want the code in
    and its version, such as Python 3.10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Iterate and refine:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Evaluate output* : Carefully review the generated code for correctness and
    readability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Provide feedback* : If the code is incorrect or needs improvement, provide
    specific feedback to the LLM – for example, “This code works but please make it
    easier to read, especially in the **Xzy** function.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Iterate* : Continue refining the prompt and iterating until you get the desired
    outcome.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Leverage LLM capabilities:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Code completion* : Use LLMs to suggest code snippets or complete unfinished
    lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Function generation* : Ask LLMs to generate entire functions based on a given
    description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code explanation* : Have LLMs explain existing code to better understand its
    functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider contextual information:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Project structure* : Provide information about the project’s structure, dependencies,
    and conventions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code style* : Specify preferred coding styles or guidelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Best practices* : Instruct the LLM to adhere to best practices and avoid common
    pitfalls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Combine human expertise with LLM capabilities:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Human oversight* : Always have a human developer review and validate the generated
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain knowledge* : Leverage human expertise to ensure the code aligns with
    specific domain requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the LLM response:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Use code with caution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While this code is correct, a human developer might suggest improvements, such
    as adding type hints or using a more efficient iterative approach for larger values
    of n .
  prefs: []
  type: TYPE_NORMAL
- en: Remember
  prefs: []
  type: TYPE_NORMAL
- en: LLMs are a valuable tool for code generation, but they should be used along
    with human expertise to ensure the highest quality and maintainability of the
    code. By following these guidelines and iteratively refining your prompts, you
    can effectively leverage LLMs to enhance your coding productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to read code does take practice, so keep practicing, and you’ll find
    it easier and more productive with time and work. Collaboration is one of the
    most powerful tools we have to make amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has been about bad and best practices when writing or generating
    code with LLMs: don’t use too many **if** statements, don’t make the code overly
    complex or with no comments, and don’t just add things randomly; do go back and
    forth with the LLM, provide the desired language version and context, such as
    the project structure, evaluate the code yourself, write simple functions, use
    descriptive names, document the code nicely, follow coding standards and conventions,
    handle errors, and so on. We looked at some code that’s hard to understand and
    some that is easier to read and understand, and where to get the code from the
    Packt GitHub repo. The next section is on how to summarize code you don’t understand.'
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing code for understanding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is about how to summarize code you’re given or find that is opaque
    to you, the functioning of which you can’t quite figure out. Alternatively, maybe
    you just don’t want to spend the time wracking your brain to figure it out when
    you can automate that process and save energy and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I asked Gemini, from Alphabet, to give me some code I don’t understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code from Gemini (+ Claude 3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: I got Claude 3 Sonnet to debug this code as it wouldn’t run – this is the final
    version (Gemini + Claude), but the explanation was done before the debugging.
  prefs: []
  type: TYPE_NORMAL
- en: In the code files, this is called **crypto_price_and_indicators.py** , which
    is what Claude called it, but that was extremely close to what I’d called it.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t really want to run code that I don’t understand at all – it could be
    dangerous, theoretically, though I mostly trust Alphabet. So, let’s see what ChatGPT
    can tell us about this.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the prompt to pass to ChatGPT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the response from ChatGPT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: ChatGPT broke down the functions for us and gave us a general overview, including
    what the main function does and even why those code libraries were imported. ChatGPT
    even explained what RSI is. This makes the reader feel rather confident about
    what the script does and what every element does. That looks pretty good to me.
    If you’re unsure that this was done well, you could copy the code and explanation
    into Claude or back into Gemini or another chatbot to check whether the explanation
    was correct in all parts.
  prefs: []
  type: TYPE_NORMAL
- en: Looking over the code myself, I think it is an accurate explanation from ChatGPT.
  prefs: []
  type: TYPE_NORMAL
- en: The code worked and produced this plot of Bitcoin (BTC) prices in US Dollars
    Tether (USDT – a cryptocurrency tethered to the USD) and SMA indicator. See *Figure
    4* *.1* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Bitcoin historical price (wiggly blue line) versus USDT and SMA
    indicator in smooth green. The BTC price is on the left vertical axis [30000 to
    70000]. The SMA is on the right vertical axis [-0.04 to 0.04].](img/B21009_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Bitcoin historical price (wiggly blue line) versus USDT and SMA
    indicator in smooth green. The BTC price is on the left vertical axis [30000 to
    70000]. The SMA is on the right vertical axis [-0.04 to 0.04].'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can have code explained to you, there’s probably only 1 more step
    up in complexity and explanation. Especially if you want to publish your code,
    you might well want to fully document it so other coders can really work well
    with it by reading the manual.
  prefs: []
  type: TYPE_NORMAL
- en: The next section is for when you need to document your code so others can know
    what it’s for, how to troubleshoot it, and the best ways to use your code.
  prefs: []
  type: TYPE_NORMAL
- en: Generating documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s see the difference between explaining the preceding code and the full
    documentation of the code here. Let’s get a direct comparison by using the preceding
    code for the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: I asked Claude (because I believe it’s currently the best-performing LLM chatbot
    for code) to give me full documentation for the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for crypto_price_and_indicators.py
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Claude 3 Sonnet responded with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That documentation was very structured and went into the library requirements;
    it detailed every function: the parameters, what is returned by each function,
    and of course, the overall summary of what it does (at the beginning). It even
    gave a note on how to improve the functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: Seriously, to say that this LLM technology is “revolutionary” would in no way
    be hyperbole! This technology makes coding and documenting amazingly easy and
    fast!
  prefs: []
  type: TYPE_NORMAL
- en: This is so much easier than writing everything by hand! We are so lucky! Yes,
    the examples given in this book are short but there is so much heavy lifting done
    by LLMs, and it will improve too.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As mind-blowing as this technology is, this is early 2024 technology and much
    more powerful, adaptable, and intelligent technology is coming at an accelerating
    rate. So, this will be old very soon.
  prefs: []
  type: TYPE_NORMAL
- en: '*Stay up to date! Keep looking for new* *coding tools.*'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for [*Chapter 4*](B21009_04.xhtml#_idTextAnchor100) – summary inbound.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how to use LLMs to produce more readable code,
    summarize and explain existing code, and generate documentation for existing code.
    Frankly, it was mind-blowing! Coding is so easy with LLMs!
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B21009_05.xhtml#_idTextAnchor115) , we will be addressing biases
    and ethical concerns in LLM-generated code. Gemini caused some problems in February
    2024, which were not popular with the public. This is always a learning process,
    and hopefully, humans and AI will get better at generating world-changing AI.
  prefs: []
  type: TYPE_NORMAL
- en: Bibliography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*GameDev_Dieterich* : “Most Programmers Can’t Read Code,” Robert Dieterich,
    [https://www.gamedeveloper.com/programming/most-programmers-can-t-read-code#close-modal](https://www.gamedeveloper.com/programming/most-programmers-can-t-read-code#close-modal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ioijilai* : “Neural/Learned Image Compression: An Overview,” Ioijilai, [https://medium.com/@loijilai_43024/learned-image-compression-an-overview-625f3ab709f2](mailto:https://medium.com/@loijilai_43024/learned-image-compression-an-overview-625f3ab709f2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*O’Reilly_Algo_Flow* : “ChapterÂ 4.Â Algorithms and Flow Control,” Nicholas
    C. Zakas, [https://www.oreilly.com/library/view/high-performance-javascript/9781449382308/ch04.html#:~:text=As%20it%20turns%20out%2C%20the,than%20it%20is%20for%20switch%20](https://www.oreilly.com/library/view/high-performance-javascript/9781449382308/ch04.html#:~:text=As%20it%20turns%20out%2C%20the,than%20it%20is%20for%20switch%20)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quora_Chen* : “What makes some code hard to read and some code easy to read?”,
    Howard Chen, [https://www.quora.com/What-makes-some-code-hard-to-read-and-some-code-easy-to-read](https://www.quora.com/What-makes-some-code-hard-to-read-and-some-code-easy-to-read)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*StackOverflow_switch* : “When to use If-else if-else over switch statements
    and vice versa [duplicate]: concerning Readability:”, Sonu Oommen, [https://stackoverflow.com/questions/427760/when-to-use-if-else-if-else-over-switch-statements-and-vice-versa](https://stackoverflow.com/questions/427760/when-to-use-if-else-if-else-over-switch-statements-and-vice-versa)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Taylor_2022* : Phillip Taylor, Nathan Griffiths, Vince Hall, Zhou Xu, Alex
    Mouzakitis, “Feature selection for supervised learning and compression,“ [https://www.tandfonline.com/doi/full/10.1080/08839514.2022.2034293](https://www.tandfonline.com/doi/full/10.1080/08839514.2022.2034293)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wiki_Cosine* : “Discrete cosine transform,” Wikipedia, [https://en.wikipedia.org/wiki/Discrete_cosine_transform](https://en.wikipedia.org/wiki/Discrete_cosine_transform)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WikiDataComp* : “Data compression ratio,” [https://en.wikipedia.org/wiki/Data_compression_ratio#:~:text=Definition,-Data%20compression%20ratio&text=Thus%2C%20a%20representation%20that%20compresses,implicit%20ratio%2C%205%2F1](https://en.wikipedia.org/wiki/Data_compression_ratio#:~:text=Definition,-Data%20compression%20ratio&text=Thus%2C%20a%20representation%20that%20compresses,implicit%20ratio%2C%205%2F1)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wiki_LZMA2* : “Lempel–Ziv–Markov chain algorithm,” Wikipedia, [https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wiki_Wavelets* : “Wavelet transform,” [https://en.wikipedia.org/wiki/Wavelet_transform#Wavelet_compression](https://en.wikipedia.org/wiki/Wavelet_transform#Wavelet_compression)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
