- en: Maths for Neural Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Neural network users need to have a fair understanding of neural network concepts,
    algorithms, and the underlying mathematics. Good mathematical intuition and understanding
    of many techniques is necessary for a solid grasp of the inner functioning of
    the algorithms and for getting good results. The amount of maths required and
    the level of maths needed to understand these techniques is multidimensional and
    also depends on interest. In this chapter, you will learn neural networks by understanding
    the maths used to solve complex computational problems. This chapter covers the
    basics of linear algebra, calculus, and optimization for neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of this chapter is to set up the fundamentals of mathematics
    for the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following topics will be covered in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding linear algebra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Calculus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding linear algebra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linear algebra is a key branch of mathematics. An understanding of linear algebra
    is crucial for **deep learning**, that is, neural networks. Throughout this chapter,
    we will go through the key and fundamental linear algebra prerequisites. Linear
    Algebra deals with linear systems of equations. Instead of working with scalars,
    we start working with matrices and vectors. Using linear algebra, we can describe
    complicated operations in deep learning.
  prefs: []
  type: TYPE_NORMAL
- en: Environment setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into the field of mathematics and its properties, it's essential
    for us to set up the development environment as it will provide us settings to
    execute the concepts we learn, meaning installing the compiler, dependencies,
    and **IDE** (**Integrated Development Environment**) to run our code base.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Python environment in Pycharm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is best to use an IDE like Pycharm to edit Python code as it provides development
    tools and built-in coding assistance. Code inspection makes coding and debugging
    faster and simpler, ensuring that you focus on the end goal of learning maths
    for neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps show you how to set up local Python environment in Pycharm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to Preferences and verify that the TensorFlow library is installed. If not,
    follow the instructions at [https://www.tensorflow.org/install/](https://www.tensorflow.org/install/)
    to install TensorFlow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/80d45f03-9991-4b89-a3f8-78695a3e62f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep the default options of TensorFlow and click on OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, right-click on the source file and click on Run ''matrices'':'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/adef8686-9dd0-4c7c-93a1-38bdbb9f497e.png)'
  prefs: []
  type: TYPE_IMG
- en: Linear algebra structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following section, we will describe the fundamental structures of linear
    algebra.
  prefs: []
  type: TYPE_NORMAL
- en: Scalars, vectors, and matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scalars, vectors, and matrices are the fundamental objects of mathematics.
    Basic definitions are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalar is represented by a single number or numerical value called **magnitude**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector is an array of numbers assembled in order. A unique index identifies
    each number. Vector represents a point in space, with each element giving the
    coordinate along a different axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrices is a two-dimensional array of numbers where each number is identified
    using two indices (*i*, *j*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array of numbers with a variable number of axes is known as a **tensor**.
    For example, for three axes, it is identified using three indices (*i*, *j*, *k*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image summaries a tensor, it describes a second-order tensor
    object. In a three-dimensional Cartesian coordinate system, tensor components
    will form the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/713cf813-f618-4301-bcf0-94bb9d530429.png)'
  prefs: []
  type: TYPE_IMG
- en: Image reference is taken from tensor wiki [https://en.wikipedia.org/wiki/Tensor](https://en.wikipedia.org/wiki/Tensor)
  prefs: []
  type: TYPE_NORMAL
- en: Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following topics will describe the various operations of linear algebra.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Norm` function is used to get the size of the vector; the norm of a vector
    *x* measures the distance from the origin to the point *x*. It is also known as
    the ![](img/c656e3fe-f16d-4703-b95d-18dd3dc02fca.jpg)norm, where *p=2* is known
    as the **Euclidean norm**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows you how to calculate the ![](img/c656e3fe-f16d-4703-b95d-18dd3dc02fca.jpg)norm
    of a given vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output of the listing is 8.77496.
  prefs: []
  type: TYPE_NORMAL
- en: Matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A matrix is a two-dimensional array of numbers where each element is identified
    by two indices instead of just one. If a real matrix *X* has a height of *m* and
    a width of *n*, then we say that *X ∈ Rm × n*. Here, *R* is a set of real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how different matrices are converted to tensor
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the listing is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Matrix multiplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Matrix multiplication of matrices *A* and *B* is a third matrix, *C*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*C = AB*'
  prefs: []
  type: TYPE_NORMAL
- en: The element-wise product of matrices is called a **Hadamard** product and is
    denoted as *A.B*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dot product of two vectors *x* and *y* of the same dimensionality is the
    matrix product *x* transposing *y*. Matrix product *C = AB* is like computing
    *C[i,j]* as the dot product between row *i* of matrix *A* and column *j* of matrix
    *B*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39075617-fcce-4cf3-aa3f-33fd65df9288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example shows the Hadamard product and dot product using tensor
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the listing is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Trace operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The trace operator *Tr(A)* of matrix *A* gives the sum of all of the diagonal
    entries of a matrix. The following example shows how to use a trace operator on
    tensor objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output of the listing is *12.0*.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix transpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transposition of the matrix is the mirror image of the matrix across the main
    diagonal. A symmetric matrix is any matrix that is equal to its own transpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ab26f97-c7f1-4046-9494-9aba9b6d4ac7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example shows how to use a transpose operator on tensor objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the listing is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Matrix diagonals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matrices that are diagonal in nature consist mostly of zeros and have non-zero
    entries only along the main diagonal. Not all diagonal matrices need to be square.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the diagonal part operation, we can get the diagonal of a given matrix,
    and to create a matrix with a given diagonal, we use the `diag` operation from
    `tensorflow`. The following example shows how to use diagonal operators on tensor
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Identity matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An identity matrix is a matrix *I* that does not change any vector, like *V*,
    when multiplied by *I*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to get the identity matrix for a given size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Inverse matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The matrix inverse of *I* is denoted as ![](img/9ce156ad-e34e-4287-bbbf-4fa1480b7702.jpg).
    Consider the following equation; to solve it using inverse and different values
    of *b*, there can be multiple solutions for *x*. Note the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4264ad0b-4dd1-4598-a383-b37799179877.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**![](img/80ef6668-7388-44e3-9008-cb946ffc07b4.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to calculate the inverse of a matrix using
    the `matrix_inverse` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Solving linear equations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TensorFlow can solve a series of linear equations using the `solve` operation.
    Let's first explain this without using the library and later use the `solve` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A linear equation is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ax + b = yy - ax = b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*y - ax = b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*y/b - a/b(x) = 1*'
  prefs: []
  type: TYPE_NORMAL
- en: Our job is to find the values for *a* and *b* in the preceding equation, given
    our observed points. First, create the matrix points. The first column represents
    *x* values, while the second column represents *y* values.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that *X* is the input matrix and *A* is the parameters that we need
    to learn; we set up a system like *AX=B*, therefore, ![](img/a545637a-63f7-46c5-b731-43b1fcae9fab.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example, with code, shows how to solve the linear equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*3x+2y = 15*'
  prefs: []
  type: TYPE_NORMAL
- en: '*4x−y = 10*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the listing is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The canonical equation for a circle is *x2+y2+dx+ey+f=0*; to solve this for
    the parameters *d*, *e*, and *f*, we use TensorFlow''s solve operation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the listing is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Singular value decomposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we decompose an integer into its prime factors, we can understand useful
    properties about the integer. Similarly, when we decompose a matrix, we can understand
    many functional properties that are not directly evident. There are two types
    of decomposition, namely eigenvalue decomposition and singular value decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: All real matrices have singular value decomposition, but the same is not true
    for Eigenvalue decomposition. For example, if a matrix is not square, the Eigen
    decomposition is not defined and we must use singular value decomposition instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**Singular Value Decomposition** (**SVD**) in mathematical form is the product
    of three matrices *U*, *S*, and *V*, where *U* is *m*r*, *S* is *r*r* and *V*
    is *r*n*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/301bd7b9-1332-435f-96c7-96a7d51f1373.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example shows SVD using a TensorFlow `svd` operation on textual
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the plot for the SVD of the preceding dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f312b60a-53ca-4019-b53b-800ec1019c19.png)'
  prefs: []
  type: TYPE_IMG
- en: Eigenvalue decomposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eigen decomposition is one of the most famous decomposition techniques in which
    we decompose a matrix into a set of eigenvectors and eigenvalues.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a square matrix, Eigenvector is a vector *v* such that multiplication by
    *A* alters only the scale of *v*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Av = λv*'
  prefs: []
  type: TYPE_NORMAL
- en: The scalar *λ* is known as the eigenvalue corresponding to this eigenvector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eigen decomposition of *A* is then given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fb009f4-4519-4f74-af40-922704ca0d3d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Eigen decomposition of a matrix describes many useful details about the matrix.
    For example, the matrix is singular if, and only if, any of the eigenvalues are
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: Principal Component Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Principal Component Analysis** (**PCA**) projects the given dataset onto
    a lower dimensional linear space so that the variance of the projected data is
    maximized. PCA requires the eigenvalues and eigenvectors of the covariance matrix,
    which is the product where *X* is the data matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SVD on the data matrix *X* is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6384841b-c4e6-4684-8e8d-bd4f8848d008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example shows PCA using SVD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the listing is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Calculus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Topics in the previous sections are covered as part of standard linear algebra;
    something that wasn't covered is basic calculus. Despite the fact that the calculus
    that we use is relatively simple, the mathematical form of it may look very complex.
    In this section, we present some basic forms of matrix calculus with a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Gradient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gradient for functions with respect to a real-valued matrix *A* is defined
    as the matrix of partial derivatives of *A* and is denoted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d459ff93-d4b1-45a4-98ec-09be902ff273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/57cf3a28-13d4-4e38-9564-c0625d794ef5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: TensorFlow does not do numerical differentiation; rather, it supports automatic
    differentiation. By specifying operations in a TensorFlow graph, it can automatically
    run the chain rule through the graph and, as it knows the derivatives of each
    operation we specify, it can combine them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows training a network using MNIST data, the MNIST database
    consists of handwritten digits. It has a training set of 60,000 examples and a
    test set of 10,000 samples. The digits are size-normalized.
  prefs: []
  type: TYPE_NORMAL
- en: Here backpropagation is performed without any API usage and derivatives are
    calculated manually. We get 913 correct out of 1,000 tests. This concept will
    be introduced in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We now define a two-layered network with a nonlinear `sigmoid` function; a
    squared loss function is applied and optimized using a backward propagation algorithm,
    as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's use automatic differentiation with TensorFlow. The following example
    demonstrates the use of `GradientDescentOptimizer`. We get 924 correct out of
    1,000 tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows linear regression using gradient descent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The plots are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/733b0660-6367-48b9-bf7d-b597645e9649.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following image shows the fitted line on testing data using the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6782be0-fb03-4c47-9af1-2e5769266908.png)'
  prefs: []
  type: TYPE_IMG
- en: Hessian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gradient is the first derivative for functions of vectors, whereas hessian
    is the second derivative. We will go through the notation now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98c65983-8474-4932-8848-2cb3d21ea642.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similar to the gradient, the hessian is defined only when *f(x)* is real-valued.
  prefs: []
  type: TYPE_NORMAL
- en: The algebraic function used is ![](img/21afe5dc-d4ba-4fbb-87c8-6d7819dfd8cb.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the hessian implementation using TensorFlow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Determinant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Determinant shows us information about the matrix that is helpful in linear
    equations and also helps in finding the inverse of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a given matrix *X*, the determinant is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04084fab-c318-4f21-960f-c326eee557b0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/ce5ff6f2-7d96-45d5-ab7a-c1e956c44634.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example shows how to get a determinant using TensorFlow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of deep learning, we mostly would like to optimize the value of a function
    that either minimizes or maximizes *f(x)* with respect to *x*. A few examples
    of optimization problems are least-squares, logistic regression, and support vector
    machines. Many of these techniques will get examined in detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will study `AdamOptimizer` here; TensorFlow `AdamOptimizer` uses Kingma and
    Ba's Adam algorithm to manage the learning rate. Adam has many advantages over
    the simple `GradientDescentOptimizer`. The first is that it uses moving averages
    of the parameters, which enables Adam to use a larger step size, and it will converge
    to this step size without any fine-tuning.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of Adam is that it requires more computation to be performed
    for each parameter in each training step. `GradientDescentOptimizer` can be used
    as well, but it would require more hyperparameter tuning before it would converge
    as quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to use `AdamOptimizer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tf.train.Optimizer` creates an optimizer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tf.train.Optimizer.minimize(loss, var_list)` adds the optimization operation
    to the computation graph'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, automatic differentiation computes gradients without user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the scatter plot for the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd9bc39b-f5b5-481c-8932-8765e2538d70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the plot of the learned model on the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5c47a2e-cde3-4932-a685-86788ec140f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've introduced the mathematical concepts that are key to
    the understanding of neural networks and reviewed some maths associated with tensors.
    We also demonstrated how to perform mathematical operations within TensorFlow.
    We will repeatedly be applying these concepts in the following chapters.
  prefs: []
  type: TYPE_NORMAL
