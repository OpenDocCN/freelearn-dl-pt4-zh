["```py\n  pip install ipython-sql\n```", "```py\npip install version_information\n```", "```py\npipreqs chapter-1/\n\n```", "```py\n     cat chapter-1/requirements.txt\n     matplotlib==2.0.2\n     numpy==1.13.1\n     pandas==0.20.3\n     requests==2.18.4\n     seaborn==0.8\n     beautifulsoup4==4.6.0\n     scikit_learn==0.19.0\n```", "```py\n    import matplotlib.pyplot as plt\n    %matplotlib inline\n    import seaborn as sns\n    # See here for more options: \n    https://matplotlib.org/users/customizing.html\n    %config InlineBackend.figure_format='retina'\n    sns.set() # Revert to matplotlib defaults\n    plt.rcParams['figure.figsize'] = (9, 6)\n    plt.rcParams['axes.labelpad'] = 10\n    sns.set_style(\"darkgrid\")\n```", "```py\n    Boston House Prices dataset\n    ===========================\n    Notes\n    ------\n    Data Set Characteristics:\n    :Number of Instances: 506\n    :Number of Attributes: 13 numeric/categorical predictive\n    :Median Value (attribute 14) is usually the target\n    :Attribute Information (in order):\n    - CRIM per capita crime rate by town\n    â€¦\n    - MEDV Median value of owner-occupied homes in $1000's\n    :Missing Attribute Values: None \n```", "```py\ndf = pd.DataFrame(data=boston['data'], columns=boston['feature_names'])\n```", "```py\n    df['MEDV'] = boston['target']\n\n```", "```py\n     y = df['MEDV'].copy()\n     del df['MEDV']\n     df = pd.concat((y, df), axis=1)\n```", "```py\n  for col in ['ZN', 'NOX', 'RAD', 'PTRATIO', 'B']:\n     del df[col]\n```", "```py\n    cols = ['RM', 'AGE', 'TAX', 'LSTAT', 'MEDV'] \n```", "```py\n   df[cols].corr()\n\n```", "```py\n     import matplotlib.pyplot as plt\n     import seaborn as sns\n     %matplotlib inline \n\n     ax = sns.heatmap(df[cols].corr(),\n     cmap=sns.cubehelix_palette(20, light=0.95, dark=0.15))\n     ax.xaxis.tick_top() # move labels to the top\n     plt.savefig('../figures/chapter-1-boston-housing-corr.png',\n     bbox_inches='tight', dpi=300)\n\n```", "```py\n     sns.pairplot(df[cols],\n     plot_kws={'alpha': 0.6},\n     diag_kws={'bins': 30}) \n```", "```py\n    fig, ax = plt.subplots(1, 2)\n    sns.regplot('RM', 'MEDV', df, ax=ax[0],\n    scatter_kws={'alpha': 0.4}))\n    sns.regplot('LSTAT', 'MEDV', df, ax=ax[1],\n    scatter_kws={'alpha': 0.4})) \n```", "```py\n    fig, ax = plt.subplots(1, 2)\n    ax[0] = sns.residplot('RM', 'MEDV', df, ax=ax[0],\n                      scatter_kws={'alpha': 0.4})\n    ax[0].set_ylabel('MDEV residuals $(y-\\hat{y})$')\n    ax[1] = sns.residplot('LSTAT', 'MEDV', df, ax=ax[1],\n                      scatter_kws={'alpha': 0.4})\n    ax[1].set_ylabel('')\n```", "```py\n      def get_mse(df, feature, target='MEDV'):\n      # Get x, y to model\n      y = df[target].values\n      x = df[feature].values.reshape(-1,1)\n      ...\n      ...\n      error = mean_squared_error(y, y_pred)\n      print('mse = {:.2f}'.format(error))\n      print() \n```", "```py\n      get_mse(df, 'RM')\n      get_mse(df, 'LSTAT') \n\n```", "```py\n    y = df['MEDV'].values\n    x = df['LSTAT'].values.reshape(-1,1) \n```", "```py\n    from sklearn.preprocessing import PolynomialFeatures\n    poly = PolynomialFeatures(degree=3) \n```", "```py\n     x_poly = poly.fit_transform(x) \n```", "```py\n    from sklearn.linear_model import LinearRegression\n    clf = LinearRegression()\n    clf.fit(x_poly, y) \n```", "```py\n    a_0 = clf.intercept_ + clf.coef_[0]   #intercept\n    a_1, a_2, a_3 = clf.coef_[1:]         #other coefficients\n    msg = 'model: y = {:.3f} + {:.3f}x + \n    {:.3f}x^2 + {:.3f}x^3'\\.format(a_0, a_1,  a_2, a_3)\n    print(msg) \n```", "```py\n    y_pred = clf.predict(x_poly)\n    resid_MEDV = y - y_pred \n```", "```py\n    from sklearn.metrics import mean_squared_error\n    error = mean_squared_error(y, y_pred)\n    print('mse = {:.2f}'.format(error)) \n```", "```py\n    fig, ax = plt.subplots()\n    # Plot the samples\n    ax.scatter(x.flatten(), y, alpha=0.6)\n    # Plot the polynomial model\n    x_ = np.linspace(2, 38, 50).reshape(-1, 1)\n    x_poly = poly.fit_transform(x_)\n    y_ = clf.predict(x_poly)\n    ax.plot(x_, y_, color='red', alpha=0.8)\n    ax.set_xlabel('LSTAT'); ax.set_ylabel('MEDV'); \n```", "```py\n    fig, ax = plt.subplots(figsize=(5, 7))\n    ax.scatter(x, resid_MEDV, alpha=0.6)\n    ax.set_xlabel('LSTAT')\n    ax.set_ylabel('MEDV Residual $(y-\\hat{y})$')    \n    plt.axhline(0, color='black', ls='dotted'); \n```", "```py\n    sns.distplot(df.AGE.values, bins=100,\n    hist_kws={'cumulative': True},\n    kde_kws={'lw': 0})\n    plt.xlabel('AGE')\n    plt.ylabel('CDF')\n    plt.axhline(0.33, color='red')\n    plt.axhline(0.66, color='red')\n    plt.xlim(0, df.AGE.max()); \n```", "```py\n    def get_age_category(x):\n        if x < 50:\n            return 'Relatively New'\n        elif 50 <= x < 85:\n            return 'Relatively Old'\n        else:\n            return 'Very Old'\n    df['AGE_category'] = df.AGE.apply(get_age_category)\n```", "```py\n    sns.violinplot(x='MEDV', y='AGE_category', data=df,\n    order=['Relatively New', 'Relatively Old', 'Very Old']); \n```", "```py\n    cols = ['RM', 'AGE', 'TAX', 'LSTAT', 'MEDV', 'AGE_category']\n    sns.pairplot(df[cols], hue='AGE_category',\n    hue_order=['Relatively New', 'Relatively Old', 'Very Old'],\n    plot_kws={'alpha': 0.5}, diag_kws={'bins': 30}); \n```"]