<html><head></head><body>
		<div id="_idContainer011">
			<h1 id="_idParaDest-52" class="chapter-number"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.2.1">Short Introduction to Plugins</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">Welcome to </span><a href="B21128_04.xhtml#_idTextAnchor052"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.5.1">! </span><span class="koboSpan" id="kobo.5.2">In this chapter, we will </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.6.1">provide a brief introduction to </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">plugins</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.8.1">in </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.9.1">Auto-GPT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.11.1">As more and </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.12.1">more people came up with new ideas on what Auto-GPT could do, we realized that it would be impossible to implement all of them into the core project of Auto-GPT, so we decided to create a plugin system that allows users to extend the functionality of Auto-GPT by adding their </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">own plugins.</span></span></p>
			<p><span class="koboSpan" id="kobo.14.1">In this chapter, we will go through </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">these topics:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.16.1">Going through an overview of plugins </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">in Auto-GPT</span></span></li>
				<li><span class="koboSpan" id="kobo.18.1">Knowing the types of plugins and their </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">use cases</span></span></li>
				<li><span class="koboSpan" id="kobo.20.1">Learning how to </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">use plugins</span></span></li>
				<li><span class="koboSpan" id="kobo.22.1">Understanding how plugins </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">are built</span></span></li>
				<li><span class="koboSpan" id="kobo.24.1">Using my Telegram plugin as a </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">hands-on example</span></span></li>
			</ul>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.26.1">Going through an overview of plugins in Auto-GPT</span></h1>
			<p><span class="koboSpan" id="kobo.27.1">Plugins in Auto-GPT serve as modular extensions that enable additional functionality and </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.28.1">customization of your own Auto-GPT instance. </span><span class="koboSpan" id="kobo.28.2">They </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.29.1">provide a way to integrate external tools, services, and models seamlessly into the Auto-GPT framework. </span><span class="koboSpan" id="kobo.29.2">By leveraging plugins, you can tailor Auto-GPT to suit specific tasks, domains, or applications, such as having your own customer support chat, having your own researching AI that gives you suggestions or helps you schedule your calendar, and so </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">much more!</span></span></p>
			<p><span class="koboSpan" id="kobo.31.1">Auto-GPT has interfaces that allow you to integrate it with almost anything that has text output or non-visual interface (with a little bit of coding, you may even make a VS Code plugin that allows Auto-GPT to navigate through projects and lines </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">of code).</span></span></p>
			<p><span class="koboSpan" id="kobo.33.1">Auto-GPT has an official plugin repository that contains a wide range of plugins. </span><span class="koboSpan" id="kobo.33.2">These plugins were developed as standalone plugins at first, but anyone who wants to add their plugin to the official list can do so by submitting a pull request. </span><span class="koboSpan" id="kobo.33.3">The official plugins are maintained by the Auto-GPT team and are thoroughly tested to ensure compatibility with the latest version of Auto-GPT. </span><span class="koboSpan" id="kobo.33.4">Although the original creator is responsible for maintaining </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.34.1">the plugin, the Auto-GPT team will provide </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.35.1">support and assistance as needed but also remove plugins that are no longer maintained and do not </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">work anymore.</span></span></p>
			<p><span class="koboSpan" id="kobo.37.1">To help everyone get started with creating a plugin, the Auto-GPT team has created a plugin template that can be used as a starting point for creating your own plugin. </span><span class="koboSpan" id="kobo.37.2">The template contains all the necessary files and folders required for a plugin, including a </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">README</span></strong><span class="koboSpan" id="kobo.39.1"> file with instructions on how to use it. </span><span class="koboSpan" id="kobo.39.2">The template is available on GitHub and can be downloaded from the repository </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">at </span></span><a href="https://github.com/Significant-Gravitas/Auto-GPT-Plugin-Template"><span class="No-Break"><span class="koboSpan" id="kobo.41.1">https://github.com/Significant-Gravitas/Auto-GPT-Plugin-Template</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.42.1">.</span></span></p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.43.1">Knowing the types of plugins and their use cases</span></h1>
			<p><span class="koboSpan" id="kobo.44.1">Plugins can </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.45.1">be created for any purpose, given that the plugin template allows it. </span><span class="koboSpan" id="kobo.45.2">There </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.46.1">are various types of plugins available in </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">Auto-GPT-Plugins</span></strong><span class="koboSpan" id="kobo.48.1">, each catering to different </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">use cases.</span></span></p>
			<p><span class="koboSpan" id="kobo.50.1">Here are </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.51.1">a few examples of </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">official plugins:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.53.1">Astro Info</span></strong><span class="koboSpan" id="kobo.54.1">: This provides Auto-GPT with information </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">about astronauts</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">API Tools</span></strong><span class="koboSpan" id="kobo.57.1">: This allows Auto-GPT to make API calls of </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">various kinds</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.59.1">Baidu Search</span></strong><span class="koboSpan" id="kobo.60.1">: This integrates Baidu search engines </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">into Auto-GPT</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.62.1">Bing Search</span></strong><span class="koboSpan" id="kobo.63.1">: This integrates Bing search engines </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">into Auto-GPT</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.65.1">Bluesky</span></strong><span class="koboSpan" id="kobo.66.1">: This enables Auto-GPT to retrieve posts from Bluesky and create </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">new posts</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.68.1">Email</span></strong><span class="koboSpan" id="kobo.69.1">: This automates email drafting and intelligent replies </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">using AI</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.71.1">News Search</span></strong><span class="koboSpan" id="kobo.72.1">: This integrates news article searches, using the NewsAPI aggregator, </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">into Auto-GPT</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.74.1">Planner</span></strong><span class="koboSpan" id="kobo.75.1">: This provides a simple task planner module </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">for Auto-GPT</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.77.1">Random Values</span></strong><span class="koboSpan" id="kobo.78.1">: This enables Auto-GPT to generate various random numbers </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">and strings</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.80.1">SceneX</span></strong><span class="koboSpan" id="kobo.81.1">: This explores </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.82.1">image storytelling beyond pixels </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">with Auto-GPT</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.84.1">Telegram</span></strong><span class="koboSpan" id="kobo.85.1">: This provides a smoothly working Telegram bot that gives you all the messages you would normally get through </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">the Terminal</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.87.1">Twitter</span></strong><span class="koboSpan" id="kobo.88.1">: This retrieves Twitter posts and other related content by accessing the Twitter platform via the v1.1 API </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">using Tweepy</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.90.1">Wikipedia Search</span></strong><span class="koboSpan" id="kobo.91.1">: This allows Auto-GPT to use </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">Wikipedia directly</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.93.1">WolframAlpha Search</span></strong><span class="koboSpan" id="kobo.94.1">: This allows Auto-GPT to use </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">WolframAlpha directly</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.96.1">The community is also coming up with new plugins all the time. </span><span class="koboSpan" id="kobo.96.2">These are then found in the official Auto-GPT Discord server in the </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">#</span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.98.1">plugins</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1"> channel:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.100.1">Language model (LM) plugins</span></strong><span class="koboSpan" id="kobo.101.1">: LM plugins allow you to incorporate specialized </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.102.1">LMs into Auto-GPT. </span><span class="koboSpan" id="kobo.102.2">These </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.103.1">plugins enable fine-tuned models that are designed for specific tasks or domains, such as code generation, translation, summarization, sentiment analysis, </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">and more.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.105.1">Data source plugins</span></strong><span class="koboSpan" id="kobo.106.1">: Data source plugins enable Auto-GPT to access external data </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.107.1">sources and retrieve information </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.108.1">on demand. </span><span class="koboSpan" id="kobo.108.2">These plugins can connect Auto-GPT to databases, APIs, web scraping tools, or other data repositories. </span><span class="koboSpan" id="kobo.108.3">With data source plugins, you can enrich Auto-GPT’s knowledge and enable it to provide up-to-date and relevant information </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">to users.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.110.1">Chatbot plugins</span></strong><span class="koboSpan" id="kobo.111.1">: Chatbot </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.112.1">plugins facilitate interactive and dynamic </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.113.1">conversations with Auto-GPT. </span><span class="koboSpan" id="kobo.113.2">These plugins incorporate dialogue management techniques, allowing Auto-GPT to maintain context, remember previous interactions, and generate coherent </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.114.1">responses. </span><span class="koboSpan" id="kobo.114.2">Chatbot plugins are useful </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.115.1">for building chat assistants, customer support bots, virtual companions, </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">and more.</span></span></li>
			</ul>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.117.1">Learning how to use plugins</span></h1>
			<p><span class="koboSpan" id="kobo.118.1">Using plugins in Auto-GPT can be a bit tricky at first, but once you get the hang of it, it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">pretty easy.</span></span></p>
			<p><span class="koboSpan" id="kobo.120.1">Auto-GPT has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">plugins</span></strong><span class="koboSpan" id="kobo.122.1"> folder in its root directory, where all the plugins </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">are stored.</span></span></p>
			<p><span class="koboSpan" id="kobo.124.1">The method </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.125.1">of how the plugins are installed has changed a bit over time – you can either clone the desired plugin repository into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">plugins</span></strong><span class="koboSpan" id="kobo.127.1"> folder and zip it or just leave it there and Auto-GPT will </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">find it.</span></span></p>
			<p><span class="koboSpan" id="kobo.129.1">By the time you read this book, the plugin system might be updated to use a plugin manager, which will make it easier to install and </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">manage plugins.</span></span></p>
			<p><span class="koboSpan" id="kobo.131.1">After placing the plugin, you have to install the dependencies that are required for the plugin to work. </span><span class="koboSpan" id="kobo.131.2">This can be done by running the following command while </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">starting Auto-GPT:</span></span></p>
			<pre class="console"><span class="koboSpan" id="kobo.133.1">
python -m autogpt --install-plugin-deps</span></pre>			<p><span class="koboSpan" id="kobo.134.1">Sometimes, this function does not work. </span><span class="koboSpan" id="kobo.134.2">If the plugin is not installed, navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">plugins</span></strong><span class="koboSpan" id="kobo.136.1"> folder and into the folder of your plugin run the </span><a id="_idTextAnchor057"/><span class="No-Break"><span class="koboSpan" id="kobo.137.1">following command:</span></span></p>
			<pre class="console"><span class="koboSpan" id="kobo.138.1">
pip install -r requirements.txt</span></pre>			<p><span class="koboSpan" id="kobo.139.1">Auto-GPT should automatically install the dependencies for the plugin, and it should now tell you that it found the plugin. </span><span class="koboSpan" id="kobo.139.2">It should also tell you that the plugin is not configured yet and that you should </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">configure it.</span></span></p>
			<p><span class="koboSpan" id="kobo.141.1">Some of the plugins may still indicate that you have to make changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">.env</span></strong><span class="koboSpan" id="kobo.143.1"> file, but currently, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">.env</span></strong><span class="koboSpan" id="kobo.145.1"> file is not used anymore, so you have to configure the plugin config file, or if by the release of this book, we have finished the plugin manager, you can configure the plugin via the </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">plugin manager.</span></span></p>
			<p><span class="koboSpan" id="kobo.147.1">To figure out what names to use, just start Auto-GPT normally and it will list the plugins it found. </span><span class="koboSpan" id="kobo.147.2">If it wasn’t configured automatically, it will tell you that it </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">is not.</span></span></p>
			<p><span class="koboSpan" id="kobo.149.1">If by the time </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.150.1">you read this book, the architecture of the plugin system has changed, you can find the information on how to configure the plugin in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">README.md</span></strong><span class="koboSpan" id="kobo.152.1"> file of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">Auto-GPT-Plugins</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.154.1"> repository.</span></span></p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.155.1">Understanding how plugins are built</span></h1>
			<p><span class="koboSpan" id="kobo.156.1">Plugins in </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.157.1">Auto-GPT are built using a modular and extensible architecture. </span><span class="koboSpan" id="kobo.157.2">The exact process of building a plugin may vary depending on the type and complexity of </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">the plugin.</span></span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.159.1">Structure of a plugin</span></h2>
			<p><span class="koboSpan" id="kobo.160.1">The plugin </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.161.1">should be in its own folder and contain </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">a __init__.py</span></strong><span class="koboSpan" id="kobo.163.1">, which contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">AutoGPTPluginsTemplate</span></strong><span class="koboSpan" id="kobo.165.1"> class reference. </span><span class="koboSpan" id="kobo.165.2">Each of the class methods contains a method that determines whether the following method is active, </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">for example:</span></span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">post_prompt</span></strong><span class="koboSpan" id="kobo.168.1"> is only active if </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">can_ post_prompt</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.170.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">True</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.173.1">As we are limited to the plugin template, we can only use the methods that the template provides. </span><span class="koboSpan" id="kobo.173.2">Each method has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">can_handle</span></strong><span class="koboSpan" id="kobo.175.1"> method that returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">boolean</span></strong><span class="koboSpan" id="kobo.177.1"> value, which is used to determine whether the plugin can handle the current prompt or method. </span><span class="koboSpan" id="kobo.177.2">The plugin methods are scattered all over the Auto-GPT code and allow plugins to add functions as commands that Auto-GPT can cognitively call to give Auto-GPT agents </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">new abilities.</span></span></p>
			<p><span class="koboSpan" id="kobo.179.1">Here are some of these </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">interface methods:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">post_prompt</span></strong><span class="koboSpan" id="kobo.182.1">: This </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.183.1">adds access </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.184.1">to the prompt generator. </span><span class="koboSpan" id="kobo.184.2">This allows the plugins to edit the prompts or add new functions </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">as commands.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">on_response</span></strong><span class="koboSpan" id="kobo.187.1">: This </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.188.1">forwards the content </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.189.1">of a chat completion response to the plugin and returns the edited content </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">to Auto-GPT.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">on_planning</span></strong><span class="koboSpan" id="kobo.192.1">: This </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.193.1">allows the plugin to </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.194.1">edit the message sequence before it is sent to the Auto-GPT agent, for example, to summarize the history of the messages or to add a new message to </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">the sequence.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">post_planning</span></strong><span class="koboSpan" id="kobo.197.1">: This </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.198.1">allows the </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.199.1">editing of the response JSON of the agent’s thought planning. </span><span class="koboSpan" id="kobo.199.2">For example, this could be used to add another step of thought such as reevaluating the decision of the agent and which command it chose </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">to execute.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">pre_command</span></strong><span class="koboSpan" id="kobo.202.1">: After </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.203.1">the user </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.204.1">approves the command the agent chooses, the plugin can edit the command before it </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">is executed.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">post_command</span></strong><span class="koboSpan" id="kobo.207.1">: After </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.208.1">the command </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.209.1">has been executed and right before the results of that command are returned to the user, the plugin can edit the result and also has access to the command name that </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">was executed.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">handle_chat_completion</span></strong><span class="koboSpan" id="kobo.212.1">: This is used to add a custom chat completion function </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.213.1">to Auto-GPT agents. </span><span class="koboSpan" id="kobo.213.2">If this is enabled, OpenAI’s GPT will not be used for chat completion mostly but could still be used if at certain places only GPT can be used or just not </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">implemented cleanly.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">handle_text_embedding</span></strong><span class="koboSpan" id="kobo.216.1">: This </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.217.1">adds the ability to add text embedding to Auto-GPT agents other than the </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">memory module.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">user_input</span></strong><span class="koboSpan" id="kobo.220.1">: This is </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.221.1">used to forward the user input query to the plugin instead of the console </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">or terminal.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">report</span></strong><span class="koboSpan" id="kobo.224.1">: This is </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.225.1">used to forward logs to the plugin that would usually only be printed to the console </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">or terminal.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.227.1">You are also free to copy and paste parts of other plugins that you find useful and use them in your own plugin, as long as you give credit to the original author of </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">the code.</span></span></p>
			<p><span class="koboSpan" id="kobo.229.1">The Planner plugin is </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.230.1">a good example of how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">PromptGenerator</span></strong><span class="koboSpan" id="kobo.232.1"> class to add new commands to </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">Auto-GPT agents.</span></span></p>
			<p><span class="koboSpan" id="kobo.234.1">If you want to create a plugin that enables communication, you may also check what already exists in the </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">Auto-GPT Discord.</span></span></p>
			<p><span class="koboSpan" id="kobo.236.1">Multiple projects exist now that also enable multiple ways to communicate with Auto-GPT and maybe you can even come up with the ultimate communication plugin that enables Auto-GPT to communicate with their humans in any </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">way possible.</span></span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.238.1">How to build plugins</span></h2>
			<p><span class="koboSpan" id="kobo.239.1">As you embark on the journey of building plugins for Auto-GPT, it’s crucial to approach the process </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.240.1">with a well-rounded strategy. </span><span class="koboSpan" id="kobo.240.2">Here, we outline a step-by-step guide to help you plan, develop, and share your plugin effectively within </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">the community.</span></span></p>
			<p><span class="koboSpan" id="kobo.242.1">It is a good idea to plan out what you want to do with your plugin and what you want to achieve with it. </span><span class="koboSpan" id="kobo.242.2">A basic procedure would be </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">as follows:</span></span></p>
			<ol>
				<li><strong class="bold"><span class="koboSpan" id="kobo.244.1">Define functionality</span></strong><span class="koboSpan" id="kobo.245.1">: Start by defining the functionality or features the plugin will provide. </span><span class="koboSpan" id="kobo.245.2">Identify the specific task, domain, or integration point that the plugin aims </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">to address.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.247.1">Implement plugin logic</span></strong><span class="koboSpan" id="kobo.248.1">: Develop the necessary code to implement the desired functionality. </span><span class="koboSpan" id="kobo.248.2">This may involve writing custom classes, functions, or methods that interact with Auto-GPT or </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">external services.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.250.1">Handle integration</span></strong><span class="koboSpan" id="kobo.251.1">: Consider how the plugin will integrate with Auto-GPT. </span><span class="koboSpan" id="kobo.251.2">This may involve hooking into specific events or methods within the Auto-GPT framework to intercept prompts, modify responses, or access </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">data sources.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.253.1">Test and refine</span></strong><span class="koboSpan" id="kobo.254.1">: Thoroughly test the plugin to ensure its functionality and compatibility with Auto-GPT. </span><span class="koboSpan" id="kobo.254.2">Iterate and refine the plugin based on feedback and testing results. </span><span class="koboSpan" id="kobo.254.3">If you can, write unit tests for your plugin to ensure that it works </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">as intended.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.256.1">Although the team is very forthcoming, if you want your plugin to become an official “first party” plugin, you should write unit tests for it and document it properly. </span><span class="koboSpan" id="kobo.256.2">Otherwise, if people don’t understand your plugin and it is not documented properly, it will not stay in the official plugin repository for long as it requires more time to read into the code to check how </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">it works.</span></span></p></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.258.1">Publish and share</span></strong><span class="koboSpan" id="kobo.259.1">: Once the plugin is ready, you can publish and share it with the Auto-GPT community. </span><span class="koboSpan" id="kobo.259.2">This allows other users to benefit from your plugin and encourages collaboration and innovation within the ecosystem. </span><span class="koboSpan" id="kobo.259.3">Most people just </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.260.1">create a Discord thread in the </span><strong class="bold"><span class="koboSpan" id="kobo.261.1">#plugins</span></strong><span class="koboSpan" id="kobo.262.1"> channel and share their plugin there, so if someone has a question, you can answer directly without having to handle multiple GitHub issues being created (which can be frustrating, as once you resolve an issue, people close it and the next day another person will ask the same question and most users do not even provide enough information of what they did or they just do not read the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">README.md</span></strong><span class="koboSpan" id="kobo.264.1"> file of the plugin or just skip steps and just tell you stuff that is nowhere related to </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">your plugin).</span></span></li>
			</ol>
			<p><span class="koboSpan" id="kobo.266.1">Now that we have learned a simple way of planning a plugin that would be then qualified to join Auto-GPT’s plugin list, we can use one of the plugins as an example to build </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">one ourselves.</span></span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.268.1">Using my Telegram plugin as a hands-on example</span></h1>
			<p><span class="koboSpan" id="kobo.269.1">Here, we </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.270.1">will go through the plugin example and see the steps we need </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">to follow:</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.272.1">To demonstrate how plugins are made, I decided to include my Auto-GPT plugin for </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">Telegram integration.</span></span></li>
				<li><span class="koboSpan" id="kobo.274.1">It involves simply forwarding messages to the user and is also capable of asking the user a question and awaiting a response. </span><span class="koboSpan" id="kobo.274.2">Basically, your Telegram chat becomes a remote extension to the console/terminal application and you can leave Auto-GPT running on your machine and operate it remotely with </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">your phone.</span></span></li>
				<li><span class="koboSpan" id="kobo.276.1">Fill the interface class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">__init__.py</span></strong><span class="koboSpan" id="kobo.278.1"> file. </span><span class="koboSpan" id="kobo.278.2">This file acts as the core of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">AutoGPTTelegram</span></strong><span class="koboSpan" id="kobo.280.1"> plugin. </span><span class="koboSpan" id="kobo.280.2">It houses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">AutoGPTTelegram</span></strong><span class="koboSpan" id="kobo.282.1"> class, which inherits from </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">AutoGPTPluginTemplate</span></strong><span class="koboSpan" id="kobo.284.1">. </span><span class="koboSpan" id="kobo.284.2">To get the template, go to the </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">Significant Gravitas GitHub</span></strong><span class="koboSpan" id="kobo.286.1"> page and either clone the Auto-GPT plugin template (which by this time is outdated) or copy-paste any of the other plugin folders </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.287.1">and make your own by just modifying </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">__init__.py</span></strong><span class="koboSpan" id="kobo.289.1"> and return </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">False</span></strong><span class="koboSpan" id="kobo.291.1"> on the methods you do not intend </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">to use.</span></span></li>
				<li><span class="koboSpan" id="kobo.293.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">__init__</span></strong><span class="koboSpan" id="kobo.295.1"> method is </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.296.1">crucial for setting up the plugin. </span><span class="koboSpan" id="kobo.296.2">It initializes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">TelegramUtils</span></strong><span class="koboSpan" id="kobo.298.1"> object that will be used for interactions with the </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">Telegram API:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.300.1">
class AutoGPTTelegram(AutoGPTPluginTemplate):
    def __init__(self):
        super().__init__()
        self._name = "AutoGPTTelegram"
        self._version = "1.0.0"
        self._description = "This plugin integrates Auto-GPT with a Telegram bot."
</span><span class="koboSpan" id="kobo.300.2">        self.telegram_chat_id = "YOUR_TELEGRAM_CHAT_ID"
        self.telegram_api_key = "YOUR_TELEGRAM_API_KEY"
        self.telegram_utils = TelegramUtils(
            chat_id=self.telegram_chat_id,
            api_key=self.telegram_api_key
)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.301.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">self._name</span></strong><span class="koboSpan" id="kobo.303.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">self._version</span></strong><span class="koboSpan" id="kobo.305.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">self._description</span></strong><span class="koboSpan" id="kobo.307.1"> are attributes to describe the plugin while </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">self.telegram_chat_id</span></strong><span class="koboSpan" id="kobo.309.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">self.telegram_api_key</span></strong><span class="koboSpan" id="kobo.311.1"> are placeholders for your Telegram credentials. </span><span class="koboSpan" id="kobo.311.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">TelegramUtils</span></strong><span class="koboSpan" id="kobo.313.1"> object is created with </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">these credentials.</span></span></p></li>				<li><span class="koboSpan" id="kobo.315.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">can_handle_user_input</span></strong><span class="koboSpan" id="kobo.317.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">user_input</span></strong><span class="koboSpan" id="kobo.319.1"> methods work in tandem </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.320.1">to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">user input:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.322.1">
def can_handle_user_input(self, user_input: str) -&gt; bool:
    return True
def user_input(self, user_input: str) -&gt; str:
    return self.telegram_utils.ask_user(prompt=user_input)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.323.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">can_handle_user_input</span></strong><span class="koboSpan" id="kobo.325.1"> method </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.326.1">returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">True</span></strong><span class="koboSpan" id="kobo.328.1">, indicating that this plugin can handle user input. </span><span class="koboSpan" id="kobo.328.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">user_input</span></strong><span class="koboSpan" id="kobo.330.1"> method </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.331.1">takes the user’s input and calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">ask_user</span></strong><span class="koboSpan" id="kobo.333.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">TelegramUtils</span></strong><span class="koboSpan" id="kobo.335.1"> to interact with the user </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">via Telegram.</span></span></p></li>				<li><span class="koboSpan" id="kobo.337.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">can_handle_report</span></strong><span class="koboSpan" id="kobo.339.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">report</span></strong><span class="koboSpan" id="kobo.341.1"> methods are designed to </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">manage reporting:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.343.1">
def can_handle_report(self) -&gt; bool:
    return True
def report(self, message: str) -&gt; None:
    self.telegram_utils.send_message(message=message)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.344.1">Similar to user input handling, </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">can_handle_report</span></strong><span class="koboSpan" id="kobo.346.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">True</span></strong><span class="koboSpan" id="kobo.348.1"> to signify that this plugin can handle reporting. </span><span class="koboSpan" id="kobo.348.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">report</span></strong><span class="koboSpan" id="kobo.350.1"> method sends a message to the user via Telegram using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">send_message</span></strong><span class="koboSpan" id="kobo.352.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">TelegramUtils</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">.</span></span></p></li>				<li><span class="koboSpan" id="kobo.356.1">Other methods in this class are disabled by default but can be enabled to </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">extend functionality:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.358.1">
def can_handle_on_response(self) -&gt; bool:
return False</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.359.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">can_handle_on_response</span></strong><span class="koboSpan" id="kobo.361.1"> method here is a placeholder that could be enabled to process responses in a </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">certain way.</span></span></p></li>				<li><span class="koboSpan" id="kobo.363.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">telegram_chat.py</span></strong><span class="koboSpan" id="kobo.365.1"> file contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">TelegramUtils</span></strong><span class="koboSpan" id="kobo.367.1"> class, which houses utility methods for Telegram interactions. </span><span class="koboSpan" id="kobo.367.2">Of course, you could write all you </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.368.1">need in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">init</span></strong><span class="koboSpan" id="kobo.370.1"> file, but it would be less than readable in the end. </span><span class="koboSpan" id="kobo.370.2">This walk-through might even be chunked into more files, but as I try to cover as many readers with different levels of knowledge as possible, we only do two files </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">in total.</span></span><ol><li class="upper-roman"><span class="koboSpan" id="kobo.372.1">We will first write a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">TelegramUtils</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.374.1"> class:</span></span><pre class="source-code2"><span class="koboSpan" id="kobo.375.1">class TelegramUtils:
    def __init__(self, api_key: str = None, 
        chat_id: str = None):
# this is filled in the next step.</span></pre></li><li class="upper-roman"><span class="koboSpan" id="kobo.376.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">__init__</span></strong><span class="koboSpan" id="kobo.378.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">TelegramUtils</span></strong><span class="koboSpan" id="kobo.380.1"> class initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">TelegramUtils</span></strong><span class="koboSpan" id="kobo.382.1"> object with the API key and chat ID or guides the user on how to obtain them if they’re </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">not provided:</span></span><pre class="source-code2"><span class="koboSpan" id="kobo.384.1">def __init__(self, api_key: str = None, 
    chat_id: str = None):
    self.api_key = api_key
    self.chat_id = chat_id
    if not api_key or not chat_id:
        # Display instructions to the user on how to get API key and chat ID
        print("Please set the TELEGRAM_API_KEY and 
        TELEGRAM_CHAT_ID environment variables.")</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.385.1">Here, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">api_key</span></strong><span class="koboSpan" id="kobo.387.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">chat_id</span></strong><span class="koboSpan" id="kobo.389.1"> is not provided, instructions are displayed to the user on how to </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">obtain them.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.391.1">In the </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.392.1">actual plugin, I decided to add more information for the user; the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">__init__</span></strong><span class="koboSpan" id="kobo.394.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">TelegramUtils</span></strong><span class="koboSpan" id="kobo.396.1"> class is more extensive and the code further handles the scenario where </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">api_key</span></strong><span class="koboSpan" id="kobo.398.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">chat_id</span></strong><span class="koboSpan" id="kobo.400.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">not provided:</span></span></p><pre class="source-code2"><span class="koboSpan" id="kobo.402.1">        if not api_key:
            print("No api key provided. </span><span class="koboSpan" id="kobo.402.2">Please set the 
                TELEGRAM_API_KEY environment   variable.")
            print("You can get your api key by talking to @
                BotFather on Telegram.")
            print( "For more information: 
https://core.telegram.org/bots/tutorial#6-  b  otfather"  )
            return
        if not chat_id:
            print( "Please set the TELEGRAM_CHAT_ID 
                environment variable.")
            user_input = input( "Would you like to send a test message to your bot to get the   id? </span><span class="koboSpan" id="kobo.402.3">(y/n): ")
            if user_input == "y":
                try:
                    print("Please send a message to your telegram bot now.")
                    update = self.poll_anyMessage()
                    print("Message received! 
</span><span class="koboSpan" id="kobo.402.4">                        Getting chat id...")
                    chat_id = update.message.chat.id
                    print("Your chat id is: " + 
                        str(chat_id))
                    print("And the message is: " + 
                        update.message.text)
                    confirmation = 
                        random.randint(1000, 9999)
                    print("Sending confirmation message: " 
                        + str(confirmation))
                    text = f"Chat id is: {chat_id} and the 
                      confirmation code is {confirmation}"
                    self.chat_id = chat_id
                    self.send_message(text)  
# Send confirmation message
                    print( "Please set the TELEGRAM_CHAT_ID 
                        environment variable to this.")
              except TimedOut:
                    print( "Error while sending test 
                    message. </span><span class="koboSpan" id="kobo.402.5">Please check your Telegram 
                        bot.")
                    return
    self.chat_id = chat_id</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.403.1">In the </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.404.1">preceding block, the method first checks whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">api_key</span></strong><span class="koboSpan" id="kobo.406.1"> is provided. </span><span class="koboSpan" id="kobo.406.2">If not, it instructs the user to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">TELEGRAM_API_KEY</span></strong><span class="koboSpan" id="kobo.408.1"> environment variable and provides guidance on where to obtain the API key. </span><span class="koboSpan" id="kobo.408.2">Similarly, for </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">chat_id</span></strong><span class="koboSpan" id="kobo.410.1">, it instructs the user to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">TELEGRAM_CHAT_ID</span></strong><span class="koboSpan" id="kobo.412.1"> environment variable and offers to send a test message to the bot to obtain the chat ID if the </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">user agrees.</span></span></p></li><li class="upper-roman"><span class="koboSpan" id="kobo.414.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">ask_user</span></strong><span class="koboSpan" id="kobo.416.1"> method is </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.417.1">designed to prompt the user for input through Telegram. </span><span class="koboSpan" id="kobo.417.2">It calls its asynchronous counterpart, </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">ask_user_async</span></strong><span class="koboSpan" id="kobo.419.1">, to handle </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.420.1">the user </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">input asynchronously:</span></span><pre class="source-code2"><span class="koboSpan" id="kobo.422.1">def ask_user(self, prompt):
    try:
        return asyncio.run(
            self.ask_user_async(prompt=prompt))
    except TimedOut:
        print("Telegram timeout error, trying again...")
        return self.ask_user(prompt=prompt)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.423.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">ask_user</span></strong><span class="koboSpan" id="kobo.425.1"> method calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">ask_user_async</span></strong><span class="koboSpan" id="kobo.427.1"> within a try block to handle any </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">TimedOut</span></strong><span class="koboSpan" id="kobo.429.1"> exceptions that might occur during </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">the process.</span></span></p></li><li class="upper-roman"><span class="koboSpan" id="kobo.431.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">user_input</span></strong><span class="koboSpan" id="kobo.433.1"> method handles user input within the plugin, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">telegram_utils.ask_user</span></strong><span class="koboSpan" id="kobo.435.1"> method to gather input from the user </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">via Telegram:</span></span><pre class="source-code2"><span class="koboSpan" id="kobo.437.1">def user_input(self, user_input: str) -&gt; str:
    user_input = remove_color_codes(user_input)
    try:
        return self.telegram_utils.ask_user(
            prompt=user_input)
    except Exception as e:
        print(e)
        print("Error sending message to telegram")
        return "s"  # s means that auto-gpt should rethink its last step, indicating an error with the call</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.438.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">user_input</span></strong><span class="koboSpan" id="kobo.440.1"> method first sanitizes the input to remove color codes, then calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">ask_user</span></strong><span class="koboSpan" id="kobo.442.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">TelegramUtils</span></strong><span class="koboSpan" id="kobo.444.1"> to interact with the user </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">on Telegram.</span></span></p></li><li class="upper-roman"><span class="koboSpan" id="kobo.446.1">Write the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">report</span></strong><span class="koboSpan" id="kobo.448.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">AutoGPTTelegram</span></strong><span class="koboSpan" id="kobo.450.1"> class to send messages. </span><span class="koboSpan" id="kobo.450.2">This method is used for sending status reports or any other messages </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.451.1">from Auto-GPT to the user </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">via Telegram.</span></span><pre class="source-code2"><span class="koboSpan" id="kobo.453.1">def report(self, message: str) -&gt; None:
    message = remove_color_codes(message)
    try:
        self.telegram_utils.send_message(message=message)
    except Exception as e:
        print(e)
        print("Error sending message to telegram")</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.454.1">In this method, any color codes in the message are removed first, and then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">send_message</span></strong><span class="koboSpan" id="kobo.456.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">TelegramUtils</span></strong><span class="koboSpan" id="kobo.458.1"> is called to send the message to the user </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">on Telegram.</span></span></p></li></ol></li>
				<li><span class="koboSpan" id="kobo.460.1">Moving on to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">telegram_chat.py</span></strong><span class="koboSpan" id="kobo.462.1"> file, it contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">TelegramUtils</span></strong><span class="koboSpan" id="kobo.464.1"> class, which encapsulates the following utility methods for </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">Telegram interactions:</span></span><ul><li><span class="koboSpan" id="kobo.466.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">__init__</span></strong><span class="koboSpan" id="kobo.468.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">TelegramUtils</span></strong><span class="koboSpan" id="kobo.470.1"> class, which has already </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">been explained.</span></span></li><li><span class="koboSpan" id="kobo.472.1">Implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">get_bot</span></strong><span class="koboSpan" id="kobo.474.1"> method, which is responsible for obtaining a Telegram bot instance using the </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">bot token:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.476.1">
async def get_bot(self):
    bot_token = self.api_key
    bot = Bot(token=bot_token)
    commands = await bot.get_my_commands()
    if len(commands) == 0:
        await self.set_commands(bot)
    commands = await bot.get_my_commands()
    return bot</span></pre></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.477.1">In this </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.478.1">method, a new bot instance is created using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">Bot</span></strong><span class="koboSpan" id="kobo.480.1"> class from the Telegram package. </span><span class="koboSpan" id="kobo.480.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">get_bot</span></strong><span class="koboSpan" id="kobo.482.1"> method checks whether the bot has any commands set already, and if not, it calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">set_commands</span></strong><span class="koboSpan" id="kobo.484.1"> to set the commands for </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">the bot.</span></span></p><ul><li><span class="koboSpan" id="kobo.486.1">Implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">poll_anyMessage</span></strong><span class="koboSpan" id="kobo.488.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">poll_anyMessage_async</span></strong><span class="koboSpan" id="kobo.490.1"> methods, which </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.491.1">are designed to poll for any </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.492.1">message sent to </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">the bot:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.494.1">def poll_anyMessage(self):
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    return loop.run_until_complete(self.poll_anyMessage_async())
async def poll_anyMessage_async(self):
    bot = Bot(token=self.api_key)
    last_update = await bot.get_updates(timeout=30)
    if len(last_update) &gt; 0:
        last_update_id = last_update[-1].update_id
    else:
        last_update_id = -1
    while True:
        try:
            print("Waiting for first message...")
            updates = await bot.get_updates(
                offset=last_update_id + 1, timeout=30)
            for update in updates:
                if update.message:
                    return update
        except Exception as e:
            print(f"Error while polling updates: {e}")
        await asyncio.sleep(1)</span></pre></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.495.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">poll_anyMessage</span></strong><span class="koboSpan" id="kobo.497.1"> sets up a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">asyncio</span></strong><span class="koboSpan" id="kobo.499.1"> event loop and calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">poll_anyMessage_async</span></strong><span class="koboSpan" id="kobo.501.1"> to poll for </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">messages asynchronously.</span></span></p><ul><li><span class="koboSpan" id="kobo.503.1">Implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">send_message</span></strong><span class="koboSpan" id="kobo.505.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">_send_message</span></strong><span class="koboSpan" id="kobo.507.1"> methods, which </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.508.1">are utilized for sending messages to the </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">Telegram chat:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.510.1">def send_message(self, message):
    try:
        loop = asyncio.get_running_loop()
    except RuntimeError as e:
        loop = None
    try:
        if loop and loop.is_running():
            print(
                "Sending message async, if this fails its due to rununtil complete task"
            )
            loop.create_task(
                self._send_message(message=message))
        else:
            eventloop = asyncio.get_event_loop
            if hasattr(eventloop, "run_until_complete")
            and eventloop.is_running():
                print("Event loop is running")
                eventloop.run_until_complete(
                    self._send_message(message=message))
            else:
                asyncio.run(self._send_message(message=message))
    except RuntimeError as e:
        print(traceback.format_exc())
        print("Error while sending message")
        print(e)
async def _send_message(self, message):
    print("Sending message to Telegram.. </span><span class="koboSpan" id="kobo.510.2">")
    recipient_chat_id = self.chat_id
    bot = await self.get_bot()
    # properly handle messages with more than 2000 characters by chunking them
    if len(message) &gt; 2000:
        message_chunks = [
            message[i : i + 2000] for i in range(0, 
                len(message), 2000)
        ]
        message_chunks = [
            message[i : i + 2000] for i in range(0, 
                len(message), 2000)
        ]
        for message_chunk in message_chunks:
            await bot.send_message(
                chat_id=recipient_chat_id,
                text=message_chunk)
    else:
        await bot.send_message(
            chat_id=recipient_chat_id, text=message)</span></pre></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.511.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">send_message</span></strong><span class="koboSpan" id="kobo.513.1">, it first </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.514.1">tries to get the current running </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">asyncio</span></strong><span class="koboSpan" id="kobo.516.1"> event loop. </span><span class="koboSpan" id="kobo.516.2">If there isn’t one running, it sets </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">loop</span></strong><span class="koboSpan" id="kobo.518.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">None</span></strong><span class="koboSpan" id="kobo.520.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">_send_message</span></strong><span class="koboSpan" id="kobo.522.1"> is the asynchronous counterpart that actually sends the message </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">to Telegram.</span></span></p><ul><li><span class="koboSpan" id="kobo.524.1">Implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">ask_user</span></strong><span class="koboSpan" id="kobo.526.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">ask_user_async</span></strong><span class="koboSpan" id="kobo.528.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">_poll_updates</span></strong><span class="koboSpan" id="kobo.530.1"> methods, which manage the interaction of asking the user a question and waiting </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.531.1">for their response </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">on Telegram:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.533.1">    async def ask_user_async(self, prompt):
        global response_queue
        response_queue = ""
        # await delete_old_messages()
        print("Asking user: " + question)
        await self._send_message(message=question)
        await self._send_message(message=question)
        print("Waiting for response on Telegram chat...")
        await self._poll_updates()
        response_text = response_queue
        print("Response received from Telegram: " + 
            response_text)
        return response_text
async def _poll_updates(self):
    global response_queue
    bot = await self.get_bot()
    print("getting updates...")
    try:
        last_update = await bot.get_updates(timeout=1)
        if len(last_update) &gt; 0:
            last_update_id = last_update[-1].update_id
        else:
            last_update_id = -1
        print("last update id: " + str(last_update_id))
        while True:
            try:
                print("Polling updates...")
                updates = await bot.get_updates(
                    offset=last_update_id + 1, timeout=30)
                for update in updates:
                    if update.message and update.message.text:
                        if self.is_authorized_user(update):
                            response_queue = update.message.text
                            return
                    last_update_id = max(
                        last_update_id, update.update_id)
            except Exception as e:
                print(f"Error while polling updates: {e}")
            await asyncio.sleep(1)
    except RuntimeError:
        print("Error while polling updates")
def ask_user(self, prompt):
    print("Asking user: " + prompt)
    try:
        loop = asyncio.get_running_loop()
    except RuntimeError:  # 'RuntimeError: There is no current event loop...'
</span><span class="koboSpan" id="kobo.533.2">        loop = None
    try:
        if loop and loop.is_running():
            return loop.create_task(
                self.ask_user_async(prompt=prompt))
        else:
            return asyncio.run(
                self.ask_user_async(prompt=prompt))
    except TimedOut:
        print("Telegram timeout error, trying again...")
        return self.ask_user(prompt=prompt)</span></pre></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.534.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">ask_user_async</span></strong><span class="koboSpan" id="kobo.536.1">, a question is sent to the user on Telegram and </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">_poll_updates</span></strong><span class="koboSpan" id="kobo.538.1"> is called to wait for their response. </span><span class="koboSpan" id="kobo.538.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">ask_user</span></strong><span class="koboSpan" id="kobo.540.1"> method serves as a synchronous wrapper </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">around </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">ask_user_async</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">.</span></span></p></li>			</ol>
			<p><span class="koboSpan" id="kobo.544.1">Each of these methods plays a critical role in the Telegram interaction, allowing Auto-GPT to communicate with the user via a Telegram bot. </span><span class="koboSpan" id="kobo.544.2">The process is well structured, ensuring </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.545.1">that the plugin can handle various scenarios that might arise during </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">the interaction.</span></span></p>
			<p><span class="koboSpan" id="kobo.547.1">The methods and code snippets discussed thus far provide a well-rounded framework for integrating Auto-GPT with a Telegram bot. </span><span class="koboSpan" id="kobo.547.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">telegram_chat.py</span></strong><span class="koboSpan" id="kobo.549.1"> file encapsulates Telegram-specific logic, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">__init__.py</span></strong><span class="koboSpan" id="kobo.551.1"> file handles the interaction with Auto-GPT using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">TelegramUtils</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.553.1"> class.</span></span></p>
			<p><span class="koboSpan" id="kobo.554.1">Now, let’s delve further into some specific segments of the code that may require </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">additional elaboration:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.556.1">Handling long messages</span></strong><span class="koboSpan" id="kobo.557.1">: In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">_send_message</span></strong><span class="koboSpan" id="kobo.559.1"> method, there’s a segment </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.560.1">of code dedicated to handling messages that exceed </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">2000 characters:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.562.1">
    if len(message) &gt; 2000:
        message_chunks = [
            message[i : i + 2000] for i in range(0, 
                len(message), 2000)
        ]
        for message_chunk in message_chunks:
            await bot.send_message(
                chat_id=recipient_chat_id,
                text=message_chunk)
    else:
        await bot.send_message(
            chat_id=recipient_chat_id, text=message)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.563.1">This segment ensures that if a message is longer than 2,000 characters, it’s split into chunks of 2,000 characters each, and each chunk is sent as a separate message to Telegram. </span><span class="koboSpan" id="kobo.563.2">This is essential for ensuring the integrity of the message being sent, given the maximum message length constraint </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">in Telegram.</span></span></p></li>				<li><strong class="bold"><span class="koboSpan" id="kobo.565.1">Re-trying on timeout</span></strong><span class="koboSpan" id="kobo.566.1">: In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">ask_user</span></strong><span class="koboSpan" id="kobo.568.1"> method, there’s logic to handle a </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">TimedOut</span></strong><span class="koboSpan" id="kobo.570.1"> exception </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.571.1">by re-trying the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">ask_user</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.573.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.574.1">
except TimedOut:
    print("Telegram timeout error, trying again...")
    return self.ask_user(prompt=prompt)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.575.1">This is a robust way to handle timeouts, ensuring that the plugin retries to ask the user for input </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">until successful.</span></span></p></li>				<li><strong class="bold"><span class="koboSpan" id="kobo.577.1">Asynchronous handling</span></strong><span class="koboSpan" id="kobo.578.1">: Various parts of the code utilize asynchronous programming </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.579.1">principles to ensure non-blocking operations, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.581.1">
async def _send_message(self, message):
    # ...
</span><span class="koboSpan" id="kobo.581.2">    await bot.send_message(chat_id=recipient_chat_id, 
        text=message)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.582.1">Utilizing asynchronous methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">await bot.send_message(...)</span></strong><span class="koboSpan" id="kobo.584.1"> ensures that the IO-bound operations do not block the execution of the program, leading to a more responsive and </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">performant plugin.</span></span></p></li>				<li><strong class="bold"><span class="koboSpan" id="kobo.586.1">Error handling</span></strong><span class="koboSpan" id="kobo.587.1">: Throughout </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.588.1">the code, exception handling is employed to catch and handle errors gracefully, ensuring that any issues are logged and dealt </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">with appropriately:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.590.1">
except Exception as e:
    print(f"Error while polling updates: {e}")</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.591.1">This approach promotes robustness and error resilience in the </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">plugin’s operation.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.593.1">The walk-through of the code has covered the fundamental aspects of how the Telegram </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.594.1">plugin for Auto-GPT operates, from initialization to user interaction and error handling. </span><span class="koboSpan" id="kobo.594.2">However, there are still some nuanced elements and potential enhancements that could be considered to refine or expand the plugin’s functionality. </span><span class="koboSpan" id="kobo.594.3">Here are a few additional points </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">and recommendations:</span></span></p></li>				<li><strong class="bold"><span class="koboSpan" id="kobo.596.1">Authorization check</span></strong><span class="koboSpan" id="kobo.597.1">: The code snippet provided doesn’t include an implementation </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.598.1">for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">is_authorized_user</span></strong><span class="koboSpan" id="kobo.600.1"> method, which is called in </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">_poll_updates</span></strong><span class="koboSpan" id="kobo.602.1">. </span><span class="koboSpan" id="kobo.602.2">Implementing authorization checks can be crucial to ensure that the bot only responds to messages from </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">authorized users:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.604.1">
    def is_authorized_user(self, update):
        # authorization check based on user ID or username
        return update.effective_user.id == int(self.chat_id)</span></pre></li>				<li><strong class="bold"><span class="koboSpan" id="kobo.605.1">Command handling</span></strong><span class="koboSpan" id="kobo.606.1">: While the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">get_bot</span></strong><span class="koboSpan" id="kobo.608.1"> method mentions setting commands </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.609.1">for the bot, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">set_commands</span></strong><span class="koboSpan" id="kobo.611.1"> method is not shown in the provided snippets. </span><span class="koboSpan" id="kobo.611.2">It’s advisable to implement command handling to provide users with a guide on how to interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">the bot:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.613.1">
    async def set_commands(self, bot):
        await bot.set_my_commands(
            [
                ("start", "Start Auto-GPT"),
                ("stop", "Stop Auto-GPT"),
                ("help", "Show help"),
                ("yes", "Confirm"),
                ("no", "Deny"),
                ("auto", "Let an Agent decide"),
            ]
        )</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.614.1">Of course, we would also have to modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">ask_user</span></strong><span class="koboSpan" id="kobo.616.1"> method to handle the commands, but </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.617.1">this is just a basic example of how to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">command handling:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.619.1">      async def ask_user_async(self, prompt):
        global response_queue
        # only display confirm if the prompt doesn't have the string ""Continue (y/n):"" inside
        if "Continue (y/n):" in prompt or "Waiting for your response..." </span><span class="koboSpan" id="kobo.619.2">in prompt:
            question = (
                (
                prompt
                + " \n Confirm: /yes     Decline: /no \n Or type your answer. </span><span class="koboSpan" id="kobo.619.3">\n or press /auto to let an Agent decide."
</span><span class="koboSpan" id="kobo.619.4">            )
            )
        elif "I want Auto-GPT to:" in prompt:
            question = prompt
        else:
            question = (
                (
                prompt + " \n Type your answer or press /auto to let an Agent decide."
</span><span class="koboSpan" id="kobo.619.5">            )
            )
        response_queue = ""
        # await delete_old_messages()
        print("Asking user: " + question)
        await self._send_message(message=question)
        await self._send_message(message=question)
        print("Waiting for response on Telegram chat...")
        await self._poll_updates()
        if response_queue == "/start":
            response_queue = await self.ask_user(
                self,
                prompt="I am already here... </span><span class="koboSpan" id="kobo.619.6">\n Please use /stop to stop me first.",
            )
        if response_queue == "/help":
            response_queue = await self.ask_user(
                self,
                prompt="You can use /stop to stop me \n and /start to start me again.",
            )
        if response_queue == "/auto":
            return "s"
        if response_queue == "/stop":
            await self._send_message("Stopping Auto-GPT now!")
            await self._send_message("Stopping Auto-GPT now!")
            exit(0)
        elif response_queue == "/yes":
            response_text = "yes"
            response_queue = "yes"
        elif response_queue == "/no":
            response_text = "no"
            response_queue = "no"
        if response_queue.capitalize() in [
            "Yes",
            "Okay",
            "Ok",
            "Sure",
            "Yeah",
            "Yup",
            "Yep",
        ]:
            response_text = "y"
        elif response_queue.capitalize() in ["No", "Nope", 
            "Nah", "N"]:
            response_text = "n"
        else:
            response_text = response_queue
        print("Response received from Telegram: " 
            + response_text)
        return response_text</span></pre></li>				<li><strong class="bold"><span class="koboSpan" id="kobo.620.1">Logging</span></strong><span class="koboSpan" id="kobo.621.1">: Incorporating </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.622.1">a logging framework as opposed to using print statements would provide a more robust and configurable way to log messages and errors. </span><span class="koboSpan" id="kobo.622.2">I first tried using the built-in logging of Auto-GPT but importing code from Auto-GPT into the plugin caused some issues over time, so I decided to use the built-in logging module of </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">Python instead:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.624.1">
import logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.625.1">Here is an example of </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">its usage:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.627.1">logger.info("Information message")
logger.error("Error message")</span></pre></li>				<li><strong class="bold"><span class="koboSpan" id="kobo.628.1">Environment variable management</span></strong><span class="koboSpan" id="kobo.629.1">: The code retrieves the Telegram API key and </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.630.1">chat ID directly. </span><span class="koboSpan" id="kobo.630.2">It’s a good practice to manage such sensitive information using environment variables, ensuring they are </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">not hardcoded:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.632.1">
import os
TELEGRAM_API_KEY = os.getenv("TELEGRAM_API_KEY")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")</span></pre></li>				<li><strong class="bold"><span class="koboSpan" id="kobo.633.1">Code modularity and reusability</span></strong><span class="koboSpan" id="kobo.634.1">: It might be beneficial to further modularize </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.635.1">the code, separating concerns and making it easier to </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.636.1">maintain and extend. </span><span class="koboSpan" id="kobo.636.2">For instance, the Telegram interaction logic could be encapsulated into a separate module or class, making the code more organized </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">and reusable.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.638.1">Unit testing</span></strong><span class="koboSpan" id="kobo.639.1">: Adding </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.640.1">unit tests to verify the functionality of the plugin is crucial for ensuring its reliability and ease of maintenance, especially when changes or updates are made to the </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">code base.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.642.1">Documentation</span></strong><span class="koboSpan" id="kobo.643.1">: Ensuring </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.644.1">that the code is well documented, including comments explaining the functionality of methods and complex code segments, will make it easier for others to understand, use, and potentially contribute to </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">the plugin.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.646.1">By considering these additional points and recommendations, developers can enhance the Telegram </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.647.1">plugin’s functionality, making it more robust, user friendly, and maintainable. </span><span class="koboSpan" id="kobo.647.2">Furthermore, readers and developers following the guide will have a more comprehensive understanding of the considerations involved in building and refining a plugin </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">for Auto-GPT.</span></span></p>
			<p><span class="koboSpan" id="kobo.649.1">The discussion thus far has provided a comprehensive overview of the Telegram plugin for Auto-GPT, covering the core functionality, error handling, asynchronous programming, and some additional considerations for refining the plugin. </span><span class="koboSpan" id="kobo.649.2">As we reach the conclusion of this walk-through, it’s a good time to summarize key takeaways and suggest further steps for readers or developers looking to work with or build upon </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">this plugin.</span></span></p>
			<p><span class="koboSpan" id="kobo.651.1">Here is a summary of the </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">key takeaways:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.653.1">Plugin structure</span></strong><span class="koboSpan" id="kobo.654.1">: The plugin comprises two main files: </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">__init__.py</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.656.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">telegram_chat.py</span></strong></span><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">__init__.py</span></strong><span class="koboSpan" id="kobo.659.1"> is the entry point where Auto-GPT interacts with the plugin, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">telegram_chat.py</span></strong><span class="koboSpan" id="kobo.661.1"> encapsulates the </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">Telegram-specific logic</span></span></p></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.663.1">Initialization and configuration</span></strong><span class="koboSpan" id="kobo.664.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">__init__</span></strong><span class="koboSpan" id="kobo.666.1"> methods in both files are crucial for initializing and configuring the plugin, including setting up the Telegram </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">bot credentials</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.668.1">User interaction</span></strong><span class="koboSpan" id="kobo.669.1">: The plugin allows for user input via Telegram and can send messages back to the user through methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">user_input</span></strong><span class="koboSpan" id="kobo.671.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">report</span></strong><span class="koboSpan" id="kobo.673.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">ask_user</span></strong><span class="koboSpan" id="kobo.675.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">send_message</span></strong></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.678.1">Asynchronous programming</span></strong><span class="koboSpan" id="kobo.679.1">: Asynchronous methods and the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">asyncio</span></strong><span class="koboSpan" id="kobo.681.1"> library enable non-blocking IO operations, improving the plugin’s responsiveness </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">and performance</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.683.1">Error handling</span></strong><span class="koboSpan" id="kobo.684.1">: Exception handling is employed throughout the code to catch and log errors, making the plugin more robust </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">and resilient</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.686.1">Let us now </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.687.1">look at the further steps that can </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">be taken:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.689.1">Explore the GitHub repository</span></strong><span class="koboSpan" id="kobo.690.1">: You are encouraged to explore the GitHub repository (</span><a href="https://github.com/Significant-Gravitas/Auto-GPT-Plugins/tree/master/src/autogpt_plugins/telegram"><span class="koboSpan" id="kobo.691.1">https://github.com/Significant-Gravitas/Auto-GPT-Plugins/tree/master/src/autogpt_plugins/telegram</span></a><span class="koboSpan" id="kobo.692.1">) for the latest version of the plugin and to understand any updates or modifications made to </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">the code.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.694.1">Contribute to the project</span></strong><span class="koboSpan" id="kobo.695.1">: Developers interested in contributing can fork the repository, make their own improvements or additions, and submit pull requests. </span><span class="koboSpan" id="kobo.695.2">This collaborative approach can help enhance the plugin </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">over time.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.697.1">Implement suggested enhancements</span></strong><span class="koboSpan" id="kobo.698.1">: Implementing the suggested enhancements such as authorization checks, command handling, logging, environment variable management, code modularity, unit testing, and documentation could significantly improve the plugin’s functionality </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">and maintainability.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.700.1">Experiment and customize</span></strong><span class="koboSpan" id="kobo.701.1">: Developers are encouraged to experiment with the plugin, customize it to fit their specific needs, and even extend it to incorporate additional features </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">or integrations.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.703.1">Learn and share</span></strong><span class="koboSpan" id="kobo.704.1">: Engaging with the community, learning from others, and sharing knowledge and experiences can be beneficial for </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">everyone involved.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.706.1">This walk-through </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.707.1">aims to provide a thorough understanding of the Telegram plugin for Auto-GPT and offer a foundation for developers and for you all who are looking to delve deeper into plugin development for Auto-GPT. </span><span class="koboSpan" id="kobo.707.2">Through exploration, experimentation, and collaboration, the community can continue to build and improve upon this and other plugins, enhancing the capabilities and applications </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">of Auto-GPT.</span></span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.709.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.710.1">By dissecting the various methods and logic within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">__init__.py</span></strong><span class="koboSpan" id="kobo.712.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">telegram_chat.py</span></strong><span class="koboSpan" id="kobo.714.1"> files, you will gain a thorough understanding of how the Telegram plugin is structured and operates. </span><span class="koboSpan" id="kobo.714.2">This step-by-step breakdown elucidates how Auto-GPT communicates with Telegram, handles user input, and sends messages or reports back to </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">the user.</span></span></p>
			<p><span class="koboSpan" id="kobo.716.1">The complete code for this plugin, along with potential updates or modifications, can be found at </span><a href="https://github.com/Significant-Gravitas/Auto-GPT-Plugins/tree/master/src/autogpt_plugins/telegram"><span class="koboSpan" id="kobo.717.1">https://github.com/Significant-Gravitas/Auto-GPT-Plugins/tree/master/src/autogpt_plugins/telegram</span></a><span class="koboSpan" id="kobo.718.1">. </span><span class="koboSpan" id="kobo.718.2">This repository is an excellent resource for those interested in exploring the plugin further or adapting it to </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">their needs.</span></span></p>
			<p><span class="koboSpan" id="kobo.720.1">In this chapter, we provided a short introduction to plugins in Auto-GPT. </span><span class="koboSpan" id="kobo.720.2">We gave an overview of plugins, the different types of plugins and their use cases, how to use plugins effectively, and the process of building plugins. </span><span class="koboSpan" id="kobo.720.3">By leveraging plugins, you can extend Auto-GPT’s functionality, tailor it to specific tasks or domains, and enhance its performance in </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">various applications.</span></span></p>
			<p><span class="koboSpan" id="kobo.722.1">In the next chapter, we will delve into practical examples and case studies that demonstrate the power of plugins in real-world scenarios. </span><span class="koboSpan" id="kobo.722.2">If you have any specific requests or suggestions for modifications, please let </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">me know!</span></span></p>
		</div>
	</body></html>