- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Is Reinforcement Learning?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The automatic learning of optimal decisions over time is a general and common
    problem that has been studied in many scientific and engineering fields. In our
    changing world, even problems that look like static input-output problems can
    become dynamic if time is taken into account. For example, imagine that you want
    to solve the simple supervised learning problem of pet image classification with
    two target classes—dog and cat. You gather the training dataset and implement
    the classifier using your favorite deep learning toolkit. After the training and
    validation, the model demonstrates excellent performance. Great! You deploy it
    and leave it running for a while. However, after a vacation at some seaside resort,
    you return to discover that dog grooming fashions have changed and a significant
    portion of your queries are now misclassified, so you need to update your training
    images and repeat the process again. Not so great!
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is intended to show that even simple machine learning (ML) problems
    often have a hidden time dimension. This is frequently overlooked and might become
    an issue in a production system. This can be addressed by reinforcement learning
    (RL), a subfield of ML, which is an approach that natively incorporates an extra
    dimension (which is usually time, but not necessarily) into learning equations.
    This places RL much closer to how people understand artificial intelligence (AI).
    In this chapter, we will discuss RL in more detail and you will become familiar
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How RL is related to and differs from other ML disciplines: supervised and
    unsupervised learning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the main RL formalisms are and how they are related to each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Theoretical foundations of RL: Markov processes (MPs), Markov reward processes
    (MRPs), and Markov decision processes (MDPs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supervised learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may be familiar with the notion of supervised learning, which is the most
    studied and well-known ML problem. Its basic question is, how do you automatically
    build a function that maps some input into some output when given a set of example
    pairs? It sounds simple in those terms, but the problem includes many tricky questions
    that computers have only recently started to address with some success. There
    are lots of examples of supervised learning problems, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text classification: Is this email message spam or not?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Image classification and object location: Does this image contain a picture
    of a cat, dog, or something else?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regression problems: Given the information from weather sensors, what will
    be the weather tomorrow?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sentiment analysis: What is the customer satisfaction level of this review?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These questions may look different, but they share the same idea — we have many
    examples of input and desired output, and we want to learn how to generate the
    output for some future, currently unseen input. The name supervised comes from
    the fact that we learn from known answers provided by a “ground truth” data source.
  prefs: []
  type: TYPE_NORMAL
- en: Unsupervised learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the other extreme, we have the so-called unsupervised learning, which assumes
    no supervision and has no known labels assigned to our data. The main objective
    is to learn some hidden structure of the dataset at hand. One common example of
    such an approach to learning is the clustering of data. This happens when our
    algorithm tries to combine data items into a set of clusters, which can reveal
    relationships in data. For instance, you might want to find similar images or
    clients with common behavior patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Another unsupervised learning method that is becoming more and more popular
    is generative adversarial networks (GANs). When we have two competing neural networks
    (NNs), the first network tries to generate fake data to fool the second network,
    while the second network tries to discriminate artificially generated data from
    data sampled from our dataset. Over time, both networks become more and more skillful
    in their tasks by capturing subtle specific patterns in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Reinforcement learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RL is the third camp and lies somewhere in between full supervision and a complete
    lack of predefined labels. On the one hand, it uses many well-established methods
    of supervised learning, such as deep neural networks for function approximation,
    stochastic gradient descent, and backpropagation, to learn data representation.
    On the other hand, it usually applies them in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two sections of the chapter, we will explore specific details of
    the RL approach, including assumptions and abstractions in its strict mathematical
    form. For now, to compare RL with supervised and unsupervised learning, we will
    take a less formal, but more easily understood, path.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have an agent that needs to take actions in some environment.
    Both “agent” and “environment” will be defined in detail later in this chapter.
    A robot mouse in a maze is a good example, but you can also imagine an automatic
    helicopter trying to perform a roll, or a chess program learning how to beat a
    grandmaster. Let’s go with the robot mouse for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](img/B22150_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: The robot mouse maze world'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the environment is a maze with food at some points and electricity
    at others. The robot mouse is the agent that can take actions, such as turn left/right
    and move forward. At each moment, it can observe the full state of the maze to
    make a decision about the actions to take. The robot mouse tries to find as much
    food as possible while avoiding getting an electric shock whenever possible. These
    food and electricity signals stand as the reward that is given to the agent (robot
    mouse) by the environment as additional feedback about the agent’s actions. The
    reward is a very important concept in RL, and we will talk about it later in the
    chapter. For now, it is enough for you to know that the final goal of the agent
    is to maximize its reward as much as possible. In our particular example, the
    robot mouse could suffer a slight electric shock as a short-term setback to get
    to a place with plenty of food in the long term — this would be a better result
    for the robot mouse than just standing still and gaining nothing.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want to hard-code knowledge about the environment and the best actions
    to take in every specific situation into the robot mouse — it will take too much
    effort and may become useless even with a slight maze change. What we want is
    to have some magic set of methods that will allow our robot mouse to learn on
    its own how to avoid electricity and gather as much food as possible. RL is exactly
    this magic toolbox and it behaves differently from supervised and unsupervised
    learning methods; it doesn’t work with predefined labels in the way that supervised
    learning does. Nobody labels all the images that the robot sees as good or bad,
    or gives it the best direction to turn in.
  prefs: []
  type: TYPE_NORMAL
- en: However, we’re not completely blind as in an unsupervised learning setup — we
    have a reward system. The reward can be positive from gathering the food, negative
    from electric shocks, or neutral when nothing special happens. By observing the
    reward and relating it to the actions taken, our agent learns how to perform an
    action better, gather more food, and get fewer electric shocks. Of course, RL
    generality and flexibility comes with a price. RL is considered to be a much more
    challenging area than supervised or unsupervised learning. Let’s quickly discuss
    what makes RL tricky.
  prefs: []
  type: TYPE_NORMAL
- en: Complications in RL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to note is that observations in RL depend on an agent’s behavior
    and, to some extent, it is the result of this behavior. If your agent decides
    to do inefficient things, then the observations will tell you nothing about what
    it has done wrong and what should be done to improve the outcome (the agent will
    just get negative feedback all the time). If the agent is stubborn and keeps making
    mistakes, then the observations will give the false impression that there is no
    way to get a larger reward — life is suffering — which could be totally wrong.
  prefs: []
  type: TYPE_NORMAL
- en: In ML terms, this can be rephrased as having non-IID data. The abbreviation
    iid stands for independent and identically distributed, a requirement for most
    supervised learning methods.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing that complicates our agent’s life is that it needs to not only
    exploit the knowledge it has learned, but actively explore the environment, because
    maybe doing things differently will significantly improve the outcome. The problem
    is that too much exploration may also seriously decrease the reward (not to mention
    the agent can actually forget what it has learned before), so we need to find
    a balance between these two activities somehow. This exploration/exploitation
    dilemma is one of the open fundamental questions in RL. People face this choice
    all the time — should I go to an already known place for dinner or try this fancy
    new restaurant? How frequently should I change jobs? Should I study a new field
    or keep working in my area? There are no universal answers to these questions.
  prefs: []
  type: TYPE_NORMAL
- en: The third complication lies in the fact that reward can be seriously delayed
    after actions. In chess, for example, one single strong move in the middle of
    the game can shift the balance. During learning, we need to discover such causalities,
    which can be tricky to discern during the flow of time and our actions.
  prefs: []
  type: TYPE_NORMAL
- en: However, despite all these obstacles and complications, RL has seen huge improvements
    in recent years and is becoming more and more active as a field of research and
    practical application.
  prefs: []
  type: TYPE_NORMAL
- en: Interested in learning more? Let’s dive into the details and look at RL formalisms
    and play rules.
  prefs: []
  type: TYPE_NORMAL
- en: RL formalisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every scientific and engineering field has its own assumptions and limitations.
    Earlier in this chapter, we discussed supervised learning, in which such assumptions
    are the knowledge of input-output pairs. You have no labels for your data? You
    need to figure out how to obtain labels or try to use some other theory. This
    doesn’t make supervised learning good or bad; it just makes it inapplicable to
    your problem.
  prefs: []
  type: TYPE_NORMAL
- en: There are many historical examples of practical and theoretical breakthroughs
    that have occurred when somebody tried to challenge rules in a creative way. However,
    we also must understand our limitations. It’s important to know and understand
    game rules for various methods, as it can save you tons of time in advance. Of
    course, such formalisms exist for RL, and we will spend the rest of this book
    analyzing them from various angles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows two major RL entities — agent and environment —
    and their communication channels — actions, reward, and observations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AERAOgnecbevwtsniaietrrorodnvnsamteionnts ](img/B22150_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: RL entities and their communication channels'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss them in detail in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Reward
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s return to the notion of reward. In RL, it’s just a scalar value
    we obtain periodically from the environment. As mentioned, reward can be positive
    or negative, large or small, but it’s just a number. The purpose of reward is
    to tell our agent how well it has behaved. We don’t define how frequently the
    agent receives this reward; it can be every second or once in an agent’s lifetime,
    although it’s common practice to receive rewards every fixed timestamp or at every
    environment interaction, just for convenience. In the case of once-in-a-lifetime
    reward systems, all rewards except the last one will be zero.
  prefs: []
  type: TYPE_NORMAL
- en: As I stated, the purpose of reward is to give an agent feedback about its success,
    and it’s a central thing in RL. Basically, the term reinforcement comes from the
    fact that reward obtained by an agent should reinforce its behavior in a positive
    or negative way. Reward is local, meaning that it reflects the benefits and losses
    achieved by the agent so far. Of course, getting a large reward for some action
    doesn’t mean that, a second later, you won’t face dramatic consequences as a result
    of your previous decisions. It’s like robbing a bank — it could look like a good
    idea until you think about the consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'What an agent is trying to achieve is the largest accumulated reward over its
    sequence of actions. To give you a better understanding of reward, here is a list
    of some concrete examples with their rewards:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Financial trading: An amount of profit is a reward for a trader buying and
    selling stocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chess: Reward is obtained at the end of the game as a win, lose, or draw. Of
    course, it’s up to interpretation. For me, for example, achieving a draw in a
    match against a chess grandmaster would be a huge reward. In practice, we need
    to specify the exact reward value, but it could be a fairly complicated expression.
    For instance, in the case of chess, the reward could be proportional to the opponent’s
    strength.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dopamine system in the brain: There is a part of the brain (limbic system)
    that produces dopamine every time it needs to send a positive signal to the rest
    of the brain. High concentrations of dopamine lead to a sense of pleasure, which
    reinforces activities considered by this system to be good. Unfortunately, the
    limbic system is ancient in terms of the things it considers good — food, reproduction,
    and safety — but that is a totally different story!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computer games: They usually give obvious feedback to the player, which is
    either the number of enemies killed or a score gathered. Note in this example
    that reward is already accumulated, so the RL reward for arcade games should be
    the derivative of the score, that is, +1 every time a new enemy is killed, −N
    if the player was killed by the enemy, and 0 at all other time steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Web navigation: There are problems, with high practical value, that require
    the automated extraction of information available on the web. Search engines are
    trying to solve this task in general, but sometimes, to get to the data you’re
    looking for, you need to fill in some forms or navigate through a series of links,
    or complete CAPTCHAs, which can be difficult for search engines to do. There is
    an RL-based approach to those tasks in which the reward is the information or
    the outcome that you need to get.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NN architecture search: RL can be used for NN architecture optimization where
    the quality of models is crucial and people work hard to gain an extra 1% on target
    metrics. In this use case, the aim is to get the best performance metric on some
    dataset by tweaking the number of layers or their parameters, adding extra bypass
    connections, or making other changes to the NN architecture. The reward in this
    case is the performance (accuracy or another measure showing how accurate the
    NN predictions are).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dog training: If you have ever tried to train a dog, you know that you need
    to give it something tasty (but not too much) every time it does the thing you’ve
    asked. It’s also common to reprimand your pet a bit (negative reward) when it
    doesn’t follow your orders, although recent studies have shown that this isn’t
    as effective as a positive reward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'School marks: We all have experience here! School marks are a reward system
    designed to give pupils feedback about their studying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from the preceding examples, the notion of reward is a very general
    indication of the agent’s performance, and it can be found or artificially injected
    into lots of practical problems around us.
  prefs: []
  type: TYPE_NORMAL
- en: The agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An agent is somebody or something who/that interacts with the environment by
    executing certain actions, making observations, and receiving eventual rewards
    for this. In most practical RL scenarios, the agent is our piece of software that
    is supposed to solve some problem in a more-or-less efficient way. For our initial
    set of six examples, the agents will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Financial trading: A trading system or a trader making decisions about order
    execution (buying, selling, or doing nothing).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chess: A player or a computer program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dopamine system: The brain itself, which, according to sensory data, decides
    whether it was a good experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computer games: The player who enjoys the game or the computer program. (Andrej
    Karpathy once tweeted that “we were supposed to make AI do all the work and we
    play games but we do all the work and the AI is playing games!”).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Web navigation: The software that tells the browser which links to click on,
    where to move the mouse, or which text to enter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NN architecture search: The software that controls the concrete architecture
    of the NN being evaluated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dog training: You make decisions about the actions (feeding/reprimand), so,
    the agent is you. But in principle, your dog also could be seen as the agent —
    the dog is trying to maximize the reward (food and/or attention) by behaving properly.
    Strictly speaking, here we have a “multi-agent RL” setup, which is briefly discussed
    in Chapter [22](ch026.xhtml#x1-41100022).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'School: Student/pupil.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The environment is everything outside of an agent. In the most general sense,
    it’s the rest of the universe, but this goes slightly overboard and exceeds the
    capacity of even tomorrow’s computers, so we usually follow the general sense
    here.
  prefs: []
  type: TYPE_NORMAL
- en: The agent’s communication with the environment is limited to reward (obtained
    from the environment), actions (executed by the agent and sent to the environment),
    and observations (some information besides the reward that the agent receives
    from the environment). We have discussed rewards already, so let’s talk about
    actions and observations next. We will identify the environment for each of our
    examples when we discuss the observations.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actions are things that an agent can do in the environment. Actions can, for
    example, be piece moves on the board (if it’s a board game), or doing homework
    (in the case of school). They can be as simple as move pawn one space forward
    or as complicated as build a profitable startup company.
  prefs: []
  type: TYPE_NORMAL
- en: In RL, we distinguish between two types of actions — discrete or continuous.
    Discrete actions form the finite set of mutually exclusive things an agent can
    do, such as move left or right. Continuous actions have some value attached to
    them, such as a car’s turn the wheel action having an angle and direction of steering.
    Different angles could lead to a different scenario a second later, so just turn
    the wheel is definitely not enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Giving concrete examples, let’s look at the actions in our six scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Financial trading: Actions are decisions to buy or sell stock. “Do nothing
    and wait” also is an action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chess: Actions are valid piece moves according to the current board’s position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dopamine system: Actions are the things that you are doing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computer games: Actions are pushing buttons. They could be also continuous,
    such as turning the steering wheel in an auto simulator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Web navigation: Actions could be mouse clicks, scrolling, and text typing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NN architecture search: Actions are changes in NN architecture, which could
    be discrete (count of layers in the network) or continuous (probability in the
    dropout layer).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dog training: Actions are everything you can do with your dog — giving a piece
    of tasty food, petting, even saying “good dog!” in a kind voice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'School: Actions are marks and lots of more informal signals, like praising
    the successes or giving extra homework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Observations of the environment form the second information channel for an agent,
    with the first being the reward. You may be wondering why we need a separate data
    source. The answer is convenience. Observations are pieces of information that
    the environment provides the agent with that indicate what’s going on around the
    agent.
  prefs: []
  type: TYPE_NORMAL
- en: Observations may be relevant to the upcoming reward (such as seeing a bank notification
    about being paid) or may not be. Observations can even include reward information
    in some vague or obfuscated form, such as score numbers on a computer game’s screen.
    Score numbers are just pixels, but potentially, we could convert them into reward
    values; it’s not a very complex task for a modern computer vision techniques.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, reward shouldn’t be seen as a secondary or unimportant thing
    — reward is the main force that drives the agent’s learning process. If a reward
    is wrong, noisy, or just slightly off course from the primary objective, then
    there is a chance that training will go in the wrong direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also important to distinguish between an environment’s state and observations.
    The state of an environment most of the time is internal to the environment and
    potentially includes every atom in the universe, which makes it impossible to
    measure everything about the environment. Even if we limit the environment’s state
    to be small enough, most of the time, it will be either not possible to get full
    information about it or our measurements will contain noise. This is completely
    fine, though, and RL was created to support such cases natively. To illustrate
    the difference, let’s return to our set of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Financial trading: Here, the environment is the whole financial market and
    everything that influences it. This is a huge list of things, such as the latest
    news, economic and political conditions, weather, food supplies, and Twitter/X
    trends. Even your decision to stay home today can potentially indirectly influence
    the world’s financial system (if you believe in the “butterfly effect”). However,
    our observations are limited to stock prices, news, and so on. We don’t have access
    to most of the environment’s state, which makes financial forecasting such a nontrivial
    thing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chess: The environment here is your board plus your opponent, which includes
    their chess skills, mood, brain state, chosen tactics, and so on. Observations
    are what you see (your current chess position), but, at some levels of play, knowledge
    of psychology and the ability to read an opponent’s mood could increase your chances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dopamine system: The environment here is your brain plus your nervous system
    and your organs’ states plus the whole world you can perceive. Observations are
    the inner brain state and signals coming from your senses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computer game: Here, the environment is your computer’s state, including all
    memory and disk data. For networked games, you need to include other computers
    plus all Internet infrastructure between them and your machine. Observations are
    a screen’s pixels and sound only. These pixels are not a tiny amount of information
    (it has been estimated that the total number of possible moderate-size images
    (1024×768) is significantly larger than the number of atoms in our galaxy), but
    the whole environment state is definitely larger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Web navigation: The environment here is the Internet, including all the network
    infrastructure between the computer on which our agent works and the web server,
    which is a really huge system that includes millions and millions of different
    components. The observation is normally the web page that is loaded in the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NN architecture search: In this example, the environment is fairly simple and
    includes the NN toolkit that performs the particular NN evaluation and the dataset
    that is used to obtain the performance metric. In comparison to the Internet,
    this looks like a tiny toy environment. Observations might be different and include
    some information about testing, such as loss convergence dynamics or other metrics
    obtained from the evaluation step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dog training: Here, the environment is your dog (including its hardly observable
    inner reactions, mood, and life experiences) and everything around it, including
    other dogs and even a cat hiding in a bush. Observations are signals from your
    senses and memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'School: The environment here is the school itself, the education system of
    the country, society, and the cultural legacy. Observations are the same as for
    the dog training example — the student’s senses and memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is our “mise en scène” and we will play around with it in the rest of this
    book. You will have already noticed that the RL model is extremely flexible and
    general, and it can be applied to a variety of scenarios. Let’s now look at how
    RL is related to other disciplines, before diving into the details of the RL model.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other areas that contribute or relate to RL. The most significant
    are shown in the following diagram, which includes six large domains heavily overlapping
    each other on the methods and specific topics related to decision-making (shown
    inside the inner circle).
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Various domains in RL'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the intersection of all those related, but still different, scientific areas
    sits RL, which is so general and flexible that it can take the best available
    information from these varying domains:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ML: RL, being a subfield of ML, borrows lots of its machinery, tricks, and
    techniques from ML. Basically, the goal of RL is to learn how an agent should
    behave when it is given imperfect observational data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Engineering (especially optimal control): This helps with taking a sequence
    of optimal actions to get the best result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Neuroscience: We used the dopamine system as our example, and it has been shown
    that the human brain acts similarly to the RL model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Psychology: This studies behavior in various conditions, such as how people
    react and adapt, which is close to the RL topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Economics: One of the important topics in economics is how to maximize reward
    in terms of imperfect knowledge and the changing conditions of the real world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mathematics: This works with idealized systems and also devotes significant
    attention to finding and reaching the optimal conditions in the field of operations
    research.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next part of the chapter, you will become familiar with the theoretical
    foundations of RL, which will make it possible to start moving toward the methods
    used to solve the RL problem. The upcoming section is important for understanding
    the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: The theoretical foundations of RL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I will introduce you to the mathematical representation and
    notation of the formalisms (reward, agent, actions, observations, and environment)
    that we just discussed. Then, using this as a knowledge base, we will explore
    the second-order notions of the RL language, including state, episode, history,
    value, and gain, which will be used repeatedly to describe different methods later
    in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Markov decision processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before that, we will cover Markov decision processes (MDPs), which will bedescribed
    like a Russian matryoshka doll: we will start from the simplest case of a Markov
    process (MP), then extend that with rewards, which will turn it into a Markov
    reward process (MRP). Then, we will put this idea into an extra envelope by adding
    actions, which will lead us to an MDP.'
  prefs: []
  type: TYPE_NORMAL
- en: MPs and MDPs are widely used in computer science and other engineering fields.
    So, reading this chapter will be useful for you not only for RL contexts but also
    for a much wider range of topics. If you’re already familiar with MDPs, then you
    can quickly skim this chapter, paying attention only to the terminology definitions,
    as we will use them later on.
  prefs: []
  type: TYPE_NORMAL
- en: The Markov process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with the simplest concept in the Markov family: the MP, which is
    also known as the Markov chain. Imagine that you have some system in front of
    you that you can only observe. What you observe is called states, and the system
    can switch between states according to some laws of dynamics (most of the time
    unknown to you). Again, you cannot influence the system, but can only watch the
    states changing. All possible states for a system form a set called the state
    space. For MPs, we require this set of states to be finite (but it can be extremely
    large to compensate for this limitation). Your observations form a sequence of
    states or a chain (that’s why MPs are also called Markov chains).'
  prefs: []
  type: TYPE_NORMAL
- en: For example, looking at the simplest model of the weather in some city, we can
    observe the current day as sunny or rainy, which is our state space. A sequence
    of observations over time forms a chain of states, such as [sunny, sunny, rainy,
    sunny, ...], and this is called history. To call such a system an MP, it needs
    to fulfill the Markov property, which means that the future system dynamics from
    any state have to depend on this state only. The main point of the Markov property
    is to make every observable state self-contained to describe the future of the
    system. In other words, the Markov property requires the states of the system
    to be distinguishable from each other and unique. In this case, only one state
    is required to model the future dynamics of the system and not the whole history
    or, say, the last N states.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of our toy weather example, the Markov property limits our model
    to represent only the cases when a sunny day can be followed by a rainy one with
    the same probability, regardless of the number of sunny days we’ve seen in the
    past. It’s not a very realistic model as, from common sense, we know that the
    chance of rain tomorrow depends not only on the current conditions but on a large
    number of other factors, such as the season, our latitude, and the presence of
    mountains and sea nearby. It was recently proven that even solar activity has
    a major influence on the weather. So, our example is really naïve, but it’s important
    to understand the limitations and make conscious decisions about them.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if we want to make our model more complex, we can always do this
    by extending our state space, which will allow us to capture more dependencies
    in the model at the cost of a larger state space. For example, if you want to
    capture separately the probability of rainy days during summer and winter, then
    you can include the season in your state.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, your state space will be [sunny+summer, sunny+winter, rainy+summer,
    rainy+winter] and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As your system model complies with the Markov property, you can capture transition
    probabilities with a transition matrix, which is a square matrix of the size N
    ×N, where N is the number of states in our model. Every cell in a row, i, and
    a column, j, in the matrix contains the probability of the system to transition
    from state i to state j.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in our sunny/rainy example, the transition matrix could be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Sunny | Rainy |'
  prefs: []
  type: TYPE_TB
- en: '| Sunny | 0.8 | 0.2 |'
  prefs: []
  type: TYPE_TB
- en: '| Rainy | 0.1 | 0.9 |'
  prefs: []
  type: TYPE_TB
- en: In this case, if we have a sunny day, then there is an 80% chance that the next
    day will be sunny and a 20% chance that the next day will be rainy. If we observe
    a rainy day, then there is a 10% probability that the weather will become better
    and a 90% probability of the next day being rainy.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, that’s it. The formal definition of an MP is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A set of states (S) that a system can be in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transition matrix (T), with transition probabilities, which defines the system
    dynamics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A useful visual representation of an MP is a graph with nodes corresponding
    to system states and edges, labeled with probabilities representing a possible
    transition from state to state. If the probability of a transition is 0, we don’t
    draw an edge (there is no way to go from one state to another). This kind of representation
    is also widely used in finite state machine representation, which is studied in
    automata theory. For our sunny/rainy weather model, the graph is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SRppppuani====nnyy0000....2189 ](img/B22150_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: The sunny/rainy weather model'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we’re talking about observation only. There is no way for us to influence
    the weather, so we just observe it and record our observations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you a more complicated example, let’s consider another model called
    Office Worker (Dilbert, the main character in Scott Adams’ famous cartoons, is
    a good example). His state space in our example has the following states:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Home: He’s not at the office'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computer: He’s working on his computer at the office'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coffee: He’s drinking coffee at the office'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chat: He’s discussing something with colleagues at the office'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The state transition graph is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CCCHhoooaffmmtepeeuter ](img/B22150_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: The state transition graph for our office worker'
  prefs: []
  type: TYPE_NORMAL
- en: We assume that our office worker’s weekday usually starts from the Home state
    and that he starts his day with Coffee without exception (no Home →Computer edge
    and no Home →Chat edge). The preceding diagram also shows that workdays always
    end (that is, going to the Home state) from the Computer state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transition matrix for the diagram above is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Home | Coffee | Chat | Computer |'
  prefs: []
  type: TYPE_TB
- en: '| Home | 60% | 40% | 0% | 0% |'
  prefs: []
  type: TYPE_TB
- en: '| Coffee | 0% | 10% | 70% | 20% |'
  prefs: []
  type: TYPE_TB
- en: '| Chat | 0% | 20% | 50% | 30% |'
  prefs: []
  type: TYPE_TB
- en: '| Computer | 20% | 20% | 10% | 50% |'
  prefs: []
  type: TYPE_TB
- en: The transition probabilities could be placed directly on the state transition
    graph, as shown in Figure [1.6](#x1-32011r6).
  prefs: []
  type: TYPE_NORMAL
- en: '![CCCHpppppppppppphooo = = = = = = = = = = = =affmmtepeeu000000000000t.5.3.1.1.2.7.5.2.2.6.2.4er
    ](img/B22150_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: The state transition graph with transition probabilities'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, we rarely have the luxury of knowing the exact transition matrix.
    A much more real-world situation is when we only have observations of our system’s
    states, which are also called episodes:'
  prefs: []
  type: TYPE_NORMAL
- en: Home → Coffee → Coffee → Chat → Chat → Coffee → Computer →Computer →Home
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computer → Computer → Chat → Chat → Coffee → Computer →Computer →Computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home → Home → Coffee → Chat → Computer → Coffee → Coffee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not complicated to estimate the transition matrix from our observations
    — we just count all the transitions from every state and normalize them to a sum
    of 1\. The more observation data we have, the closer our estimation will be to
    the true underlying model.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth noting that the Markov property implies stationarity (which
    means, the underlying transition distribution for any state does not change over
    time). Non-stationarity means that there is some hidden factor that influences
    our system dynamics, and this factor is not included in observations. However,
    this contradicts the Markov property, which requires the underlying probability
    distribution to be the same for the same state regardless of the transition history.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand the difference between the actual transitions observed
    in an episode and the underlying distribution given in the transition matrix.
    Concrete episodes that we observe are randomly sampled from the distribution of
    the model, so they can differ from episode to episode. However, the probability
    of the concrete transition to be sampled remains the same. If this is not the
    case, Markov chain formalism becomes non-applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can go further and extend the MP model to make it closer to our RL problems.
    Let’s add rewards to the picture!
  prefs: []
  type: TYPE_NORMAL
- en: Markov reward processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To introduce reward, we need to extend our MP model a bit. First, we need to
    add value to our transition from state to state. We already have probability,
    but probability is being used to capture the dynamics of the system, so now we
    have an extra scalar number without extra burden.
  prefs: []
  type: TYPE_NORMAL
- en: Rewards can be represented in various forms. The most general way is to have
    another square matrix, similar to the transition matrix, with a reward given for
    transitioning from state i to state j, which reside in row i and column j.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, rewards can be positive or negative, large or small. In some cases,
    this representation is redundant and can be simplified. For example, if a reward
    is given for reaching the state regardless of the origin state, we can keep only
    (state, reward) pairs, which is a more compact representation. However, this is
    applicable only if the reward value depends solely on the target state, which
    is not always the case.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing we’re adding to the model is the discount factor γ (Greek letter
    “gamma”), which is a single number from 0 to 1 (inclusive). The meaning of this
    will be explained after the extra characteristics of our MRP have been defined.
  prefs: []
  type: TYPE_NORMAL
- en: As you will remember, we observe a chain of state transitions in an MP. This
    is still the case for a MRP, but for every transition, we have our extra quantity
    — reward. So now, all our observations have a reward value attached to every transition
    of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every episode, we define return at the time t as G[t]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∞∑ Gt = Rt+1 + γRt+2 + ⋅⋅⋅ = γkRt+k+1 k=0 ](img/equation1.png)'
  prefs: []
  type: TYPE_IMG
- en: The γ in the preceding formula is very important in RL, and we will meet it
    a lot in the subsequent chapters. For now, think about it as a measure of how
    far into the future we look to estimate the future return. The closer its value
    is to 1, the more steps ahead of us we will take into account.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s try to understand what the formula for return means. For every time
    point, we calculate return as a sum of subsequent rewards, but more distant rewards
    are multiplied by the discount factor raised to the power of the number of steps
    we are away from the starting point at t. The discount factor stands for the foresightedness
    of the agent. If γ = 1, then return, G[t], just equals a sum of all subsequent
    rewards and corresponds to the agent that has perfect visibility of any subsequent
    rewards. If γ = 0, G[t] will be just immediate reward without any subsequent state
    and will correspond to absolute short-sightedness.
  prefs: []
  type: TYPE_NORMAL
- en: These extreme values are useful only in corner cases, and most of the time,
    γ is set to something in between, such as 0.9 or 0.99\. In this case, we will
    look into future rewards, but not too far. The value of γ = 1 might be applicable
    in situations of short finite episodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This return quantity is not very useful in practice, as it was defined for
    every specific chain we observed from our MRP, so it can vary widely, even for
    the same state. However, if we go to the extreme and calculate the mathematical
    expectation of return for any state (by averaging a large number of chains), we
    will get a much more practical quantity, which is called the value of the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∞∑ Gt = Rt+1 + γRt+2 + ⋅⋅⋅ = γkRt+k+1 k=0 ](img/eq2.png)'
  prefs: []
  type: TYPE_IMG
- en: This interpretation is simple—for every state, s, the value, V (s), is the average
    (or expected) return we get by following the Markov reward process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To represent this theoretical knowledge practically, let’s extend our office
    worker (Dilbert) process with a reward and turn it into a Dilbert reward process
    (DRP). Our reward values will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Home →Home: 1 (as it’s good to be home)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Home →Coffee: 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computer →Computer: 5 (working hard is a good thing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computer →Chat: −3 (it’s not good to be distracted)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chat →Computer: 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computer →Coffee: 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coffee →Computer: 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coffee →Cofee: 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coffee →Chat: 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chat →Coffee: 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chat →Chat: -1 (long conversations become boring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A diagram of this is shown in Figure [1.7](#x1-33005r7).
  prefs: []
  type: TYPE_NORMAL
- en: '![pppppppppppp = = = = = = = = = = = = 000000000000.5.3.1.1.2.7.5.2.2.6.2.4
    CCCHrrhooo =r =rrrrrrrrraffmm = = = = = = = = = =tepeeu−2−112531121t 1 3er ](img/B22150_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: The state transition graph with transition probabilities and rewards'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to our γ parameter and think about the values of states with different
    values of γ. We will start with a simple case: γ = 0\. How do you calculate the
    values of states here? To answer this question, let’s fix our state to Chat. What
    could the subsequent transition be? The answer is that it depends on chance. According
    to our transition matrix for the Dilbert process, there is a 50% probability that
    the next state will be Chat again, 20% that it will be Coffee, and 30% that it
    will be Computer. When γ = 0, our return is equal only to a value of the next
    immediate state. So, if we want to calculate the value of the Chat state in the
    preceding diagram, then we need to sum all transition values and multiply that
    by their probabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| V (chat) | = | − 1 ⋅ 0.5 + 2 ⋅ 0.3 + 1 ⋅ 0.2 = 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| V (coffee) | = | 2 ⋅ 0.7 + 1 ⋅ 0.1 + 3 ⋅ 0.2 = 2.1 |'
  prefs: []
  type: TYPE_TB
- en: '| V (home) | = | 1 ⋅ 0.6 + 1 ⋅ 0.4 = 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| V (computer) | = | 5 ⋅ 0.5 + (−3) ⋅ 0.1 + 1 ⋅ 0.2 + 2 ⋅ 0.2 = 2.8 |'
  prefs: []
  type: TYPE_TB
- en: So, Computer is the most valuable state to be in (if we care only about immediate
    reward), which is not surprising as Computer →Computer is frequent, has a large
    reward, and the ratio of interruptions is not too high.
  prefs: []
  type: TYPE_NORMAL
- en: Now a trickier question — what’s the value when γ = 1? Think about this carefully.
    The answer is that the value is infinite for all states. Our diagram doesn’t contain
    sink states (states without outgoing transitions), and when our discount equals
    1, we care about a potentially infinite number of transitions in the future. As
    you’ve seen in the case of γ = 0, all our values are positive in the short term,
    so the sum of the infinite number of positive values will give us an infinite
    value, regardless of the starting state.
  prefs: []
  type: TYPE_NORMAL
- en: This infinite result shows us one of the reasons to introduce γ into a MRP instead
    of just summing all future rewards. In most cases, the process can have an infinite
    (or large) amount of transitions. As it is not very practical to deal with infinite
    values, we would like to limit the horizon we calculate values for. Gamma with
    a value less than 1 provides such a limitation, and we will discuss this later
    in this book. On the other hand, if you’re dealing with finite-horizon environments
    (for example, the tic-tac-toe game, which is limited by at most nine steps), then
    it will be fine to use γ = 1.
  prefs: []
  type: TYPE_NORMAL
- en: As another example, there is an important class of environments with only one
    step called the multi-armed bandit MDP. This means that on every step, you need
    to make a selection of one alternative action, which provides you with some reward
    and the episode ends.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about bandit methods in the book Bandit Algorithms by Tor
    Lattimore and Csaba Szepesvari ( [https://tor-lattimore.com/downloads/book/book.pdf](https://tor-lattimore.com/downloads/book/book.pdf)).
  prefs: []
  type: TYPE_NORMAL
- en: As I already mentioned about the MRP, γ is usually set to a value between 0
    and 1\. However, with such values, it becomes almost impossible to calculate them
    accurately by hand, even for MRPs as small as our Dilbert example, because it
    will require summing hundreds of values. Computers are good at tedious tasks such
    as this, and there are several simple methods that can quickly calculate values
    for MRPs for given transition and reward matrices. We will see and even implement
    one such method in Chapter [5](ch009.xhtml#x1-820005), when we will start looking
    at Q-learning methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s put another layer of complexity around our Markov reward processes
    and introduce the final missing piece: actions.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding actions to MDP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may already have ideas about how to extend our MDP to include actions. Firstly,
    we must add a set of actions (A), which has to be finite. This is our agent’s
    action space. Secondly, we need to condition our transition matrix with actions,
    which basically means that our matrix needs an extra action dimension, which turns
    it into a cuboid of shape |S|×|S|×|A|, where S is an our state space and A is
    an action space.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, in the case of MPs and MRPs, the transition matrix had a square
    form, with the source state in rows and target state in columns. So, every row,
    i, contained a list of probabilities to jump to every state, as shown in Figure [1.8](#x1-34002r8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Probability for i → j pSTioa,jurrgceettrststaaanttseeitiijon ](img/B22150_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: The transition matrix for the Markov process'
  prefs: []
  type: TYPE_NORMAL
- en: 'In case of an MDP, the agent no longer passively observes state transitions,
    but can actively choose an action to take at every state transition. So, for every
    source state, we don’t have a list of numbers, but we have a matrix, where the
    depth dimension contains actions that the agent can take, and the other dimension
    is what the target state system will jump to after actions are performed by the
    agent. The following diagram shows our new transition table, which became a cuboid
    with the source state as the height dimension (indexed by i), the target state
    as the width (j), and the action the agent can take as the depth (k) of the transition
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Probability for i → j STAoacurtrgigceoietnveststknaa attceetiijon k ](img/B22150_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: The transition probabilities for the MDP'
  prefs: []
  type: TYPE_NORMAL
- en: So, in general, by choosing an action, the agent can affect the probabilities
    of the target states, which is a useful ability.
  prefs: []
  type: TYPE_NORMAL
- en: To give you an idea of why we need so many complications, let’s imagine a small
    robot that lives in a 3 × 3 grid and can execute the actions turn left, turn right,
    and go forward. The state of the world is the robot’s position plus orientation
    (up, down, left, and right), which gives us 3 × 3 × 4 = 36 states (the robot can
    be at any location in any orientation).
  prefs: []
  type: TYPE_NORMAL
- en: Also, imagine that the robot has imperfect motors (which is frequently the case
    in the real world), and when it executes turn left or turn right, there is a 90%
    chance that the desired turn happens, but sometimes, with a 10% probability, the
    wheel slips and the robot’s position stays the same. The same happens with go
    forward — in 90% of cases it works, but for the rest (10%) the robot stays at
    the same position.
  prefs: []
  type: TYPE_NORMAL
- en: In Figure [1.10](#x1-34006r10), a small part of a transition diagram is shown,
    displaying the possible transitions from the state (1, 1), up, when the robot
    is in the center of the grid and facing up. If the robot tries to move forward,
    there is a 90% chance that it will end up in the state (0, 1), up, but there is
    a 10% probability that the wheels will slip and the target position will remain
    (1, 1), up.
  prefs: []
  type: TYPE_NORMAL
- en: '![Robot at cell (1,1) 012012 facing up ](img/B22150_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: A grid world environment'
  prefs: []
  type: TYPE_NORMAL
- en: To properly capture all these details about the environment and possible reactions
    to the agent’s actions, the general MDP has a 3D transition matrix with the dimensions
    source state, action, and target state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to turn our MRP into an MDP, we need to add actions to our reward
    matrix in the same way that we did with the transition matrix. Our reward matrix
    will depend not only on the state but also on the action. In other words, the
    reward the agent obtains will now depend not only on the state it ends up in but
    also on the action that leads to this state. Now, with a formally defined MDP,
    we’re finally ready to cover the most important thing for MDPs and RL: policy.'
  prefs: []
  type: TYPE_NORMAL
- en: Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simple definition of policy is that it is some set of rules that defines
    the agent’s behavior. Even for fairly simple environments, we can have a variety
    of policies. For example, in the preceding example with the robot in the grid
    world, the agent can have different policies, which will lead to different sets
    of visited states. For example, the robot can perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Blindly move forward regardless of anything
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to go around obstacles by checking whether that previous forward action
    failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Funnily spin around by always turning right to entertain its creator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose an action randomly regardless of position and orientation, modeling a
    drunk robot in the grid world scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may remember that the main objective of the agent in RL is to gather as
    much return as possible. So, again, different policies can give us different amounts
    of return, which makes it important to find a good policy. This is why the notion
    of policy is important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Formally, policy is defined as the probability distribution over actions for
    every possible state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![π (a |s) = P[At = a|St = s] ](img/eq3.png)'
  prefs: []
  type: TYPE_IMG
- en: This is defined as probability and not as a concrete action to introduce randomness
    into an agent’s behavior. In section 3 of the book, we will talk about why this
    is important and useful. Deterministic policy is a special case of probabilistics
    with the needed action having 1 as its probability.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful notion is that if our policy is fixed and not changing during
    training (i.e., when the policy always returns the same actions for the same states),
    then our MDP becomes a MRP, as we can reduce the transition and reward matrices
    with a policy’s probabilities and get rid of the action dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on getting to this stage! This chapter was challenging, but
    it was important for understanding subsequent practical material. After two more
    introductory chapters about OpenAI Gym and deep learning, we will finally start
    tackling this question — how do we teach agents to solve practical tasks?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you started your journey into the RL world by learning what
    makes RL special and how it relates to the supervised and unsupervised learning
    paradigms. We then learned about the basic RL formalisms and how they interact
    with each other, after which we covered MPs, MRPs, and MDPs. This knowledge will
    be the foundation for the material that we will cover in the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move away from the formal theory to the practice
    of RL. We will cover the setup required and libraries, and then you will write
    your first agent.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Deep Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/rl](https://packt.link/rl)
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
