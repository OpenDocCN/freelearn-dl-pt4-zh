<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introduction to the Markov Process</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will develop the basic concepts that we need to understand <strong>Hidden Markov Models</strong> (<strong>HMM</strong>). We will cover the following topics:</p>
<ul>
<li>Random processes</li>
<li>Markov processes</li>
<li>Markov chains or discrete-time Markov processes</li>
<li>Continuous-time Markov chains</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Random variables</h1>
                </header>
            
            <article>
                
<p>As we always do in statistics, let's start with a simple example of rolling a dice. If we consider rolling a fair dice, the outcome of the dice can be anything from 1 to 6, and is random. To represent such situations (the outcome of rolling the dice in this case), in mathematics we use the concept of random variables. We come across a lot of such variables in our everyday lives. Another example could be ordering food at a restaurant. In this case, the outcome could be any food item on the menu. In general terms, a random variable is a variable whose possible values are outcomes of a random phenomenon. The possible states of the outcomes are also known as the <strong>domain of the random variable</strong>, and the outcome is based on the probability distribution defined over the domain of the random variable.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Coming back to <span>rolling </span><span>the dice, the domain of the random variable outcome</span><em>, O, </em><span>is given by</span> <em>domain(O) = (1, 2, 3, 4, 5, 6),</em> <span>and the probability distribution is given by a uniform distribution</span> <em>P(o) = 1/6 ∀ ∈ domain(O)</em><span>. Similarly, in the case of the restaurant example, for the random variable</span> <em>choosing a dish</em><span>, the domain would be every item on the menu, and the probability distribution would depend on your food preference. In both of the previous examples, the domain of the random variable has discrete variables; such random variables are known as</span> <strong>discrete random variables</strong><span>. But it's also possible for the domain to be a continuous space. For example, consider the random variable representing the stock price of Google</span><em> </em><span>tomorrow. The domain of this random variable will be all positive real numbers with most of the probability mass distributed around ±5% of today's price. Such random variables are known as</span> <strong>continuous random variables</strong><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Random processes</h1>
                </header>
            
            <article>
                
<p>In the previous section, we discussed random variables that are able to mathematically represent the outcomes of a single random phenomenon. But what if we want to represent these random events over some period of time or the length of an experiment? For example, let's say we want to represent the stock prices for a whole day at intervals of every one hour, or we want to represent the height of a ball at intervals of every one second after being dropped from some height in a vacuum. For such situations, we would need a set of random variables, each of which will represent the outcome at the given instance of time. These sets of random variables that represent random variables over a period of time are also known as <strong>random processes</strong>.<strong> </strong><span>It is worth noting that the domains of all these random variables are the same. Therefore, we can also think of the process as just changing the states.</span></p>
<div class="packt_infobox packt_tip">Here, we have been talking about random variables at different instances of time, but it doesn't need to be time-based in every case. It could be just some other event. But since, in most cases, it is usually time, and it is much easier to talk about random processes in terms of time, we will use time to represent any such event. The same concepts will apply to creating a model if it varies over some other event instead of time.</div>
<p>Now let's discuss the previous two examples in more detail. Starting with the example of dropping the ball from a height in a vacuum, if we know the exact value of gravity and the height from which the ball is being dropped, we will be able to determine the exact location of the ball at every interval of one second using Newton's laws of motion.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Such random processes, in which we can deterministically find the state of each random variable given the initial conditions (in this case, dropping the ball, zero initial velocity) and the parameters of the system (in this case, the value of gravity), are known as <strong>deterministic random processes</strong> (commonly called <strong>deterministic processes</strong>).</p>
<p>Now let's go to the second example; representing the stock price over time. In this case, even if we know the current price and the exact probability distribution of the price at the next one hour mark, we won't be able to deterministically compute the value. These random processes, in which we can't determine the state of a process, even if we are given the initial conditions and all the parameters of the system, are known as <strong>stochastic random processes</strong> (commonly called <strong>processes</strong>). A very good way of understanding or getting a feel for a stochastic process is to think of it as being the opposite of a deterministic process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Markov processes</h1>
                </header>
            
            <article>
                
<p>A stochastic process is called a <strong>Markov process </strong>if the state of the random variable at the next instance of time depends only on the outcome of the random variable at the current time. In simplistic mathematical terms, for a stochastic process, <em>S = {R1, R<sub>2</sub>, . . ., R<sub>n</sub>} = {R}<sub>t=1, . . ., n</sub></em>, to be a Markov process, it must satisfy the following condition:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/57bcdc2f-a875-446c-82c5-fa07de0db4d9.png" style="width:21.33em;height:1.42em;"/></div>
<p>According to the previous condition, the probability distribution for any variable at any given instance in a Markov process is a conditional distribution, which is conditioned only on the random variable at the last time instance. This property of a system, such that the future states of the system depend only on the current state of the system, is also known as the <strong>Markov property</strong>. Systems satisfying the Markov property are also known as <strong>memoryless systems</strong> since they don't need to remember the previous states to compute the distribution of the next state, or, in other words, the next state depends only on the current state of the system.</p>
<p>A very common example used to explain the Markov process is a drunk man walking along a street. We consider that, since the man is drunk, he can either take a step backward, a step forward, or stay in his current position, which is given by some distribution of these, let's say <em>[0.4, 0.4, 0.2]</em>. Now, given the position of the man at any given instance in time, his position at the next instance depends only on his current position and the parameters of the system (his step size and the probability distribution of possible actions). Therefore, this is an example of a Markov process.</p>
<p>In the previous example, let's assume that the drunk man takes an action (steps forward/backward or stays in his position) at fixed intervals of time and his step size is always the same. With these considerations, the Markov process in our example has a discrete state space. Also, since the man takes steps after fixed intervals of time, we can think of it as a discrete time. But Markov processes don't need to have discrete state space or discrete time intervals. Considering discrete and continuous time as well as discrete and continuous state space, we can categorize Markov processes into four main categories:</p>
<ul>
<li>Discrete time and discrete state space</li>
<li>Discrete time and continuous state space</li>
<li>Continuous time and discrete state space</li>
<li>Continuous time and continuous state space</li>
</ul>
<p>We will discuss each of these categories of Markov process in more detail in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Python and packages</h1>
                </header>
            
            <article>
                
<p>Before moving ahead, we need to set up Python and all the packages required to run the code examples. For all the code examples in this book, we will be using Python 3.4. All the example code in the book is also available on GitHub at <a href="https://github.com/PacktPublishing/HandsOnMarkovModelswithPython" target="_blank">https://github.com/PacktPublishing/HandsOnMarkovModelswithPython</a>. We highly recommend using Miniconda to set up your environment for running the examples. Miniconda can be downloaded from <a href="https://conda.io/miniconda.html" target="_blank">https://conda.io/miniconda.html</a>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation on Windows</h1>
                </header>
            
            <article>
                
<p>Miniconda can be installed on a Windows system by just double-clicking on the downloaded <kbd>.exe</kbd> file and following the installation instructions. After installation, we will need to create a <kbd>conda</kbd> environment and install all the required packages in the environment. To create a new Python 3.4 environment with the name <kbd>hmm</kbd>, run the following command:</p>
<pre><strong>conda create -n hmm python=3.4</strong></pre>
<p>After creating the environment, we will need to activate it and install the required packages in it. This can be done using the following commands:</p>
<pre><strong>activate hmm</strong><br/><strong>conda install numpy scipy</strong></pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation on Linux</h1>
                </header>
            
            <article>
                
<p>On Linux, after downloading the <kbd>Miniconda</kbd> file, we will need to give it execution permissions and then install it. This can be done using the following commands:</p>
<pre><strong>chmod +x Miniconda.sh</strong><br/><strong>./Miniconda.sh</strong></pre>
<p>After executing the file, we can simply follow the installation instructions. Once installed, we will need to create a new environment and install the required packages. We can create a new Python 3.4 environment with the name <kbd>hmm</kbd> using the following commands:</p>
<pre><strong>conda create -n hmm python=3.4</strong></pre>
<p>Once the environment has been created, we will need to activate it and install the packages inside it using the following:</p>
<pre><strong>source activate hmm</strong><br/><strong>conda install numpy scipy</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Markov chains or discrete-time Markov processes</h1>
                </header>
            
            <article>
                
<p>A Markov chain is a type of Markov process in which the time is discrete. However, there is a lot of disagreement among researchers on what categories of Markov process should be called <strong>Markov chain</strong>. But, most commonly, it is used to refer to discrete-state-space Markov processes. Therefore, a Markov chain is a stochastic process over a discrete state space satisfying the Markov property. More formally, we can say that a discrete-time Markov chain is a sequence of random variables <em>X<sub>1</sub></em>, <em>X<sub>2</sub></em>, <em>X<sub>3</sub></em>, ... that satisfy the Markov property, namely that the probability of moving from the current state to the next state depends only on the present state and not on any of the previous states. In terms of the probability distribution, we can say that, given that the system is at time instance <em>n</em>, the conditional distribution of the states at the next time instance, <em>n + 1</em>, is conditionally independent of the state of the system at time instances <em>{1, 2, . . ., n-1}</em>, given the state of the random variable at time instance <em>n</em>. This can be written as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/834a5c22-1466-4e66-bf09-24972d32a079.png" style="width:39.83em;height:1.42em;"/></div>
<p>Markov chains are often represented using directed graphs. The nodes in the directed graphs represent the different possible states of the random variables, and the edges represent the probability of the system going from one state to the other in the next time instance. Let's take a simple example of predicting the weather to understand this representation better. We will consider that there are three possible states of the random variable <em>Weather={Sunny, Rainy, Snowy}</em>, and possible Markov chains for this can be represented as shown in <em>Figure 1.1</em>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/346d701d-7454-4060-9e93-059c68a637f2.png" style="width:31.25em;height:19.67em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1.1: A simple Markov chain on the random variable, representing the random variable Weather={Sunny, Rainy, Snowy}<em> </em>and showing the probability of the random variable switching to other states in the next time instance</div>
<p>One of the main points to understand in Markov chains is that we are modeling the outcomes of a sequence of random variables over time. This is sometimes confusing for people since the model is represented using a single graph, which doesn't mention anything about time. So, the name state transitions is not a particularly good name for this, since the state is not changing for any random variable; rather, we are trying to determine the state of the next random variable given the observed state of our current random variable. Coming back to our example, we can see that the nodes of the graph represent the different possible states of the random variable <em>Weather, </em>and the edges between them show the probability of the next random variable taking the different possible states, given the state of the current random variable. The self-loops show the probability of the model staying in its current state. In the previous Markov chain, let's say we know that the observed state of the current random variable is <em>Sunny, </em>then the probability that the random variable at the next time instance will also take the value <em>Sunny </em>is <em>0.8</em>. It could also take the value <em>Rainy </em>with a probability of <em>0.19</em>, or <em>Snowy</em> with a probability of <em>0.01</em>. One thing to note here is that the sum of all the probability values on all the outward edges from any state should equal 1, since it's an exhaustive event.</p>
<p class="mce-root"/>
<p>Now, let's try to code this simple Markov chain. We will start by defining a simple <kbd>MarkovChain</kbd> class, and we will keep on adding methods to this class as we go through this chapter:</p>
<pre>import numpy as np<br/><br/>class MarkovChain(object):<br/>    def __init__(self, transition_prob):<br/>        """<br/>        Initialize the MarkovChain instance.<br/><br/>        Parameters<br/>        ----------<br/>        transition_prob: dict<br/>            A dict object representing the transition probabilities in <br/>            Markov Chain. Should be of the form: {'state1': {'state1': <br/>            0.1, 'state2': 0.4}, 'state2': {...}}<br/>        """<br/>        self.transition_prob = transition_prob<br/>        self.states = list(transition_prob.keys())<br/><br/>    def next_state(self, current_state):<br/>        """<br/>        Returns the state of the random variable at the next time <br/>        instance.<br/><br/>        Parameters<br/>        ----------<br/>        current_state: str<br/>            The current state of the system.<br/>        """<br/>        return np.random.choice(<br/>            self.states, p=[self.transition_prob[current_state][next_state] <br/>                            for next_state in self.states])<br/><br/>    def generate_states(self, current_state, no=10):<br/>        """<br/>        Generates the next states of the system.<br/><br/>        Parameters<br/>        ----------<br/>        current_state: str<br/>            The state of the current random variable.<br/><br/>        no: int<br/>            The number of future states to generate.<br/>        """<br/>        future_states = []<br/>        for i in range(no):<br/>            next_state = self.next_state(current_state)<br/>            future_states.append(next_state)<br/>            current_state = next_state<br/>        return future_states</pre>
<p>Now, we can try out our example with this <kbd>MarkovChain</kbd> class:</p>
<pre>&gt;&gt;&gt; transition_prob = {'Sunny': {'Sunny': 0.8, 'Rainy': 0.19, <br/> 'Snowy': 0.01},<br/> 'Rainy': {'Sunny': 0.2, 'Rainy': 0.7,<br/> 'Snowy': 0.1},<br/> 'Snowy': {'Sunny': 0.1, 'Rainy': 0.2,<br/> 'Snowy': 0.7}}<br/><br/>&gt;&gt;&gt; weather_chain = MarkovChain(transition_prob=transition_prob)<br/>&gt;&gt;&gt; weather_chain.next_state(current_state='Sunny')<br/>'Sunny'<br/>&gt;&gt;&gt; weather_chain.next_state(current_state='Snowy')<br/>'Snowy'<br/>&gt;&gt;&gt; weather_chain.generate_states(current_state='Snowy', no=10)     <br/>['Snowy', 'Snowy', 'Snowy', 'Rainy', 'Snowy', 'Snowy', 'Rainy',
 'Rainy', 'Snowy', 'Snowy']</pre>
<div class="packt_infobox">In the previous code example, you might find your outputs to be different from what's shown here. This is because the Markov chain is probabilistic in nature and it picks on the next state based on a probability distribution, which can give different outputs on different runs.</div>
<p>So far in the discussion, we have considered that the probability space of the variables doesn't change over different instances of time. This is known as a <strong>time-homogeneous Markov chain</strong>, but it is also possible to have a <strong>time-inhomogeneous Markov chain</strong>, which also has a lot of applications but is outside the scope of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parameterization of Markov chains</h1>
                </header>
            
            <article>
                
<p>In the code for the Markov chain in the previous section, we used a dictionary to parameterize the Markov chain that had the probability values of all the possible state transitions. Another way of representing state transitions is using a <strong>transition matrix</strong>. The transition matrix, as the name suggests, uses a tabular representation for the transition probabilities. The transition matrix for the example in <em>Figure 1.1</em> is shown in the following table.</p>
<p class="mce-root"/>
<p><span>The following table shows the transition matrix for the Markov chain shown in <em>Figure 1.1</em>. The probability values represent the probability of the system going from the state in the row to the states mentioned in the columns:</span></p>
<table border="1" style="width: 498px;height: 257px">
<tbody>
<tr>
<td style="width: 122px"><strong>States</strong></td>
<td style="width: 118px"><strong>Sunny</strong></td>
<td style="width: 107px"><strong>Rainy</strong></td>
<td style="width: 123px"><strong>Snowy</strong></td>
</tr>
<tr>
<td style="width: 122px"><strong>Sunny</strong></td>
<td style="width: 118px">0.8</td>
<td style="width: 107px">0.19</td>
<td style="width: 123px">0.01</td>
</tr>
<tr>
<td style="width: 122px"><strong>Rainy</strong></td>
<td style="width: 118px">0.2</td>
<td style="width: 107px">0.7</td>
<td style="width: 123px">0.1</td>
</tr>
<tr>
<td style="width: 122px"><strong>Snowy</strong></td>
<td style="width: 118px">0.1+</td>
<td style="width: 107px">0.2</td>
<td style="width: 123px">0.7</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The transition matrix represents the same information as in the dictionary, but in a more compact way. For this reason, the transition matrix is the standard way of representing Markov chains. Let's modify our <kbd>MarkovChain</kbd> class so that it can accept a transition matrix:</p>
<pre>import numpy as np<br/><br/>class MarkovChain(object):<br/>    def __init__(self, transition_matrix, states):<br/>        """<br/>        Initialize the MarkovChain instance.<br/><br/>        Parameters<br/>        ----------<br/>        transition_matrix: 2-D array<br/>            A 2-D array representing the probabilities of change of <br/>            state in the Markov Chain.<br/><br/>        states: 1-D array <br/>            An array representing the states of the Markov Chain. It<br/>            needs to be in the same order as transition_matrix.<br/>        """<br/>        self.transition_matrix = np.atleast_2d(transition_matrix)<br/>        self.states = states<br/>        self.index_dict = {self.states[index]: index for index in <br/>                           range(len(self.states))}<br/>        self.state_dict = {index: self.states[index] for index in<br/>                           range(len(self.states))}<br/><br/>    def next_state(self, current_state):<br/>        """<br/>        Returns the state of the random variable at the next time <br/>        instance.<br/><br/>        Parameters<br/>        ----------<br/>        current_state: str<br/>            The current state of the system.<br/>        """<br/>        return np.random.choice(<br/>                    self.states, <br/>                    p=self.transition_matrix[self.index_dict[current_state], :])<br/><br/>    def generate_states(self, current_state, no=10):<br/>        """<br/>        Generates the next states of the system.<br/><br/>        Parameters<br/>        ----------<br/>        current_state: str<br/>            The state of the current random variable.<br/><br/>        no: int<br/>            The number of future states to generate.<br/>        """<br/>        future_states = []<br/>        for i in range(no):<br/>            next_state = self.next_state(current_state)<br/>            future_states.append(next_state)<br/>            current_state = next_state<br/>        return future_states</pre>
<p>Running this code should also give similar results to what we got in the previous section. Using a transition matrix might not seem like a good idea because it requires us to create extra variables to store the indices. But, in cases when we have hundreds of states, using a transition matrix is much more efficient than using the simple dictionary implementation. In the case of a transition matrix, we can simply use NumPy indexing to get the probability values in the <kbd>next_state</kbd> method, whereas we were looping over all the state names in the previous implementation:</p>
<pre>&gt;&gt;&gt; transition_matrix = [[0.8, 0.19, 0.01],<br/>                         [0.2,  0.7,  0.1],<br/>                         [0.1,  0.2,  0.7]]<br/>&gt;&gt;&gt; weather_chain = MarkovChain(transition_matrix=transition_matrix,<br/>                                states=['Sunny', 'Rainy', 'Snowy'])<br/>&gt;&gt;&gt; weather_chain.next_state(current_state='Sunny')<br/>'Sunny'<br/>&gt;&gt;&gt; weather_chain.next_state(current_state='Snowy')<br/>'Sunny'<br/>&gt;&gt;&gt; weather_chain.generate_states(current_state='Snowy', no=10)<br/>['Snowy', 'Rainy', 'Rainy', 'Rainy', 'Rainy', 'Rainy', <br/> 'Rainy', 'Rainy', 'Sunny', 'Sunny']</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Properties of Markov chains</h1>
                </header>
            
            <article>
                
<p>In this section, we will talk about the different properties of Markov chains, namely reducibility, periodicity, transience and recurrence, ergodicity, and steady-state analysis and limiting distributions. We will also try some simple examples of our <kbd>MarkovChain</kbd> class to show these properties.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reducibility</h1>
                </header>
            
            <article>
                
<p>A Markov chain is said to be <strong>irreducible</strong> if we can reach any state of the given Markov chain from any other state. In terms of states, state <em>j</em> is said to be <strong>accessible</strong> from another state <em>i </em>if a system that started at state <em>i</em> has a non-zero probability of getting to the state <em>j</em>. In more formal terms, state <em>j</em> is said to be accessible from state <em>i</em> if an integer <em>n<sub>ij</sub> ≥ 0</em> exists such that the following condition is met:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/08868cdf-6f36-4bf9-9a0a-238a7b3ae4ac.png" style="width:16.33em;height:1.83em;"/></div>
<p class="mce-root">The <em>n<sub>ij</sub></em> here is basically the number of steps it takes to go from state <em>i</em> to <em>j</em>, and it can be different for different pairs of values for <em>i</em> and <em>j</em>. Also, for a given state <em>i</em>, if all the values for <em>n<sub>ij</sub> = 0</em>, it means that all the states of the Markov chain are directly accessible from it. The accessibility relation is reflexive and transitive, but not necessary symmetric. We can take a simple example to understand this property:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2157c03e-4397-4110-a66a-e37822909cf6.png" style="width:52.25em;height:16.67em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1.2: An example of an irreducible Markov chain</div>
<p><span>In the previous example, it can be clearly seen that all of the states are accessible from all other states and hence are irreducible.</span></p>
<p class="mce-root"/>
<div class="packt_tip"><span>Note in the examples in <em>Figure 1.2</em> and <em>Figure 1.3</em> that we haven't represented edges if probability values are 0. This helps to keep the model less complicated and easier to read.</span></div>
<p><span>In the following example, we can see that state <strong>D</strong> is not accessible from <strong>A</strong>, <strong>B</strong>, or <strong>C</strong>. Also, state <strong>C</strong> is not accessible from either <strong>A</strong> or <strong>B</strong>. But all the states are accessible from state <strong>D</strong>, and states <strong>A</strong> and <strong>B</strong> are accessible from <strong>C</strong>:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/90f569c3-3c03-4fcc-8f3d-cd039301b53d.png" style="width:50.50em;height:12.58em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1.3: An example of a reducible Markov chain</div>
<p>We can also add a couple of methods to our <kbd>MarkovChain</kbd> class to check which states in our chain are reachable and whether our chain is irreducible:</p>
<pre>from itertools import combinations<br/><br/>def is_accessible(self, i_state, f_state):<br/>    """<br/>    Check if state f_state is accessible from i_state.<br/><br/>    Parameters<br/>    ----------<br/>    i_state: str<br/>        The state from which the accessibility needs to be checked.<br/>    <br/>    f_state: str<br/>        The state to which accessibility needs to be checked.<br/>    """<br/>    reachable_states = [i_state]<br/>    for state in reachable_states:<br/>        if state == self.index_dict[f_state]:<br/>            return True<br/>        else:<br/>            reachable_states.append(np.nonzero(<br/>              self.transition_matrix[self.index_dict[i_state], :])[0])<br/>    return False<br/><br/>def is_irreducible(self):<br/>    """<br/>    Check if the Markov Chain is irreducible.<br/>    """<br/>    for (i, j) in combinations(self.states, self.states):<br/>        if not self.is_accessible(i, j):<br/>            return False<br/>    return True</pre>
<p>Let's give our examples a try using the examples in <em>Figure 1.2</em> and <em>Figure 1.3</em>:</p>
<pre>&gt;&gt;&gt; transition_irreducible = [[0.5, 0.5, 0, 0],<br/>                              [0.25, 0, 0.5, 0.25],<br/>                              [0.25, 0.5, 0, 0.25],<br/>                              [0, 0, 0.5, 0.5]]<br/>&gt;&gt;&gt; transition_reducible = [[0.5, 0.5, 0, 0],<br/>                            [0, 1, 0, 0],<br/>                            [0.25, 0.5, 0, 0],<br/>                            [0, 0, 0.25, 0.75]]<br/>&gt;&gt;&gt; markov_irreducible = MarkovChain(transition_matrix=transition_irreducible,<br/>                                     states=['A', 'B', 'C', 'D'])<br/>&gt;&gt;&gt; markov_reducible = MarkovChain(transition_matrix=transition_reducible,<br/>                                   states=['A', 'B', 'C', 'D'])<br/>&gt;&gt;&gt; markov_irreducible.is_accessible(i_state='A', f_state='D')<br/>True<br/>&gt;&gt;&gt; markov_irreducible.is_accessible(i_state='B', f_state='D')<br/>True<br/>&gt;&gt;&gt; markov_irreducible.is_irreducible()<br/>True<br/>&gt;&gt;&gt; markov_reducible.is_accessible(i_state='A', f_state='D')<br/>False<br/>&gt;&gt;&gt; markov_reducible.is_accessible(i_state='D', f_state='A')<br/>True<br/>&gt;&gt;&gt; markov_reducible.is_accessible(i_state='C', f_state='D')<br/>False<br/>&gt;&gt;&gt; markov_reducible.is_irreducible()<br/>False</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Periodicity</h1>
                </header>
            
            <article>
                
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">State <em>i</em> is said to have period <em>k</em> if any possible path to return to state <em>i</em> would be a multiple of <em>k</em> steps. Formally, it is defined like this:</p>
<div class="CDPAlignCenter"><img class="fm-editor-equation" src="assets/6dbaa677-d15d-4024-a027-174e6458d04f.png" style="width:22.17em;height:1.42em;"/></div>
<p>Here, <em>gcd </em>means the <strong>greatest common divisor</strong> (<strong>GCD</strong>). Basically, <em>k</em> is the GCD of the length/number of steps of all possible paths from state <em>i</em> back to itself. If there are no possible paths from state <em>i </em>back to itself, then the period for it is not defined. We also need to note that <em>k</em> has nothing to do with the number of steps required to return to the starting state. For example, let's say that for any given state the number of steps required to return to it are <em>(4, 6, 8, 12, 16)</em>. In this case <em>k=2</em>, but the minimum number of steps required to return is <em>4,</em> and <em>2</em> doesn't even appear in the list of possible numbers of steps. </p>
<p>For any given state in the Markov chain, if <em>k=1</em>, the state is said to be <strong>aperiodic</strong>. A Markov chain is called aperiodic if all of its states are aperiodic. One major thing to note is that, in the case of an irreducible Markov chain, a single aperiodic state is enough to imply that all the states are aperiodic. Let's take a simple example and check the periodicity of different states:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e557d34b-4c7d-488b-aac4-79b0078332b2.png" style="width:42.25em;height:7.83em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1.4: <span>Markov chain is also periodic</span></div>
<p>In the previous example, we can easily see that for state <strong>A</strong> the possible paths to return are <strong>A</strong> -&gt; <strong>B</strong> -&gt; <strong>C</strong> -&gt; <strong>A</strong> or <strong>A</strong> -&gt; <strong>B</strong> -&gt; <strong>C</strong> -&gt; <strong>D</strong> -&gt; <strong>E</strong> -&gt; <strong>C</strong> -&gt; <strong>A</strong>. For these two paths, the path lengths are 3 and 6, respectively, and hence state <strong>A</strong> has a period of 3. Similarly, <strong>B</strong>, <strong>C</strong>, <strong>D</strong>, and <strong>E</strong> also each has a period of 3 in the Markov chain, and hence the Markov chain is also periodic:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/53bdcce6-38f9-4282-8046-827e2ae07a11.png" style="width:44.50em;height:8.25em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1.5: Example of Markov Chain with aperiodic states.</div>
<p>In this example, we added a couple of extra edges, due to which the possible path lengths for <strong>A</strong> are now <em>3, 5, 7, ...;</em> and for <strong>B</strong> are <em>2, 3, 4, 5, ...</em> And, since the GCD of these path lengths is 1, states <strong>A</strong> and <strong>B</strong> are both <span>now </span>aperiodic. Similarly, we can compute the period of other nodes, each of which is also 1, and hence the Markov chain is also aperiodic.</p>
<p>Let's now add a couple of new methods to our <kbd>MarkovChain</kbd> class to compute the period of different states and check whether our model is aperiodic:</p>
<pre>def get_period(self, state):<br/>    """<br/>    Returns the period of the state in the Markov Chain.<br/><br/>    Parameters<br/>    ----------<br/>    state: str<br/>        The state for which the period needs to be computed.<br/>    """<br/>    return gcd([len(i) for i in all_possible_paths])<br/><br/>def is_aperiodic(self):<br/>    """<br/>    Checks if the Markov Chain is aperiodic. <br/>    """<br/>    periods = [self.get_period(state) for state in self.states]<br/>    for period in periods:<br/>        if period != 1:<br/>            return False<br/>    return True</pre>
<p>Let's now try out our methods on our examples. In this example, we will randomly assign probability values to different transitions:</p>
<pre>&gt;&gt;&gt; transition_periodic = [[0, 1, 0, 0, 0],<br/>                           [0, 0, 1, 0, 0],<br/>                           [0.5, 0, 0, 0.5, 0],<br/>                           [0, 0, 0, 0, 1],<br/>                           [0, 0, 1, 0, 0]]<br/>&gt;&gt;&gt; transition_aperiodic = [[0, 1, 0, 0, 0],<br/>                            [0, 0, 1, 0, 0],<br/>                            [0.5, 0.25, 0, 0.25, 0],<br/>                            [0, 0, 0, 0, 1],<br/>                            [0, 0, 0.5, 0.5, 0]]<br/>&gt;&gt;&gt; markov_periodic = MarkovChain(transition_matrix=transition_periodic,<br/>                                  states=['A', 'B', 'C', 'D', 'E'])<br/>&gt;&gt;&gt; markov_aperiodic = MarkovChain(transition_matrix=transition_aperiodic,<br/>                                   states=['A', 'B', 'C', 'D', 'E'])<br/><br/>&gt;&gt;&gt; markov_periodic.get_period('A')<br/>3<br/>&gt;&gt;&gt; markov_periodic.get_period('C')<br/>3<br/>&gt;&gt;&gt; markov_aperiodic.is_periodic()<br/>False<br/><br/>&gt;&gt;&gt; markov_aperiodic.get_period('A')<br/>1<br/>&gt;&gt;&gt; markov_aperiodic.get_period('B')<br/>1<br/>&gt;&gt;&gt; markov_aperiodic.is_periodic()<br/>True</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transience and recurrence</h1>
                </header>
            
            <article>
                
<p>Given that we start at state <em>i</em>, it is called <strong>transient </strong>if there is a non-zero probability that we will never return to state <em>i</em>. To define this in more formal terms, let's consider a random variable <em>T<sub>i</sub></em> as the first return time to state <em>i</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/04d20803-cef5-45c5-9b34-dc573ecd193a.png" style="width:17.92em;height:1.58em;"/></div>
<p>Let's now define another term, <img class="fm-editor-equation" src="assets/4f34bad6-91a7-4962-84fc-d352a981f4fc.png" style="width:1.50em;height:1.58em;"/>, as the probability of the system returns to state <em>i</em> after <em>n</em> steps:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/270650b0-6e5f-44da-ae58-7dd809c8bc7c.png" style="width:9.33em;height:1.58em;"/></div>
<p class="mce-root">Now we can define that any given state <em>i</em> is transient if the following condition is met:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/2f7cf787-a6e8-4932-80c9-222ebe3bf2e5.png" style="width:13.75em;height:3.58em;"/></div>
<p>In the preceding equation, we are basically checking whether the total sum of probabilities of returning to state <em>i</em> in step sizes less than <img class="fm-editor-equation" src="assets/5e7bf897-9732-416f-9b50-5f97c4443743.png" style="width:1.58em;height:0.92em;"/> is less than <em>1</em>. If the total sum is less than <em>1</em>, it would mean that the probability of <em><span>T</span><sub>i</sub></em> to be <img class="fm-editor-equation" src="assets/698f246f-4292-4db7-9ec1-0662ddf1b719.png" style="width:1.58em;height:0.92em;"/> is greater than <em>0</em> which would mean that the state <em>i</em> is transient. The given state <em>i</em> is called <strong>recurrent</strong> if it is not transient:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e52def1e-c33f-4ac5-890c-54ae185acdab.png" style="width:44.75em;height:10.58em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1.6:</div>
<p>In the preceding example, we can see that states <strong>A</strong> and <strong>B</strong> are transient because <strong>A</strong> doesn't have any incoming edge. <strong>B</strong> does have an incoming edge, but it's incoming from another transient state and therefore it is also transient. Hence, once the system leaves state <strong>A</strong> or <strong>B</strong>, it won't be able to come back.</p>
<p>It is really simple to check whether a given state is transient or not. We can simply check whether there are any incoming edges from other states or not. If not, the state is transient. Let's write a simple method to check this for our <kbd>MarkovChain</kbd> class:</p>
<pre>def is_transient(self, state):<br/>    """<br/>    Checks if a state is transient or not.<br/><br/>    Parameters<br/>    ----------<br/>    state: str<br/>        The state for which the transient property needs to be checked.<br/>    """<br/>    if all(self.transition_matrix[~self.index_dict[state], self.index_dict[state]] == 0):<br/>        return True<br/>    else:<br/>        return False</pre>
<p>Now we can use this method in our example in <em>Figure 1.6</em> to check which nodes are transient:</p>
<pre>&gt;&gt;&gt; transient_matrix = [[0, 0.5, 0.5, 0],<br/>                        [0, 0, 0.25, 0.75],<br/>                        [0, 0, 0, 1],<br/>                        [0, 0, 0.5, 0.5]]<br/>&gt;&gt;&gt; transient_markov = MarkovChain(transition_matrix=transient_matrix,<br/>                                   states=['A', 'B', 'C', 'D'])</pre>
<pre>&gt;&gt;&gt; transient_markov.is_transient('A')<br/>True<br/>&gt;&gt;&gt; transient_markov.is_transient('B')<br/>True<br/>&gt;&gt;&gt; transient_markov.is_transient('C')<br/>False</pre>
<p>In the following subsections, we will talk about the statistical properties of the random variable <em><span>T</span><sub>i</sub></em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mean recurrence time</h1>
                </header>
            
            <article>
                
<p>The first-return time for the initial state <em>i</em> is also known as the <strong>hitting time</strong>. It was represented using the random variable <em><span>T</span><sub>i</sub></em> in the previous section. The <strong>mean recurrence time </strong>of state <em>i</em> is defined as its expected return time:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/ed32432b-7b90-47b3-b018-58e9ccf05b4b.png" style="width:10.25em;height:3.33em;"/></div>
<p>If the mean recurrence time, <em><span>M</span><sub>i</sub></em>, is finite, the state is called <strong>positive recurrent</strong>, otherwise it is called <strong>null recurrent</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Expected number of visits</h1>
                </header>
            
            <article>
                
<p>As is evident from the name, the <strong>expected number of visits </strong>for any state <em>i</em> is the number of times the system is expected to be in that state. Also, a given state <em>i</em> is recurrent if and only if the expected number of visits to <em>i</em> is infinite:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/fb6b31d3-c6c7-495d-a26b-ad26a66abaff.png" style="width:6.58em;height:3.75em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Absorbing states</h1>
                </header>
            
            <article>
                
<p>State <em>i</em> is said to be an <strong>absorbing state </strong>if it is impossible for a system to leave that state once it reaches it. For a state to be an absorbing state, the probability of staying in the same state should be <em>1</em>, and all the other probabilities should be <em>0</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/09d3d7e8-7bed-43c4-aaed-c50658b6e009.png" style="width:14.42em;height:1.42em;"/></div>
<p>In a Markov chain, if all the states are absorbing, then we call it an absorbing Markov chain:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ed11565f-4c97-40c8-b946-587c3d705b3a.png" style="width:33.67em;height:7.25em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Figure 1.7: An example showing an absorbing state C, since the probability of transitioning from state C to C is <em><em>1</em></em></div>
<p>Again, we can add a very simple method to check for absorbing states in our <kbd>MarkovChain</kbd> class:</p>
<pre>def is_absorbing(self, state):<br/> """<br/> Checks if the given state is absorbing.<br/><br/> Parameters<br/> ----------<br/> state: str<br/> The state for which we need to check whether it's absorbing<br/> or not.<br/> """<br/> state_index = self.index_dict[state]<br/> if self.transition_matrix[state_index, state_index]</pre>
<p>We can again check whether our state i<span>n the example </span>is absorbing by creating a Markov chain and using the <kbd>is_absorbing</kbd> method:</p>
<pre>&gt;&gt;&gt; absorbing_matrix = [[0, 1, 0],<br/>                        [0.5, 0, 0.5],<br/>                        [0, 0, 1]]<br/>&gt;&gt;&gt; absorbing_chain = MarkovChain(transition_matrix=absorbing_matrix,<br/>                                  states=['A', 'B', 'C'])<br/>&gt;&gt;&gt; absorbing_chain.is_absorbing('A')<br/>False<br/>&gt;&gt;&gt; absorbing_chain.is_absorbing('C')<br/>True</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ergodicity</h1>
                </header>
            
            <article>
                
<p>State <em>i</em> is said to be ergodic<strong> </strong>if it is recurrent, has a period of <em>1</em>, and has a finite mean recurrence time. If all the states of a Markov chain are ergodic, then it's an ergodic Markov chain. In general terms, a Markov chain is ergodic if there is a number <em>N</em>, such that any state in the system can be reached from any other state in any number of steps greater than or equal to the number <em>N</em>. Therefore, in the case of a fully connected transition matrix, where all transitions have a non-zero probability, this condition is fulfilled with <em>N=1</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Steady-state analysis and limiting distributions</h1>
                </header>
            
            <article>
                
<p>In a Markov chain, vector <em>π</em> is called the <strong>stationary distribution</strong> if <em>∀ j ∈ s</em> satisfies the following conditions:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/a953572f-46e4-4143-8949-bb5c54f86fd0.png" style="width:5.50em;height:1.33em;"/></div>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/a08e7d8a-dc8a-4a1f-88f6-c1785c4aee42.png" style="width:5.33em;height:3.00em;"/></div>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/abef43c3-94bd-45eb-86ef-e533349dc6b2.png" style="width:6.08em;height:2.42em;"/></div>
<p>The stationary distribution is one of the most important properties of Markov chains, and we will talk about it in much more detail in later sections of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Continuous-time Markov chains</h1>
                </header>
            
            <article>
                
<p>Continuous-time Markov chains are quite similar to discrete-time Markov chains except for the fact that in the continuous case we explicitly model the transition time between the states using a positive-value random variable. Also, we consider the system at all possible values of time instead of just the transition times.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exponential distributions</h1>
                </header>
            
            <article>
                
<p>The random variable <em>x</em> is said to have an exponential distribution with a rate of distribution of <em>λ</em> if its probability density function is defined as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b3978ef3-e2da-4d7a-a261-2b515257ad70.png" style="width:15.50em;height:2.92em;"/></div>
<p>Here, the rate of distribution <em>λ</em> needs to be greater than <em>0</em>. We can also compute the expectation of <em>X</em> as this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/75e9d1c4-2111-4f43-a9e3-10abfa201cd6.png" style="width:17.58em;height:10.75em;"/></div>
<p>We see that the expectation of <em>X</em> is inversely proportional to the rate of learning. This means that an exponential distribution with a higher rate of learning would have a lower expectation. The exponential distribution is often used to model problems that involve modelling time until some event happens. A simple example could be modelling the time before an alarm clock goes off, or the time before a server comes to your table in a restaurant. And, as we know <img class="fm-editor-equation" src="assets/dd100edc-df74-492f-8eb3-5ec358f9ebc2.png" style="width:3.58em;height:1.75em;"/>, the higher the learning rate, the sooner we would expect the event to happen, and hence the name <em>learning rate</em>. </p>
<p>We can also compute the second moment and the variance of the exponential distribution:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b1ae65c6-6e54-47db-87eb-707b6fa61733.png" style="width:15.33em;height:2.83em;"/></div>
<p class="mce-root"><span>And, using the first moment and the second moment, we can compute the variance of the distribution:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/ef34e702-b79c-40a3-8895-4ae604c4887d.png" style="width:13.67em;height:4.25em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/825fd73b-5528-4cc5-8038-7f6591e99edd.png" style="width:16.25em;height:13.00em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1.x: Probability distribution of exponential distribution</div>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/01d538af-5079-4bf5-9a31-acceb2ec78a0.png" style="width:2.92em;height:1.25em;"/> <img class="fm-editor-equation" src="assets/5e2aefcc-b7b3-41d8-ba93-19e3fd346718.png" style="width:3.58em;height:1.17em;"/></div>
<p>Now we will move on to some of the properties of the exponential distribution that are relevant to our example:</p>
<ul>
<li><strong>Memoryless</strong>:<strong> </strong><em>Figure 1.x</em> shows a plot of an exponential distribution. In the diagram, we can clearly see that the graph after any given point (<em>a</em> in this case) is an exact copy of the original distribution. We can also say that an exponential distribution that is conditioned on (<em>X &gt; a</em>) still stays exponential. If we think about this property in terms of our examples, it means that if we had an alarm clock, and at any time, <em>t</em>, we check that it still hasn't gone off, we can still determine the distribution over the time ahead of <em>t</em>, which will be the same exponential distribution. This property of the exponential distribution is known as being <strong>memoryless</strong>,<strong> </strong>since at any given point in time, if you know the current state of the system (in this example, that the alarm hasn't gone off), you can determine the probability distribution over time in the future. This property of exponential distributions is quite similar to Markov chains, as you may recall from previous sections.</li>
<li><strong>Probability of minimum value</strong>:<strong> </strong>Let's say we have <em>n</em> independent exponential distributions over the random variables <em>X<sub>0</sub></em>, . . ., <em>X<sub>n</sub></em> with learning rates <em><span>λ<sub>0</sub>, ..., λ<sub>n</sub></span></em>, respectively. For these distributions, we can prove that the distribution of <em>min(X<sub>0</sub>, . . ., X<sub>n</sub>)</em><span> is also an exponential distribution with learning rate </span><img class="fm-editor-equation" src="assets/61a44bbe-5d1f-438a-a39b-77f63415ceb4.png" style="font-size: 1em;width:1.83em;height:2.17em;"/>:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/d2d9ee00-7dc9-4139-bfc6-1033a6dc3bb4.png" style="width:25.58em;height:10.17em;"/></div>
<p>We will use both of these properties of the exponential distribution in our example for the continuous time Markov chain in a later section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Poisson process</h1>
                </header>
            
            <article>
                
<p>The Poisson process is a continuous process, and there can be multiple interpretations of it, which lead to different possible definitions. In this section, we will start with the formal definition and build up to a more simple, intuitive definition. A continuous-time stochastic process <em>N(t):t &gt; 0</em> is a <strong>Poisson process</strong> with a rate <em><span>λ &gt; 0</span></em> if the following conditions are met:</p>
<ul>
<li><em>N(0) = 0</em></li>
<li>It has <strong>stationary</strong> and <strong>independent increments</strong></li>
<li>The distribution of <em>N(t)</em> is Poisson with mean <em><span>λt</span></em>:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/ee5e44d4-e407-47e7-b423-c6b65a4838c4.png" style="width:24.50em;height:3.08em;"/></div>
<p>First of all, we need to define what the stationary and independent increments are. For a continuous-time stochastic process, <em>X(t): ≥ 0</em>, an increment is defined as the difference in state of the system between two time instances; that is, given two time instances <em>s</em> and <em>t</em> with <em>s &lt; t</em>, the increment from time <em>s</em> to time <em>t</em> is <em>X(t) - X(s)</em>. As the name suggests, a process is said to have a stationary increment if its distribution for the increment depends only on the time difference.</p>
<p class="mce-root"/>
<p>In other words, a process is said to have a stationary increment if the distribution of <em>X(t<sub>1</sub>) - X(s<sub>1</sub>)</em> is equal to <em>X(t<sub>2</sub>) - X(s<sub>2</sub>)</em> if <em>t<sub>1</sub> &gt; s<sub>1</sub>,t<sub>2</sub> &gt; s<sub>2</sub></em> and <em>t<sub>1</sub> - s<sub>1</sub> = t<sub>2</sub> -s<sub>2</sub></em>. A process is said to have an independent increment if any two increments in disjointed time intervals are independent; that is, if <em><span>t</span><sub>1</sub><span> &gt; s</span><sub>1</sub> &gt; <span>t</span><sub>2</sub><span> &gt; s</span><sub>2</sub></em>, then the increments <em>X(t<sub>2</sub>) - X(s<sub>2</sub>)</em> and <em>X(t<span>1)</span> - X(s<span>1</span>)</em> are independent. </p>
<p>Now let's come back to defining the Poisson process. The Poisson process is essentially a counting process that counts the number of events that have occurred before time <em>t</em>. This count of the number of events before time <em>t</em> is given by <em>N(t),</em> and, similarly, the number of events occurring between time intervals <em>t</em> and <em>t + s</em> is given by <em>N(t + s) - N(t)</em>. The value <em>N(t + s) - N(t)</em> is Poisson-distributed with a mean <em>λ<sub>s</sub></em>. We can see that the Poisson process has stationary increments in fixed time intervals, but as <img class="fm-editor-equation" src="assets/8fc844b3-9885-4aea-8137-0b980d454a11.png" style="width:3.92em;height:1.08em;"/>, the value of <em>N(t)</em> will also approach infinity; that is, <img class="fm-editor-equation" src="assets/a4c5c95a-61b3-4f89-a6f3-4b6eaaa929c3.png" style="width:4.42em;height:1.08em;"/>. Another thing worth noting is that, as the value of <em>λ</em> increases, the number of events happening will also increase, and that is why <span><em>λ</em> </span>is also known as the <strong>rate of the process</strong>.</p>
<p>This brings us to our second simplified definition of the Poisson process. A continuous-time stochastic process <em>N(t): t ≥ 0</em> is called a Poisson process with the rate of learning <em>λ &gt; 0</em> if the following conditions are met: </p>
<ul>
<li><em><em>N(0) = 0</em></em></li>
<li>It is a counting process; that is, <em>N(T)</em> gives the count of the number of events that have occurred before time <em>t</em></li>
<li>The times between the events are distributed independently and identically, with an exponential distribution having a learning rate of <em>λ</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Continuous-time Markov chain example</h1>
                </header>
            
            <article>
                
<p>Now, since we have a basic understanding of exponential distributions and the Poisson process, we can move on to the example to build up a continuous-time Markov chain. In this example, we will try to show how the properties of exponential distributions can be used to build up generic continuous-time Markov chains. Let's consider a hotel reception where <em>n</em> receptionists are working in parallel. Also consider that the guests arrive according to a Poisson process, with rate <em>λ</em>, and the service time for each guest is represented using an exponential random variable with learning rate <em>µ</em>. Also, if all the receptionists are busy when a new guest arrives, he/she will depart without getting any service. Now let's consider that a new guest arrives and finds all the receptionists are busy, and let's try to compute the expected number of busy receptionists in the next time interval. </p>
<p>Let's start by assuming that <em>T<sub>k</sub></em> represents the number of <em>k</em> busy receptionists in the next time instance. We can also use <em>T<sub>k</sub></em> to represent the expected number of busy receptionists found by the next arriving guest if <em>k</em> receptionists are busy at the current time instance. These two representations of <em>T<sub>k</sub></em> are equivalent because of the memoryless property of exponential distributions.</p>
<p>Firstly, <em>T<sub>0</sub></em> is clearly <em>0</em>, because if there are currently <em>0</em> busy receptionists, the next arrival will also find <em>0</em> busy receptionists for sure. Now, considering <em>T<sub><span>1</span></sub></em>, if there are currently <em>i</em> busy receptionists, the next arriving guest will find <em>1</em> busy receptionist if the time to the next arrival is less than the remaining service time for the busy receptionist. From the memoryless property, we know that the next arrival time is exponentially distributed with a learning rate of <em>λ</em>, and the remaining service time is also exponentially distributed with a learning rate of <em>µ</em>. Therefore, the probability that the next guest will find one receptionist busy is <img class="fm-editor-equation" src="assets/068b24db-2f99-4a87-b9cd-014c064a8012.png" style="width:2.17em;height:1.92em;"/> and hence the following is true:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/442d615d-93a8-4b50-83df-cad87da8a688.png" style="width:17.92em;height:2.75em;"/></div>
<p>In general, we consider the situation that <em>k</em> receptionists are busy. We can obtain an expression for <em>T<sub>k</sub></em> by conditioning on what happens first. When we have <em>k</em> receptionists busy, we can think of basically <em>k+1</em> independent exponential distributions: <em>k</em> exponentials with a learning rate of <em>µ</em> for the remaining service time for each receptionist, and <em>1</em> exponential distribution with a learning rate of <em>λ</em> for the next arriving guest. In our case, we want to condition on whether a service completion happens first or a new guest arrives first. The time for a service completion will be the minimum of the <em>k</em> exponentials. This first completion time is also exponentially distributed with a learning rate of <em>kµ</em>. Now, the probability of having a service completion before the next guest arrives is <img class="fm-editor-equation" src="assets/7ce58380-fab8-4c4b-9d1f-f3f3fe154a99.png" style="width:3.75em;height:2.33em;"/>. Similarly, the probability of the next thing happening being a guest arrival is <img class="fm-editor-equation" src="assets/175c5826-e3d2-475c-b4a7-3429afbc162f.png" style="width:3.58em;height:2.17em;"/>. </p>
<p>Now, based on this, we can say that if the next event is service completion, then the expected number of busy receptionists will be <em>T<sub>k-1</sub></em>. Otherwise, if a guest arrives first, there will be <em>k</em> busy receptionists. Therefore we have the following:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/82b218d4-3aba-4497-a550-b40a0f84beb6.png" style="width:15.67em;height:3.08em;"/></div>
<p>We need to just solve this recursion now. <em>T<sub>2</sub></em> will be given by this equation:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/10c9c1e2-44bf-4b47-95db-9f7d20a07ea5.png" style="width:16.67em;height:5.75em;"/></div>
<p>If we continue this same pattern, we will get <em>T<sub>3</sub></em> as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/bd73ad20-4547-46a9-81f7-b7c796b8e79c.png" style="width:18.33em;height:6.08em;"/></div>
<p>We can see a pattern in the values of <em>T<sub>1</sub></em> and <em>T<sub>2</sub></em>, and therefore we can write a general term for it as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/bb49a251-7a25-4539-a1a2-cd330a334033.png" style="width:20.50em;height:3.83em;"/></div>
<p class="mce-root"/>
<p>Let's point out our observations on the previous example:</p>
<ul>
<li>At any given time instance, if there are <em>i</em> busy receptionists, for <em>i &lt; n</em> there are <em>i + 1</em> independent exponential distributions, with <em>i</em> of them having rate <em>µ</em>, and <em>1</em> of them having rate <em>λ</em>. The time until the process makes a jump is exponential, and its rate is given by <em>iµ + λ</em>. If all the receptionists are busy, then only the <em>n</em> exponential distributions corresponding to the service time can trigger a jump, and the time until the process makes a jump is exponential with rate <em>nµ</em>.</li>
<li>When the process jumps from state <em>i</em><span>, for <em>i &lt; n</em></span><span>, it jumps to state <em>i + 1</em></span><span> with probability </span><img class="fm-editor-equation" src="assets/ed6d8ec5-8072-4d0c-a69a-ee917ca54e2a.png" style="font-size: 1em;color: #333333;width:4.08em;height:2.58em;"/>, <span>and jumps to state <em>i - 1</em></span><span> with probability of</span> <img class="fm-editor-equation" src="assets/1db82956-143a-4aea-9a00-55b931fdcf1f.png" style="font-size: 1em;color: #333333;width:2.92em;height:1.92em;"/><span>.</span></li>
<li>When the process makes a jump from state <em>i</em><span><span><span>, we can start up a whole new set of</span> distributions<span> corresponding to the state we jumped to. This is</span> because,<span> even though some of the old exponential distributions haven't triggered, it's equivalent to resetting or replacing those distributions.</span></span></span></li>
</ul>
<div class="packt_tip">Every time we jump to state <em>i</em>, regardless of when the time is, the distribution of how long we stay in state <em>i</em> and the probabilities of where we jump to next when we leave state <em>i</em> are the same. In other words, the process is time-homogeneous.</div>
<p>The preceding description of a continuous-time stochastic process corresponds to a continuous-time Markov chain. In the next section, we will try to define it in a more formal way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Continuous-time Markov chain</h1>
                </header>
            
            <article>
                
<p>In the previous section, we showed an example of a continuous-time Markov chain to give an indication of how it works. Let's now move on to formally define it. In a continuous-time Markov chain with a discrete state space <em>S,</em> for each state <em>i ∈ S</em> we have an associated set of <em>n<sub>i</sub></em> independent exponential distributions with rates <em>q<sub>i</sub>, j<sub>1</sub>, ..., q<sub>i</sub>,j<sub>n<sub>i</sub></sub></em>, where <em>j<sub>1</sub>, ..., j<sub>n<sub>i</sub></sub></em> is the set of possible states the process may jump to when it leaves state <em>i</em>. And, when the process enters state <em>i</em>, the amount of time it spends in state <em>i</em> is exponentially distributed with rate <em>v<sub>i</sub> = q<sub>i</sub>j<sub>1</sub>+...+q<sub>i</sub>j<sub>n<sub>i</sub></sub></em>, and when it leaves state <em>i</em> it will go to state <em>j<sub>l</sub></em> with probability <img class="fm-editor-equation" src="assets/4f414e44-4ad4-415c-b90a-e4faab286f59.png" style="width:2.42em;height:3.00em;"/> for <em>l = 1, ...,n<sub>i</sub></em>.</p>
<p>We can also extend the Markov property from the discrete-time case to continuous time.</p>
<p>For a continuous-time stochastic process <em>(X(t) : t ≥ 0)</em> with state space <em>S</em>, we say it has the Markov property if the following condition is met:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/32561f53-1637-4826-ad1c-8ce3f50d5a35.png" style="width:29.25em;height:3.17em;"/></div>
<p>Here, <em>0 ≤ t<sub>1</sub> ≤ t<span>2 ≤. . . .t<sub>n-1 </sub>≤ s</span><span> ≤ t</span></em> is any non-decreasing sequence of <em>n + 1</em> times, and <em>i<sub>1, i</sub>2, . . ., i<sub>n-1</sub>, i, j<sub> </sub>∈ S</em> are any <em>n + 1</em> states in the state space, for any integer <em>n ≥ 1</em>. </p>
<p>Similarly, we can extend time-homogeneity to the case of continuous-time Markov chains. We say that a continuous-time Markov chain is time homogenous if, for any <em>s ≤ t</em>, and any states <em>i</em>, <em>j ∈ S</em>, the following condition is met:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/11009b6b-202e-4776-af19-20bc7b346c53.png" style="width:25.50em;height:1.33em;"/></div>
<p>As in the case of discrete-time Markov chains, a continuous-time Markov chain does not need to be time-homogeneous, but non-homogeneous Markov chains are out of scope for this book. For more details on non-homogeneous Markov chains, you can refer to Cheng-Chi Huang's thesis on the topic: <a href="https://lib.dr.iastate.edu/cgi/viewcontent.cgi?article=8613&amp;context=rtd" target="_blank">https://lib.dr.iastate.edu/cgi/viewcontent.cgi?article=8613&amp;context=rtd</a>.</p>
<p>Now let's define the transition probability for a continuous-time Markov chain. Just as the rates <em>q<sub>ij</sub></em> in a continuous-time Markov chain are the counterpart of the transition probabilities <em>p<sub>ij</sub></em> in a discrete-time Markov chain, there is a counterpart to the n-step transition probabilities <em><span>p</span><sub>ij</sub>(t)</em> for a time-homogeneous, continuous-time Markov chain, which is defined as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/4e6b5a80-1819-4567-a31b-770a6c9f1798.png" style="width:16.58em;height:1.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we gave a detailed introduction to Markov chains. We talked about different types of Markov chains, mainly chains with a discrete state space, with either discrete time or continuous time. We also introduced the concepts of time-homogeneous and non-time-homogeneous Markov chains. We discussed the different properties of Markov chains in detail, and provided relevant examples and code.</p>
<p>Markov chains and their properties are the basic concepts on which HMMs are built. In the next chapter, we will discuss HMMs in much more detail. </p>


            </article>

            
        </section>
    </body></html>