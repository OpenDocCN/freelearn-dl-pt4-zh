- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to Graph Learning
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图学习简介
- en: Graph data is a powerful and intuitive way of expressing information, and several
    practical scenarios can be better expressed using graph data than tabular approaches.
    Analyzing graph data has been a topic of study for decades, but it has only recently
    begun to capture the limelight due to advances in compute capabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图形数据是一种强大且直观的信息表达方式，许多实际场景使用图形数据表达要比表格方式更为合适。图形数据分析已经是几十年的研究课题，但由于计算能力的提升，它最近才开始受到关注。
- en: In this book, we aim to introduce you to the world of **graphs** . Here, we’ll
    begin by discussing what graph data is and the fundamental mathematical terminologies
    surrounding graphs. Next, we’ll take a small detour and discuss some common graph
    algorithms and their applications in graph data analytics. We’ll extend our discussion
    on graph data analytics to the requirement of graph deep learning and why it stands
    as a specialized subdomain compared to applying existing architectures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们旨在向你介绍**图形**的世界。我们将从讨论图形数据是什么以及图形相关的基本数学术语开始。接下来，我们将绕道讨论一些常见的图算法及其在图形数据分析中的应用。我们还将扩展关于图形数据分析的讨论，涉及图形深度学习的需求，以及为何它作为一个专门子领域，与应用现有架构有所不同。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Do we need graphs?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要图形吗？
- en: Formalizing graphs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的形式化
- en: Types and properties of graphs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的类型和属性
- en: Graph data structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形数据结构
- en: Traditional graph-based solutions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的基于图的解决方案
- en: The need for **representation learning**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示学习**的需求'
- en: '**Graph neural networks** ( **GNNs** ) and the need for a separate vertical'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图神经网络**（**GNNs**）及其作为独立领域的需求'
- en: Do we need graphs?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们需要图形吗？
- en: The recent **artificial intelligence** ( **AI** ) revolution is the tip of the
    iceberg of a megatrend that has been impacting the computing industry for decades
    now. Over time, computing performance has increased exponentially against power
    consumed and cost; information storage costs have also decreased exponentially.
    To put this into perspective, while a terabyte of data can be stored in a disk
    costing around 100 US dollars in 2024, it would have taken more than a million
    dollars in the early 1990s!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的**人工智能**（**AI**）革命只是一个大趋势的冰山一角，这一趋势已影响计算机行业数十年。随着时间的推移，计算性能在消耗功率和成本上指数级增长；信息存储成本也在指数级下降。为了更好理解这一点，2024年，一个100美元的硬盘可以存储一TB数据，而在1990年代初，存储同样数据的成本超过一百万美元！
- en: 'Using computers and their derivative products, such as software, web applications,
    games, and multimedia content, has become deeply tied to our normal lifestyle.
    This dependence led to the need for understanding the behavior of all the interacting
    entities: humans, computer hardware, software such as web applications, and even
    organizations as a whole. The end goal was to find ways to make interactions more
    efficient, which could lead to unprecedented business opportunities.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算机及其衍生产品，如软件、网页应用程序、游戏和多媒体内容，已深深融入我们的日常生活。这种依赖关系催生了对所有交互实体行为的理解需求：人类、计算机硬件、像网页应用程序这样的软件，甚至整个组织。最终目标是找到方法提高交互效率，从而可能带来前所未有的商业机会。
- en: 'Initially, given the constraints of the time, the information that was collected
    was less organized and the recorded truth provided a very high-level overview
    of systems, and only about a handful of variables within the system (for data
    scientists, think of data at aggregated levels, and with a small number of dimensions).
    At some point, someone realized computing power and data storage were cheap enough
    that you could record facts more granularly: not only could individual scenarios
    be recorded separately and more frequently, but other variables could also be
    recorded every time a snapshot was taken. The data revolution had begun, and stakeholders
    realized that by capturing and reviewing enough data about these interacting entities,
    a holistic picture of their behavior in the ecosystem could be drawn. The 2010s
    were spent commoditizing data and its products, to the point that even Series
    A-funded startups have adopted a data solution: be it warehousing, Elasticsearch,
    or recommendation engines.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，由于时间的限制，收集到的信息较为零散，记录的事实提供了系统的一个非常高层次的概述，且仅涉及系统中的少量变量（对于数据科学家来说，类似于聚合级别的数据，且维度较少）。在某个时刻，有人意识到计算能力和数据存储已经足够便宜，可以更加细致地记录事实：不仅可以更频繁地单独记录每个场景，还可以在每次拍摄快照时记录其他变量。数据革命开始了，利益相关者意识到，通过捕捉并审查这些交互实体的足够数据，可以绘制出它们在生态系统中的行为全貌。2010年代人们致力于数据及其产品的商品化，以至于即使是获得A轮融资的初创公司也采用了数据解决方案：无论是数据仓库、Elasticsearch，还是推荐引擎。
- en: Taking a step back, let’s understand what data means. A data point is essentially
    just a factual statement. Very little discussion exists *on how the fact is represented
    in the data* . The de facto representation of data is tabular, and this has generally
    worked well for the capabilities built around the current data ecosystem. The
    focus on data science research and engineering has revolved around existing database
    architectures, which is why the tabular form of representation is the most widespread.
    However, the tabular form need isn’t the only form of representation. The purpose
    of this chapter is to build a case around the graph form of representation and
    why graph representations can be the best option for several practical scenarios.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 回到原点，让我们理解数据的含义。一个数据点本质上只是一个事实陈述。关于*事实在数据中的表示方式*，讨论非常少。数据的事实表示方式通常是表格形式，这对于围绕现有数据生态系统构建的能力而言通常运作良好。数据科学研究和工程的重点一直围绕现有的数据库架构，这也是表格形式的表示最为广泛的原因。然而，表格形式并不是唯一的表示方式。本章的目的是围绕图形表示法构建案例，并说明为什么图形表示法可以成为许多实际场景中的最佳选择。
- en: 'Graph data is represented using **nodes** (also called objects, vertices, or
    nouns) and **edges** (also called relationships, links, or verbs). Certain real-life
    scenarios necessitate emphasizing the relationships between the objects rather
    than just treating each object as an independent entity. Graph data structures
    provide us with a natural way to express these scenarios, as opposed to something
    such as the tabular format. Using the simple construct of treating entities as
    nodes and relationships as edges between two nodes, graph representations can
    effectively model information from a wide range of domains: from network topology
    to biological systems and supply chains to molecular structure.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据通过**节点**（也称为对象、顶点或名词）和**边**（也称为关系、链接或动词）来表示。某些现实生活中的场景需要强调对象之间的关系，而不仅仅是将每个对象视为独立实体。图数据结构为我们提供了一种自然的方式来表达这些场景，这与表格格式等其他方式不同。通过将实体视为节点、关系视为两个节点之间的边这一简单结构，图形表示能够有效地建模来自各个领域的信息：从网络拓扑到生物系统，再到供应链和分子结构。
- en: A case study
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究
- en: 'To make this point clearer, let’s consider a common question that arises in
    social networks. For a user (say John), we want to ascertain whether another user
    (say Mary) is a second-degree connection (to John). A second-degree connection
    simply means Mary and John have a common connection, but Mary isn’t directly connected
    (is friends with) to John. The social media platform commonly tracks this piece
    of information between a pair of users and determines whether they should be recommended
    by the platform to connect. We’ll tackle this problem from two perspectives: first
    using the tabular representation, and then using the graph representa tion.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明这一点，让我们考虑社交网络中常见的一个问题。对于一个用户（比如 John），我们想要确定另一个用户（比如 Mary）是否是其二度连接。二度连接简单来说是指
    Mary 和 John 有共同的连接，但 Mary 并不直接与 John 相连接（即 Mary 是 John 的朋友）。社交媒体平台通常在用户对之间跟踪这一信息，并决定是否应该推荐他们连接。我们将从两个角度解决这个问题：首先使用表格表示，然后使用图形表示。
- en: Tabular representation
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表格表示
- en: 'First, we need to understand what the schema of the tables in the database
    would be. In a typical social media platform database, there would be several
    tables – one for users (capturing demographic information such as age, location,
    date of joining, and so on), one for posts (containing details about a post made,
    such as the user who made the post, the contents of the post, the date of making
    the post, the visibility level, and so on), and many more. The table of concern
    for us would be something called the **connections table** . It should capture
    information about which users are connected directly (that is, they have a first-degree
    connection). The schema should go somewhat like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解数据库中表的架构。在典型的社交媒体平台数据库中，可能会有几个表 – 一个用于用户（包含年龄、位置、加入日期等人口统计信息）、一个用于帖子（包含关于发布帖子的详细信息，如发布帖子的用户、帖子内容、发布日期、可见性等），以及其他许多表。对我们而言关键的表是所谓的
    **连接表**。它应该记录直接连接的用户信息（即具有一度连接的用户）。架构应该类似于这样：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Table 1.1* shows a table that contains a few data points:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 1.1* 显示了一个包含几个数据点的表：'
- en: '| **conn_id** | **user_id_1** | **user_id_2** | **date_of_conn** | **status_of_conn**
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **conn_id** | **user_id_1** | **user_id_2** | **date_of_conn** | **status_of_conn**
    |'
- en: '| conn_uuid_0 | john_uuid | alex_uuid | 2022-10-30 | active |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| conn_uuid_0 | john_uuid | alex_uuid | 2022-10-30 | active |'
- en: '| conn_uuid_1 | alex_uuid | greg_uuid | 2023-03-12 | active |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| conn_uuid_1 | alex_uuid | greg_uuid | 2023-03-12 | active |'
- en: '| conn_uuid_2 | greg_uuid | mary_uuid | 2023-04-11 | active |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| conn_uuid_2 | greg_uuid | mary_uuid | 2023-04-11 | active |'
- en: '| conn_uuid_3 | mary_uuid | alex_uuid | 2023-06-09 | active |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| conn_uuid_3 | mary_uuid | alex_uuid | 2023-06-09 | active |'
- en: Table 1.1 – Example data stored in tabular format
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 – 以表格格式存储的示例数据
- en: 'To determine whether John and Mary have a second-degree connection, a SQL query
    similar to the following can be executed:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定 John 和 Mary 是否具有二度连接，可以执行类似以下的 SQL 查询：
- en: '![Figure 1.1 – A SQL query being performed over tables that were introduced
    previously to retrieve second-degree connections](img/B22118_01_1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 在先前介绍的表上执行的 SQL 查询，以检索二度连接](img/B22118_01_1.jpg)'
- en: Figure 1.1 – A SQL query being performed over tables that were introduced previously
    to retrieve second-degree connections
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 在先前介绍的表上执行的 SQL 查询，以检索二度连接
- en: The crux of this query contains a recursive self-join operation, where each
    recursion level contains the connections of a certain degree. The initial filter
    of **user_id_1 =** **'john_uuid'** OR **user_id_2 = 'john_uuid'** ensures that
    we only concern ourselves with users who are on some level and connected to John.
    Finally, by filtering by **degree = 2** , we can get the list of all users who
    have a second-degree connection to John.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询的关键部分包含递归自连接操作，其中每个递归级别包含特定程度的连接。初始过滤条件 **user_id_1 = 'john_uuid'** 或 **user_id_2
    = 'john_uuid'** 确保我们只关注与 John 有某种级别连接的用户。最后，通过过滤条件 **degree = 2** ，我们可以获取所有与 John
    有二度连接的用户列表。
- en: How efficient is this approach? The worst-case time complexity can be evaluated
    asymptotically and expressed in **Big-O notation** . Let ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    be the count of users present on the social media platform and ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png)
    be the count of all first-degree connections (or the number of entries in the
    connections table). Join algorithms have evolved, and current join operations
    are very efficient, but if we look at the naive approach, where two tables have
    lengths ![<mml:math  ><mml:mi>L</mml:mi></mml:math>](img/3.png) and ![<mml:math  ><mml:mi>R</mml:mi></mml:math>](img/4.png)
    , a join operation would have an ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>L</mml:mi><mml:mi>*</mml:mi><mml:mi>R</mml:mi><mml:mo>)</mml:mo></mml:math>](img/5.png)
    time complexity. Applying this logic   to the preceding recursion, we’ll see   that
    the time complexity of the entire query is ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mi>*</mml:mi><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/6.png)
    or ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/7.png)
    .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的效率如何？最坏情况下的时间复杂度可以渐进地评估，并用**大 O 记法**表示。设 ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    为社交媒体平台上用户的数量，![
- en: Graph representation
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图形表示
- en: 'Now, let’s look at the graph representation for the same problem. Let each
    node of the graph represent a user and each edge connecting two nodes represent
    a first-degree connection between the users that the connected nodes represent.
    An illustration using *Table 1.1* would look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下这个问题的图形表示。图中的每个节点代表一个用户，连接两个节点的每条边代表这两个节点所代表的用户之间的一度连接。使用*表 1.1* 的示意图如下所示：
- en: '![Figure 1.2 – Representing data from Table 1.1 in a graph](img/B22118_01_2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 将表 1.1 中的数据表示为图](img/B22118_01_2.jpg)'
- en: Figure 1.2 – Representing data from Table 1.1 in a graph
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 将表 1.1 中的数据表示为图
- en: 'How do we find the answer to whether John and Mary have a second-degree connection
    here? We can employ an intuitive algorithm over this graph:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何找到约翰和玛丽是否有二度连接的答案呢？我们可以在这个图上应用一个直观的算法：
- en: '**Start from a source** : Begin at a chosen starting point, often called the
    *source* or **initial node** of the graph. This is your current position for exploration.
    For our use case, the initial node would be that of John.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从源点开始**：从选择的起始点开始，通常称为图的*源点*或**初始节点**。这是你当前的探索位置。在我们的用例中，初始节点将是约翰的节点。'
- en: '**Explore neighbors level by level** : Visit all the neighbors of the current
    node before moving on to their neighbors. Imagine exploring the graph in layers,
    moving outward one level at a time. This ensures that you discover all nodes at
    a certain distance before moving farther away.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**按层级探索邻居**：在进入它们的邻居之前，先访问当前节点的所有邻居。想象一下按层次探索图形，每次向外扩展一级。这确保你在继续探索更远的节点之前，先发现所有距离较近的节点。'
- en: '**Mark visited nodes** : As you visit each node, mark it as visited to avoid
    revisiting the same node. Use a queue to keep track of the order in which you
    encounter nodes. While marking the nodes, you can also keep track of how many
    jumps from the initial node were made to reach this node. Continue this process
    until you’ve visited all reachable nodes from the starting point.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标记访问的节点**：当你访问每个节点时，将其标记为已访问，以避免重新访问同一节点。使用队列来跟踪你遇到节点的顺序。在标记节点时，你还可以跟踪从初始节点跳跃到达该节点的次数。继续这个过程，直到访问到从起始点能够到达的所有节点。'
- en: 'In simpler terms, this algorithm explores the graph by gradually moving away
    from the starting point, checking neighboring nodes level by level, and keeping
    track of visited nodes to avoid duplication. It’s like ripples spreading out from
    a pebble dropped in a pond, exploring nearby areas before moving to more distant
    ones. This algorithm is called **breadth-first search** ( **BFS** ), and it’s
    one of the most popular graph algorithms:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这个算法通过逐渐远离起始点来探索图，逐层检查相邻节点，并跟踪已访问的节点以避免重复。这就像一颗小石子落入池塘，产生的涟漪先向周围扩散，然后再向更远的地方扩展。这个算法叫做**广度优先搜索**（**BFS**），它是最流行的图算法之一：
- en: '![Figure 1.3 – Running BFS on the graph](img/B22118_01_3.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 在图上运行 BFS](img/B22118_01_3.jpg)'
- en: Figure 1.3 – Running BFS on the graph
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 在图上运行 BFS
- en: By using this algorithm, if Mary’s node is marked as visited and has a jump
    count of *2* , then we can safely say that John and Mary have a second-degree
    connection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个算法，如果玛丽的节点被标记为已访问，并且跳数为*2*，那么我们可以放心地说，约翰和玛丽有二度连接。
- en: What’s the time complexity of BFS? As mentioned previously, the number of users
    is assumed to be ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png) , and
    the number of first-degree connections is ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png)
    . Effectively, BFS touches all vertices and edges of the graph at most once, so
    the time complexity is simply ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/10.png)
    . In a practical scenario, the number of connections far outweighs the number
    of users on the platform, so the time complexity can be approximated to ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/11.png)
    .
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: BFS 的时间复杂度是多少？如前所述，用户的数量假定为 ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    ，一度连接的数量为 ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png) 。实际上，BFS 至多访问图中的所有顶点和边一次，所以时间复杂度就是简单的
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/10.png)
    。在实际场景中，连接数远远超过平台上的用户数，因此时间复杂度可以近似为 ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/11.png)
    。
- en: Is ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/12.png)
    better than ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/13.png)
    ? Definitely. We can see that just by changing the perspective of approaching
    the problem, we achieve a much more efficient solution. To further test your understanding,
    think of a scenario where the problem was kept the same, except you now have to
    check whether John and Mary were third-degree connections instead of second-degree
    connections. How would the time complexities of both approaches be affected?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 是 ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/12.png)
    比 ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/13.png)
    更好吗？当然好。我们可以看到，通过改变问题的解决方法视角，我们可以实现一个更高效的解决方案。为了进一步测试你的理解，假设问题保持不变，只是你现在需要检查约翰和玛丽是否为三度连接，而不是二度连接。那么这两种方法的时间复杂度会受到什么影响？
- en: Graphs are useful in practice. But before we talk about how certain properties
    of graphs and algorithms are used to solve graph problems, we need to define a
    common language that we can use to refer to graphs and their properties. The following
    section will cover how graphs are commonly defined in mathematics, and how a simple
    representation can cover all the different types of data that graphs can represent.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图在实际应用中非常有用。但在我们讨论图的某些属性和算法如何用于解决图问题之前，我们需要定义一种通用语言，用来指代图及其属性。以下部分将介绍数学中图的常见定义，以及如何通过简单的表示方式涵盖图所能表示的所有不同类型的数据。
- en: Formalizing graphs
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的形式化
- en: Graphs are a very popular concept in mathematics. In this domain, a common terminology
    is well accepted. Let’s take a closer look.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图是数学中非常流行的概念。在这个领域，常用的术语已经得到了广泛的接受。让我们仔细看一下。
- en: Definition and semantics
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和语义
- en: With the argument being made for graph representations to be a relevant topic
    for practical problems, let’s take a moment to define what a graph is. A graph
    is an abstract concept. Mathematically, it’s generally repre sented as ![<mml:math  ><mml:mi>G</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/14.png)
    , where ![<mml:math  ><mml:mi>G</mml:mi></mml:math>](img/15.png) is the graph,
    which contains a set of vertices, ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    , and a set of edges, ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/17.png)
    . Each element of ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/17.png) is
    a tuple, ![<mml:math  ><mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>,</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math>](img/19.png)
    , where ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>,</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:math>](img/20.png)
    , and represents a connection between the two vertices. That’s all there is to
    the mathematical definition; how you choose to apply semantics to this is completely
    up to you.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example mentioned in the previous section, the users of the social media
    platform were represented by the vertices, and the connection between the two
    users was represented by the edges. Also, vertices and edges need not be so homogeneous.
    Consider the graph representation of a home network:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – A classic heterogeneous graph, where there are multiple types
    of elements represented as nodes. There is also heterogeneity in the interactions
    represented by edges](img/B22118_01_4.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – A classic heterogeneous graph, where there are multiple types of
    elements represented as nodes. There is also heterogeneity in the interactions
    represented by edges
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the nodes represent all entities present in the home network, from human
    users to **Internet of Things** ( **IoT** ) devices, routers, and smart TVs. The
    semantics of the edges range from interaction to network communication and media
    streaming. Formally, the set of vertices and edges can be defined as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Graph representations can be further supercharged by adding more information
    specific to the nodes or edges. A popular way to represent this information is
    by using a feature vector. We’ll learn more about how node and edge features can
    be added in future chapters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaway here is that graphs are an incredibly powerful way of representing
    facts. With this definition at hand, let’s try to investigate a few derived characteristics
    of graphs. Certain characteristics of graphs imply certain high-level facts about
    how the nodes and edges in the graph are organized. The next section focuses on
    a few such popular properties and graph types.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是，图是一种非常强大的事实表示方式。理解了这个定义后，我们可以尝试探讨一些图的派生特性。图的某些特性暗示了关于图中节点和边如何组织的高层次事实。接下来的部分将重点介绍几种流行的图属性和类型。
- en: Types and properties of graphs
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的类型和属性
- en: Several types of graphs have been identified, each with its unique properties,
    but we’ll focus on the ones that are most popular. Note that these types need
    not be mutually exclusive, meaning a graph can be labeled as more than one type
    at a time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 已识别出几种类型的图，每种图都有其独特的属性，但我们将重点讨论最流行的几种。请注意，这些类型不一定是互斥的，也就是说，一个图可以同时标记为多种类型。
- en: Directed graphs
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有向图
- en: Graphs are **directed** when the edges have a one-way relationship between their
    connecting nodes. There are many scenarios where the relationship that’s represented
    is unidirectional. In a graph representing a family tree, an edge might represent
    the relation “ *is a parent of,* ” and another might represent the relation “
    *is a pet of.* ” Such relationships can’t be inverted between the nodes and hold
    the same meaning.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当图的边具有单向关系时，图就是**有向图**。许多场景中，表示的关系是单向的。在表示家谱的图中，一条边可能代表“*是父母*”的关系，而另一条边可能代表“*是宠物*”的关系。这样的关系无法在节点之间倒转，并且保持相同的含义。
- en: Bipartite graphs
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分图
- en: A **bipartite graph** is a type of graph whose vertices can be divided into
    two disjoint sets such that every edge connects a vertex from one set to a vertex
    in the other set. In other words, there are no edges that connect vertices within
    the same set. Mathematically, a graph, ![<mml:math  ><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/21.png)
    , is bipartite if the vertex set, ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    , is partitioned into two non-empty sets, ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/23.png)
    and ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/24.png)
    , such that every edge in ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/25.png)
    connects a vertex in ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/26.png)
    to a vertex in ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/27.png)
    .
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**二分图**是一种图，其顶点可以被划分为两个不相交的集合，使得每条边都连接一个集合中的顶点和另一个集合中的顶点。换句话说，图中没有连接同一集合内顶点的边。从数学上讲，图，![<mml:math  ><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/21.png)，是二分图当且仅当顶点集![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)被划分为两个非空集合，![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/23.png)和![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/24.png)，使得图中每条边![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/25.png)都连接![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/26.png)中的一个顶点和![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/27.png)中的一个顶点。'
- en: Bipartite graphs are often denoted as ![<math ><mrow><mrow><mrow><msub><mrow><mi>G</mi><mo>(</mo><mi>V</mi></mrow><mn>1</mn></msub><mo>,</mo><msub><mi>V</mi><mn>2</mn></msub><mo>,</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/28.png)
    , where ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/29.png)
    and ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/30.png)
    are the two disjoint sets of vertices, and ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/31.png)
    is the set of edges connecting vertices from ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/32.png)
    to ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/33.png)
    One common application of bipartite graphs is in modeling relationships between
    two distinct types of entities, where edges represent connections or relationships
    between entities of different types.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Bipartite graphs occur very commonly in the wild. In e-commerce, **recommendation
    systems** , also known as **recommender systems** (see *Chapters 2* and *9* ),
    are built on bipartite graph data, where the nodes consist of users and items.
    The users and items never interact within their own kind; only interactions between
    users and items exist. This interaction can be in the form of clicks or orders
    of items made by the user:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – A classic example of a bipartite graph, from an e-commerce application](img/B22118_01_5.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – A classic example of a bipartite graph, from an e-commerce application
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a bipartite graph is the **marriage problem** , where vertices
    in one set represent men, vertices in the other set represent women, and edges
    represent marriages between couples. Another example is modeling interactions
    between customers and products in recommender systems.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Connected graphs
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fully **connected graphs** , also known as **complete graphs** , are graphs
    in which every pair of distinct vertices is connected by an edge, forming a network
    where each node is directly linked to every other node. They exhibit high connectivity
    but can become computationally intensive as the number of nodes increases.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Weighted graphs
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graphs can also be appended with additional information on both the nodes and
    edges. When the edges are added as scalar additional information, the graph is
    said to be **weighted** .
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: While on the topic of graph types, let’s complete our discussion by introducing
    a few commonly noted properties of graphs. These aren’t labels that are attached
    to graphs, as we discussed previously regarding the different types of graphs,
    but certain measures or attributes of graphs that are agnostic of the type of
    graph under concern.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Subgraphs
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **subgraph** is a graph that’s formed from a subset of the vertices and edges
    of the original graph. More formally, let ![<mml:math  ><mml:mi>G</mml:mi></mml:math>](img/34.png)
    be a graph with vertex set ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    and edge set ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png) . A subgraph
    of ![<mml:math  ><mml:mi>G</mml:mi></mml:math>](img/34.png) is a graph, ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mi>'</mml:mi></mml:math>](img/38.png)
    , such that ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi><mml:mo>(</mml:mo><mml:mi>G</mml:mi><mml:mi>'</mml:mi><mml:mo>)</mml:mo></mml:math>](img/39.png)
    is a subset of ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/40.png) and E(
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mi>'</mml:mi><mml:mo>)</mml:mo></mml:math>](img/41.png)
    is a subset of ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png) . Often,
    searching for subgraphs with useful properties such as being bipartite, or connected,
    is an important step for the bigger problem at hand.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Centrality
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Centrality** is a measure in graph theory that quantifies the importance
    or influence of a node within a network. Nodes with high centrality are more central
    to the network, playing a more significant role in its structure and dynamics.
    There are several centrality measures, each capturing different aspects of a node’s
    importance. Here are some common centrality measures:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**Degree centrality** : The degree centrality of a node is the number of edges
    connected to it (that is, the number of neighbors it has). Nodes with a high degree
    of centrality are well-connected and may play a crucial role in spreading information
    or influence.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closeness centrality** : Closeness centrality measures how close a node is
    to all other nodes in the network. It’s the reciprocal of the sum of the shortest
    path distances from a node to all other nodes. Nodes with high closeness centrality
    can quickly interact with other nodes and are often central in terms of communication
    efficiency.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Betweenness centrality** : Betweenness centrality quantifies the number of
    shortest paths that pass through a node. A node with high betweenness centrality
    has a significant influence on communication between other nodes. Nodes with high
    betweenness centrality act as bridges or gatekeepers in the network, controlling
    the flow of information.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eigenvector centrality** : Eigenvector centrality considers not only the
    number of connections a node has but also the centrality of its neighbors. It’s
    based on the principle that connections to high-scoring nodes contribute more
    to a node’s centrality. Nodes with high eigenvector centrality are connected to
    other central nodes, making them important in the overall network structure.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PageRank** : PageRank is a centrality measure that’s used in web search algorithms
    (for example, Google’s PageRank). It assigns importance to a node based on both
    the number and quality of its incoming links. Nodes with high PageRank are considered
    influential as they are linked to other important nodes.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centrality measures help identify key nodes in a network, which can be important
    for understanding information flow, identifying influential individuals, or targeting
    nodes for interventions in various applications such as social networks, transportation
    systems, and biological networks. Different centrality measures may be appropriate,
    depending on the specific context and goals of the analysis.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Community structure
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In terms of graphs, **community structure** refers to dividing a network or
    graph into groups or clusters of nodes that are densely connected internally but
    have fewer connections between groups. Nodes within a community are more likely
    to share similar properties, interests, or functions, and identifying community
    structure is a fundamental aspect of analyzing the organization and dynamics of
    complex networks. Detecting communities in a graph is crucial for understanding
    the modular organization of the system and can have applications in various fields,
    including social network analysis, biology, and information retrieval.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Isomorphism
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Isomorphism** is a concept in graph theory that deals with the structural
    similarity between two graphs. Two graphs are considered isomorphic if a one-to-one
    correspondence exists between their vertices such that the adjacency relationships
    are preserved. In other words, the graphs are essentially the same from a structural
    point of view, even if the vertex and edge labels may differ.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Graph isomorphism is a fundamental problem in computer science and has applications
    in various areas, such as chemistry, computer-aided design, and pattern recognition.
    Despite its practical importance, finding a fast algorithm for graph isomorphism
    has proven to be a challenging problem, and it remains an open question whether
    such an algorithm exists with polynomial time complexity:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – G and H are isomorphic graphs. To understand this, notice the
    mapping: g1→h1, g2→h2, g3→h3, and so on](img/B22118_01_6.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6 – G and H are isomorphic graphs. To understand this, notice the
    mapping: g 1 →h 1 , g 2 →h 2 , g 3 →h 3 , and so on'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The properties of specialized graphs can be exploited to derive further insights
    into the scenarios represented by these graphs. Now, let’s take a look at how
    graphs can be fed into machines so that they can be read algorithmically.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Graph data structures
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How should we feed graph data into computer programs so that we can apply graph-based
    algorithms to solve problems? This will be addressed in this section. Each representation
    has its advantages and disadvantages, and we’ll explore them from the perspective
    of the time complexity of determining whether an edge exists and updating the
    graph.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrix
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **adjacency matrix** aims to record the graph structure via a matrix. A
    matrix, say ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/43.png) , of size
    ![<mml:math  ><mml:mi>v</mml:mi><mml:mo>×</mml:mo><mml:mi>v</mml:mi></mml:math>](img/44.png)
    is created (where ![<mml:math  ><mml:mi>v</mml:mi></mml:math>](img/45.png) denotes
    the number of nodes, or mathematically, ![<mml:math  ><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:math>](img/46.png)
    ). We start with all entries of ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/47.png)
    being 0. Next, if ![<mml:math  ><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/48.png)
    , ![<mml:math  ><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:math>](img/49.png)
    , then element ![<mml:math  ><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:math>](img/50.png)
    of ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/47.png) is labeled * 1 * .
    If the graph is undirected, then if ![<mml:math  ><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/52.png)
    , ![<mml:math  ><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:math>](img/53.png)
    , then both elements of ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/43.png)
    , ![<mml:math  ><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:math>](img/55.png)
    , and ![<mml:math  ><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:math>](img/56.png)
    , are labeled * 1 * .
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity to check whether an edge exists in an adjacency matrix is
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/57.png)
    since it just involves checking a particular cell in the matrix. However, adding
    a new vertex to the graph would be difficult, and depending on the matrix implementation,
    it might need an entirely new initialization. Finally, the space complexity of
    the adjacency matrix is also large, in the order of ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/58.png)
    . Sparse matrix implementations exist, which might reduce the space required by
    the matrix in memory, but they come with their own set of drawbacks. Adjacency
    matrices are a good choice when the graph is fairly small and   static and   also
    requires frequent lookup.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency list
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another popular data structure that’s used to store graph data is an **adjacency
    list** . It contains a dictionary that has keys as node names, and each entry
    contains a list of all nodes connected to the key node with an edge. Unlike adjacency
    matrices, whose space complexity is ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/59.png)
    , adjacency lists have a space complexity of ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo></mml:math>](img/60.png)
    ). However, adjacency lists are far more flexible with efficient time complexities
    for many data-related tasks. Inserting vertices and edges is ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/61.png)
    ; accessing neighbors takes ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/62.png)
    as well, while finding whether an edge exists or not can take ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>)</mml:mo></mml:math>](img/63.png)
    time. Adjacency lists are a good choice when the graph is inherently sparse:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – For the given graph, G, M and L are the adjacency matrix and
    list, respectively](img/B22118_01_7.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – For the given graph, G, M and L are the adjacency matrix and list,
    respectively
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve talked about adjacency matrices and adjacency lists as the two
    most popular data structures that are used to represent graphs in algorithms.
    However, several other graph data structures can be used based on the problem
    statement. Each graph data structure has its own set of advantages and disadvantages,
    and this serves as a great domain on which further research can be performed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Traditional graph-based solutions
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many computer scientists have etched their names in history by devising elegant
    solutions to seemingly complex problems involving graphs. However, graphs aren’t
    just confined to the algorithm books, and graph-based problems are common in the
    wild. Lots of business problems and scientific research can be boiled down to
    graph-based problems, on which existing solutions can be implemented to generate
    the required output. In this section, we’ll talk about the most popular problems
    in the domain of graphs, a few approaches to solving them, and where these problems
    are encountered in practical scenarios.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Searching
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two fundamental approaches when performing a search over a graph:
    breadth-first and depth-first. Both are means to traverse a graph from a starting
    point to all nodes that can be reached from the initial node, but the differentiating
    factor is their approach.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In BFS, the algorithm explores a graph level by level, starting from the source
    vertex and visiting all its neighbors before moving on to the next level. This
    approach ensures that nodes closer to the source are visited before deeper nodes.
    On the other hand, **depth-first search** ( **DFS** ) explores a graph by going
    as deep as possible along each branch before backtracking. It explores one branch
    of the graph until it reaches the end before moving on to the next branch.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: BFS is well-suited for finding the shortest path in unweighted graphs and is
    commonly used in network routing protocols and social network analysis. DFS, with
    its deep exploration, is useful in topological sorting, cycle detection, and solving
    problems such as maze exploration and puzzle-solving.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of search algorithms, let’s look at another
    class of problems, called **partitioning** . The need to understand graph partitions
    occurs frequently in practice.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In graph theory, partitioning refers to dividing the vertices or edges of a
    graph into disjoint subsets or components. The goal of partitioning is to group
    elements of the graph in such a way that certain properties are satisfied, or
    specific objectives are achieved. There are different types of graph partitioning,
    and the choice of partitioning criteria depends on the application or problem
    at hand:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex partitioning** : This involves dividing the set of vertices of a graph
    into disjoint subsets. Vertex partitioning is done to achieve balance in terms
    of the number of vertices in each subset. This is a problem that’s commonly encountered
    in load balancing in parallel computing, network design, and social network analysis.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge partitioning** : As the name suggests, this involves dividing the set
    of edges of a graph into disjoint subsets. Just like vertex partitioning, the
    objective here is to balance the number of edges or the total weight of edges
    in each subset. Edge partitioning problems generally find application in communication
    optimization in distributed computing, minimizing inter-partition communication.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph cut** : This involves partitioning a graph by removing a minimum number
    of edges. This is done to minimize the cut size (total weight of removed edges)
    while achieving certain constraints. Applications include image segmentation and
    community detection in social networks.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**K-way partitioning** : This is a generalization of the aforementioned ideas
    and involves dividing the vertices or edges into ![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/64.png)
    disjoint subsets. We find k-way partitioning problems where we need to achieve
    balance in terms of the number of elements in each of the ![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/64.png)
    subsets, such as in domains such as ** very-large-scale integration ** ( ** VLSI
    ** ) design   and parallel computing. You can read more here: [ https://patterns.eecs.berkeley.edu/?page_id=571
    ](https://patterns.eecs.berkeley.edu/?page_id=571) .'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph partitioning problems are often NP-hard, meaning finding an optimal solution
    may be computationally intractable for large graphs. Therefore, various heuristics,
    approximation algorithms, and optimization techniques are employed to find good
    solutions in a reasonable amount of time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Another important problem in the domain of graphs is path optimization, and
    a lot of supply chain businesses and network researchers have been traditionally
    interested in solutions to such problems.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Path optimization
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two common problems in graph theory are finding the shortest path and finding
    the widest path between two nodes in a weighted graph. Their applications are
    obvious and involve route optimization in supply chains and social network analysis
    (the problem mentioned in the preceding case study can also be viewed as a shortest
    path problem between the two nodes, especially if a slight modification was made
    by needing the edges to be weighted).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The widest path problem is a variant of the shortest path problem. Formally,
    the problem is defined thus: given a weighted graph, the widest path problem seeks
    a path from a source vertex to a target vertex such that the minimum edge weight
    (bottleneck) along the path is maximized. This can be particularly relevant in
    network design or communication systems, where the goal is to maximize the capacity
    of the bottleneck link.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular solution to find the shortest path between two nodes is **Dijkstra’s
    algorithm** . While not diving too much into the details, here’s a short step-by-step
    summary of the algorithm:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization** :'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start at the source vertex.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign a tentative distance of 0 to the source and infinity to all other vertices.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark all vertices as unvisited.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Iterative exploration** :'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the unvisited vertex with the smallest tentative distance.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For the selected vertex, consider all its neighbors.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the tentative distance of each neighbor by adding the distance from the
    current vertex.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the updated distance is smaller than the current tentative distance, update
    it.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark the current vertex as visited.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Termination** :'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the iterative process until the destination vertex is visited or all
    vertices have been visited.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The final assigned distances represent the shortest paths from the source to
    all other vertices.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reconstruct the shortest path by backtracking from the destination to the source
    using the information that was stored about the shortest distances.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In summary, Dijkstra’s algorithm explores the graph in a step-by-step manner,
    always choosing the vertex with the smallest tentative distance. It gradually
    builds up the shortest paths from the source to all other vertices while marking
    visited vertices. The final result is a set of shortest distances and paths from
    the source to all other vertices in the graph. The widest path problem can also
    be solved by the same algorithm, but instead of maintaining the smallest tentative
    distance per node, we maintain the bottleneck weight (or the maximum of the minimum
    weights across all paths). The time complexity of this algorithm depends heavily
    on the implementation used, and the complexity ranges from ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>*</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/66.png)
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>*</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/67.png)
    to ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/68.png)
    . Dijkstra’s algorithm fails when the edge weights are negative, however, and
    is also inefficient if the graph is nearly fully connected. In such scenarios,
    alternatives such as the ** Bellman-Ford ** ** algorithm ** can   be used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of what kind of analytics are performed
    on graph data, let’s look at another powerful way of learning patterns within
    graph data. The core ideas of representation learning are described in the following
    section; we’ll learn how representation learning is an important first step for
    solving many complex problems involving graphs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The need for representation learning
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we’ll introduce a new concept called **representation learning for graphs**
    . Let’s use a small analogy to understand what this means. A typical corporate
    organization has several entities: employees, IT equipment, offices, and so on.
    All these entities maintain different types of relationships with each other:
    employees can be related to each other based on organizational hierarchy; one
    employee may use several pieces of IT equipment; several pieces of equipment,
    such as servers, can be networked with each other; employees and equipment can
    report physically or be located in a particular office, respectively; and so on.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'A graph, quite rightly, seems like a natural way to represent this information,
    like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – A graph showing the different entities in an organization interacting
    with each other](img/B22118_01_8.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – A graph showing the different entities in an organization interacting
    with each other
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Graphs are very visually intuitive. However, performing algorithmic calculations
    on graphs isn’t trivial. Could we find a way to capture the characteristics as
    well as the relationship information of each entity as much as possible, but within
    some common fields? Consider a sort of unique ID card for each entity that contains
    the following fields: Name, Sub-Organization, Date of Initiation, Years in Industry,
    and Geographic Location. So, a few ID cards may look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Examples of a few ID cards with the same fields for all entities](img/B22118_01_9.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Examples of a few ID cards with the same fields for all entities
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you’re presented with a set of ID cards of all entities and not the
    preceding graph, could you answer questions such as which employee reports to
    whom? Alternatively, which ID card is that of an employee, which of the office,
    and which of a piece of IT equipment? It’s not easy (or completely feasible) to
    determine the answers to such questions using just the information in the ID cards,
    but we can get close to the correct answer. To answer whether an employee is under
    some other employee in the hierarchy, we can check whether both employees have
    the same **Sub-Organization** and **Geographic-Location** values and whether the
    employee higher in the hierarchy has a higher **Years-in-Industry** value than
    the other. Guessing whether an ID card belongs to an office might simply mean
    checking whether the **Sub-Organization** value of the entity is blank, and so
    on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: While this approach sounds non-intuitive at first, using such heuristics to
    try to answer these practical questions based simply on the ID cards, and not
    the graph, can be performed efficiently by computers and modern-day implementations.
    The ID card here tries to *represent* the characteristics of the entities and
    relationships in the graph.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: More formally, the ID cards in the preceding example are vector embeddings of
    a fixed dimension that’s associated with each node of the graph. A learning algorithm
    is applied that tries to capture as much information present in the graph structure
    within these embeddings. These sets of embeddings are then used to answer difficult
    questions regarding the graph, instead of relying on the original graph itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Why should we try to learn representations? What benefits do working with embeddings
    present over working with the original graph in itself? Let’s take a look:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability** : Traditional graph algorithms can become computationally expensive
    and impractical for large-scale graphs. Representation learning allows compact
    embeddings to be generated that capture essential graph information, enabling
    more scalable and efficient computations.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task flexibility** : Representation learning produces embeddings that are
    task-agnostic, meaning they can be used for a variety of downstream tasks. Traditional
    graph algorithms are often designed for specific problems, and adapting them to
    different tasks might be challenging. Embeddings provide a more flexible and versatile
    way to approach diverse tasks.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incorporating node and edge features** : Many real-world graphs come with
    additional features associated with nodes and edges. Representation learning methods
    can naturally incorporate these features into the learning process, allowing for
    a more comprehensive understanding of the graph’s characteristics. Traditional
    graph algorithms might not easily integrate external features.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling dynamic graphs** : Representation learning is well-suited for dynamic
    graphs where the structure evolves. The learned embeddings can capture temporal
    patterns and changes, providing a more adaptive approach compared to traditional
    graph algorithms, which might not inherently address temporal aspects.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generalization to unseen data** : Representation learning aims to generate
    embeddings that generalize well to unseen data. This is particularly useful in
    scenarios where the graph structure is not completely known or is subject to change.
    Traditional graph algorithms may not generalize as effectively to new or unseen
    graph instances.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Noise robustness** : Embeddings can be more robust to noisy or incomplete
    graph data. Traditional graph algorithms may be sensitive to noise, but representation
    learning methods can learn to ignore irrelevant information and focus on the most
    informative aspects of the graph.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with machine learning models** : Representation learning facilitates
    the integration of graph data with machine learning models. The learned embeddings
    can serve as input features for various machine learning tasks, allowing practitioners
    to leverage the power of both graph-based and non-graph-based algorithms in a
    unified framework.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By capturing essential information in compact embeddings, it becomes more feasible
    to apply machine learning techniques to graph-structured data and address a wide
    range of tasks efficiently.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: GNNs and the need for a separate vertical
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We won’t dive into the details of what GNNs do or how they differ from other
    popular neural network architectures in this chapter. Here, we’ll merely attempt
    to explain why there’s a need to study GNNs separately from other deep learning
    architectures.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Before talking about the differences, we must discuss the similarities. GNNs
    are an architecture choice that’s specialized for processing graph data and outputting
    representations or node embeddings. Similar to how convolutional networks are
    fundamental for reading pixel data, the set of architectures under GNNs are optimized
    for reading graph data. GNN-based learning tasks follow the same trajectory as
    other deep learning solutions: to iteratively optimize the parameters of the model
    so that a loss function can be minimized. In the case of GNNs, the loss function
    often tries to capture and preserve meaningful information about the graph structure.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s have a look at the differences, and why GNNs require special attention:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**Irregular graph structures** : Graphs can have irregular and varying structures,
    with nodes having different numbers of neighbors. This irregularity poses challenges
    for traditional deep learning architectures, which often assume fixed input sizes.
    For example, in a social network, individuals may have varying numbers of connections
    (friends, followers, and so on).'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permutation invariance** : The order of nodes in a graph shouldn’t affect
    the output of a GNN. Achieving permutation invariance is crucial to ensure that
    the model can generalize across different node orders. A good example of permutation
    invariance is in molecular graphs in chemistry. The properties of a molecule depend
    only on its structure, not the order in which the atoms are labeled.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph isomorphism problem** : Determining whether two graphs are isomorphic
    is a computationally complex problem. GNNs need to be able to capture and differentiate
    between different graph structures.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node and graph classification** : GNNs often need to perform tasks such as
    node classification or graph classification. These tasks require the model to
    capture both local and global information from the graph, which can be challenging.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling different types of edges** : Graphs may have different types of
    edges, each representing a different kind of relationship between nodes. GNNs
    need to be able to model and leverage this heterogeneity in edge types.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pooling and aggregation** : Aggregating information from neighbors in a graph
    is a fundamental operation in GNNs. Designing effective pooling and aggregation
    strategies to capture important information while avoiding information loss or
    redundancy is a challenge. A good example is when recommendation systems pool
    information from the user’s friends’ preferences. The representations should capture
    this pooling idea as well.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capturing long-range dependencies** : GNNs need to capture long-range dependencies
    in graphs. Unlike sequential data in **recurrent neural networks** ( **RNNs**
    ), where dependencies are often local, graphs may have dependencies that span
    long distances.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpretable representations** : Understanding and interpreting the learned
    representations in GNNs is crucial, especially in applications where interpretability
    is essential. Interpretability is crucial in medical diagnosis with electronic
    health records. GNNs can be used to analyze patient records where nodes represent
    different health parameters. Interpretable representations are crucial for healthcare
    professionals to understand and trust the model’s decision-making process in diagnosing
    diseases or predicting patient outcomes.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNNs provide a lot of the benefits that machine learning approaches have in
    terms of boosting our capabilities with tabular data, but in terms of graph data.
    There are several important implications of using GNNs as an intermediary step
    to solve relevant problems related to graphs. We’ll explore more such topics in
    the coming chapters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the foundational concepts in graph learning and
    representation. We began with motivating examples of how graph structures naturally
    capture relationships between entities, making them a powerful data representation.
    Then, formal definitions of graphs, common graph types, and key properties were
    discussed. We also looked at popular graph algorithms such as searching, partitioning,
    and path optimization, along with their real-world use cases.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: A key idea presented here was the need for representation learning on graphs.
    Converting graph data into vector embeddings allows us to leverage the capabilities
    of machine learning models. Benefits such as scalability, flexibility, and robustness
    make graph embeddings an enabling technique.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we justified the need for specialized GNN architectures. Factors such
    as irregular structure, permutation invariance, and complex operations such as
    aggregation and pooling necessitate tailored solutions. GNNs open up new possibilities
    for learning from relational data across domains.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll discuss how graph learning is applied in practice.
    There are several levels to graph learning and representation, and all of them
    have business and academic significance. The topics covered here will act as a
    foundation for your understanding of the concepts in the chapters that follow.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
