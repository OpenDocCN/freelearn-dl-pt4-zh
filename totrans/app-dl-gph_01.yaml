- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Graph Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph data is a powerful and intuitive way of expressing information, and several
    practical scenarios can be better expressed using graph data than tabular approaches.
    Analyzing graph data has been a topic of study for decades, but it has only recently
    begun to capture the limelight due to advances in compute capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we aim to introduce you to the world of **graphs** . Here, we’ll
    begin by discussing what graph data is and the fundamental mathematical terminologies
    surrounding graphs. Next, we’ll take a small detour and discuss some common graph
    algorithms and their applications in graph data analytics. We’ll extend our discussion
    on graph data analytics to the requirement of graph deep learning and why it stands
    as a specialized subdomain compared to applying existing architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we need graphs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formalizing graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types and properties of graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditional graph-based solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for **representation learning**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph neural networks** ( **GNNs** ) and the need for a separate vertical'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need graphs?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recent **artificial intelligence** ( **AI** ) revolution is the tip of the
    iceberg of a megatrend that has been impacting the computing industry for decades
    now. Over time, computing performance has increased exponentially against power
    consumed and cost; information storage costs have also decreased exponentially.
    To put this into perspective, while a terabyte of data can be stored in a disk
    costing around 100 US dollars in 2024, it would have taken more than a million
    dollars in the early 1990s!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using computers and their derivative products, such as software, web applications,
    games, and multimedia content, has become deeply tied to our normal lifestyle.
    This dependence led to the need for understanding the behavior of all the interacting
    entities: humans, computer hardware, software such as web applications, and even
    organizations as a whole. The end goal was to find ways to make interactions more
    efficient, which could lead to unprecedented business opportunities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, given the constraints of the time, the information that was collected
    was less organized and the recorded truth provided a very high-level overview
    of systems, and only about a handful of variables within the system (for data
    scientists, think of data at aggregated levels, and with a small number of dimensions).
    At some point, someone realized computing power and data storage were cheap enough
    that you could record facts more granularly: not only could individual scenarios
    be recorded separately and more frequently, but other variables could also be
    recorded every time a snapshot was taken. The data revolution had begun, and stakeholders
    realized that by capturing and reviewing enough data about these interacting entities,
    a holistic picture of their behavior in the ecosystem could be drawn. The 2010s
    were spent commoditizing data and its products, to the point that even Series
    A-funded startups have adopted a data solution: be it warehousing, Elasticsearch,
    or recommendation engines.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking a step back, let’s understand what data means. A data point is essentially
    just a factual statement. Very little discussion exists *on how the fact is represented
    in the data* . The de facto representation of data is tabular, and this has generally
    worked well for the capabilities built around the current data ecosystem. The
    focus on data science research and engineering has revolved around existing database
    architectures, which is why the tabular form of representation is the most widespread.
    However, the tabular form need isn’t the only form of representation. The purpose
    of this chapter is to build a case around the graph form of representation and
    why graph representations can be the best option for several practical scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Graph data is represented using **nodes** (also called objects, vertices, or
    nouns) and **edges** (also called relationships, links, or verbs). Certain real-life
    scenarios necessitate emphasizing the relationships between the objects rather
    than just treating each object as an independent entity. Graph data structures
    provide us with a natural way to express these scenarios, as opposed to something
    such as the tabular format. Using the simple construct of treating entities as
    nodes and relationships as edges between two nodes, graph representations can
    effectively model information from a wide range of domains: from network topology
    to biological systems and supply chains to molecular structure.'
  prefs: []
  type: TYPE_NORMAL
- en: A case study
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make this point clearer, let’s consider a common question that arises in
    social networks. For a user (say John), we want to ascertain whether another user
    (say Mary) is a second-degree connection (to John). A second-degree connection
    simply means Mary and John have a common connection, but Mary isn’t directly connected
    (is friends with) to John. The social media platform commonly tracks this piece
    of information between a pair of users and determines whether they should be recommended
    by the platform to connect. We’ll tackle this problem from two perspectives: first
    using the tabular representation, and then using the graph representa tion.'
  prefs: []
  type: TYPE_NORMAL
- en: Tabular representation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we need to understand what the schema of the tables in the database
    would be. In a typical social media platform database, there would be several
    tables – one for users (capturing demographic information such as age, location,
    date of joining, and so on), one for posts (containing details about a post made,
    such as the user who made the post, the contents of the post, the date of making
    the post, the visibility level, and so on), and many more. The table of concern
    for us would be something called the **connections table** . It should capture
    information about which users are connected directly (that is, they have a first-degree
    connection). The schema should go somewhat like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Table 1.1* shows a table that contains a few data points:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **conn_id** | **user_id_1** | **user_id_2** | **date_of_conn** | **status_of_conn**
    |'
  prefs: []
  type: TYPE_TB
- en: '| conn_uuid_0 | john_uuid | alex_uuid | 2022-10-30 | active |'
  prefs: []
  type: TYPE_TB
- en: '| conn_uuid_1 | alex_uuid | greg_uuid | 2023-03-12 | active |'
  prefs: []
  type: TYPE_TB
- en: '| conn_uuid_2 | greg_uuid | mary_uuid | 2023-04-11 | active |'
  prefs: []
  type: TYPE_TB
- en: '| conn_uuid_3 | mary_uuid | alex_uuid | 2023-06-09 | active |'
  prefs: []
  type: TYPE_TB
- en: Table 1.1 – Example data stored in tabular format
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine whether John and Mary have a second-degree connection, a SQL query
    similar to the following can be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – A SQL query being performed over tables that were introduced
    previously to retrieve second-degree connections](img/B22118_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – A SQL query being performed over tables that were introduced previously
    to retrieve second-degree connections
  prefs: []
  type: TYPE_NORMAL
- en: The crux of this query contains a recursive self-join operation, where each
    recursion level contains the connections of a certain degree. The initial filter
    of **user_id_1 =** **'john_uuid'** OR **user_id_2 = 'john_uuid'** ensures that
    we only concern ourselves with users who are on some level and connected to John.
    Finally, by filtering by **degree = 2** , we can get the list of all users who
    have a second-degree connection to John.
  prefs: []
  type: TYPE_NORMAL
- en: How efficient is this approach? The worst-case time complexity can be evaluated
    asymptotically and expressed in **Big-O notation** . Let ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    be the count of users present on the social media platform and ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png)
    be the count of all first-degree connections (or the number of entries in the
    connections table). Join algorithms have evolved, and current join operations
    are very efficient, but if we look at the naive approach, where two tables have
    lengths ![<mml:math  ><mml:mi>L</mml:mi></mml:math>](img/3.png) and ![<mml:math  ><mml:mi>R</mml:mi></mml:math>](img/4.png)
    , a join operation would have an ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>L</mml:mi><mml:mi>*</mml:mi><mml:mi>R</mml:mi><mml:mo>)</mml:mo></mml:math>](img/5.png)
    time complexity. Applying this logic   to the preceding recursion, we’ll see   that
    the time complexity of the entire query is ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mi>*</mml:mi><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/6.png)
    or ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/7.png)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Graph representation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s look at the graph representation for the same problem. Let each
    node of the graph represent a user and each edge connecting two nodes represent
    a first-degree connection between the users that the connected nodes represent.
    An illustration using *Table 1.1* would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Representing data from Table 1.1 in a graph](img/B22118_01_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Representing data from Table 1.1 in a graph
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we find the answer to whether John and Mary have a second-degree connection
    here? We can employ an intuitive algorithm over this graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start from a source** : Begin at a chosen starting point, often called the
    *source* or **initial node** of the graph. This is your current position for exploration.
    For our use case, the initial node would be that of John.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Explore neighbors level by level** : Visit all the neighbors of the current
    node before moving on to their neighbors. Imagine exploring the graph in layers,
    moving outward one level at a time. This ensures that you discover all nodes at
    a certain distance before moving farther away.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mark visited nodes** : As you visit each node, mark it as visited to avoid
    revisiting the same node. Use a queue to keep track of the order in which you
    encounter nodes. While marking the nodes, you can also keep track of how many
    jumps from the initial node were made to reach this node. Continue this process
    until you’ve visited all reachable nodes from the starting point.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In simpler terms, this algorithm explores the graph by gradually moving away
    from the starting point, checking neighboring nodes level by level, and keeping
    track of visited nodes to avoid duplication. It’s like ripples spreading out from
    a pebble dropped in a pond, exploring nearby areas before moving to more distant
    ones. This algorithm is called **breadth-first search** ( **BFS** ), and it’s
    one of the most popular graph algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Running BFS on the graph](img/B22118_01_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Running BFS on the graph
  prefs: []
  type: TYPE_NORMAL
- en: By using this algorithm, if Mary’s node is marked as visited and has a jump
    count of *2* , then we can safely say that John and Mary have a second-degree
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the time complexity of BFS? As mentioned previously, the number of users
    is assumed to be ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png) , and
    the number of first-degree connections is ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png)
    . Effectively, BFS touches all vertices and edges of the graph at most once, so
    the time complexity is simply ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/10.png)
    . In a practical scenario, the number of connections far outweighs the number
    of users on the platform, so the time complexity can be approximated to ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/11.png)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Is ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/12.png)
    better than ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/13.png)
    ? Definitely. We can see that just by changing the perspective of approaching
    the problem, we achieve a much more efficient solution. To further test your understanding,
    think of a scenario where the problem was kept the same, except you now have to
    check whether John and Mary were third-degree connections instead of second-degree
    connections. How would the time complexities of both approaches be affected?
  prefs: []
  type: TYPE_NORMAL
- en: Graphs are useful in practice. But before we talk about how certain properties
    of graphs and algorithms are used to solve graph problems, we need to define a
    common language that we can use to refer to graphs and their properties. The following
    section will cover how graphs are commonly defined in mathematics, and how a simple
    representation can cover all the different types of data that graphs can represent.
  prefs: []
  type: TYPE_NORMAL
- en: Formalizing graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs are a very popular concept in mathematics. In this domain, a common terminology
    is well accepted. Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Definition and semantics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the argument being made for graph representations to be a relevant topic
    for practical problems, let’s take a moment to define what a graph is. A graph
    is an abstract concept. Mathematically, it’s generally repre sented as ![<mml:math  ><mml:mi>G</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/14.png)
    , where ![<mml:math  ><mml:mi>G</mml:mi></mml:math>](img/15.png) is the graph,
    which contains a set of vertices, ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    , and a set of edges, ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/17.png)
    . Each element of ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/17.png) is
    a tuple, ![<mml:math  ><mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>,</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math>](img/19.png)
    , where ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>,</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:math>](img/20.png)
    , and represents a connection between the two vertices. That’s all there is to
    the mathematical definition; how you choose to apply semantics to this is completely
    up to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example mentioned in the previous section, the users of the social media
    platform were represented by the vertices, and the connection between the two
    users was represented by the edges. Also, vertices and edges need not be so homogeneous.
    Consider the graph representation of a home network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – A classic heterogeneous graph, where there are multiple types
    of elements represented as nodes. There is also heterogeneity in the interactions
    represented by edges](img/B22118_01_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – A classic heterogeneous graph, where there are multiple types of
    elements represented as nodes. There is also heterogeneity in the interactions
    represented by edges
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the nodes represent all entities present in the home network, from human
    users to **Internet of Things** ( **IoT** ) devices, routers, and smart TVs. The
    semantics of the edges range from interaction to network communication and media
    streaming. Formally, the set of vertices and edges can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Graph representations can be further supercharged by adding more information
    specific to the nodes or edges. A popular way to represent this information is
    by using a feature vector. We’ll learn more about how node and edge features can
    be added in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaway here is that graphs are an incredibly powerful way of representing
    facts. With this definition at hand, let’s try to investigate a few derived characteristics
    of graphs. Certain characteristics of graphs imply certain high-level facts about
    how the nodes and edges in the graph are organized. The next section focuses on
    a few such popular properties and graph types.
  prefs: []
  type: TYPE_NORMAL
- en: Types and properties of graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several types of graphs have been identified, each with its unique properties,
    but we’ll focus on the ones that are most popular. Note that these types need
    not be mutually exclusive, meaning a graph can be labeled as more than one type
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Directed graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graphs are **directed** when the edges have a one-way relationship between their
    connecting nodes. There are many scenarios where the relationship that’s represented
    is unidirectional. In a graph representing a family tree, an edge might represent
    the relation “ *is a parent of,* ” and another might represent the relation “
    *is a pet of.* ” Such relationships can’t be inverted between the nodes and hold
    the same meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Bipartite graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **bipartite graph** is a type of graph whose vertices can be divided into
    two disjoint sets such that every edge connects a vertex from one set to a vertex
    in the other set. In other words, there are no edges that connect vertices within
    the same set. Mathematically, a graph, ![<mml:math  ><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/21.png)
    , is bipartite if the vertex set, ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    , is partitioned into two non-empty sets, ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/23.png)
    and ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/24.png)
    , such that every edge in ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/25.png)
    connects a vertex in ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/26.png)
    to a vertex in ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/27.png)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Bipartite graphs are often denoted as ![<math ><mrow><mrow><mrow><msub><mrow><mi>G</mi><mo>(</mo><mi>V</mi></mrow><mn>1</mn></msub><mo>,</mo><msub><mi>V</mi><mn>2</mn></msub><mo>,</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/28.png)
    , where ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/29.png)
    and ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/30.png)
    are the two disjoint sets of vertices, and ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/31.png)
    is the set of edges connecting vertices from ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/32.png)
    to ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/33.png)
    One common application of bipartite graphs is in modeling relationships between
    two distinct types of entities, where edges represent connections or relationships
    between entities of different types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bipartite graphs occur very commonly in the wild. In e-commerce, **recommendation
    systems** , also known as **recommender systems** (see *Chapters 2* and *9* ),
    are built on bipartite graph data, where the nodes consist of users and items.
    The users and items never interact within their own kind; only interactions between
    users and items exist. This interaction can be in the form of clicks or orders
    of items made by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – A classic example of a bipartite graph, from an e-commerce application](img/B22118_01_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – A classic example of a bipartite graph, from an e-commerce application
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a bipartite graph is the **marriage problem** , where vertices
    in one set represent men, vertices in the other set represent women, and edges
    represent marriages between couples. Another example is modeling interactions
    between customers and products in recommender systems.
  prefs: []
  type: TYPE_NORMAL
- en: Connected graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fully **connected graphs** , also known as **complete graphs** , are graphs
    in which every pair of distinct vertices is connected by an edge, forming a network
    where each node is directly linked to every other node. They exhibit high connectivity
    but can become computationally intensive as the number of nodes increases.
  prefs: []
  type: TYPE_NORMAL
- en: Weighted graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graphs can also be appended with additional information on both the nodes and
    edges. When the edges are added as scalar additional information, the graph is
    said to be **weighted** .
  prefs: []
  type: TYPE_NORMAL
- en: While on the topic of graph types, let’s complete our discussion by introducing
    a few commonly noted properties of graphs. These aren’t labels that are attached
    to graphs, as we discussed previously regarding the different types of graphs,
    but certain measures or attributes of graphs that are agnostic of the type of
    graph under concern.
  prefs: []
  type: TYPE_NORMAL
- en: Subgraphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **subgraph** is a graph that’s formed from a subset of the vertices and edges
    of the original graph. More formally, let ![<mml:math  ><mml:mi>G</mml:mi></mml:math>](img/34.png)
    be a graph with vertex set ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    and edge set ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png) . A subgraph
    of ![<mml:math  ><mml:mi>G</mml:mi></mml:math>](img/34.png) is a graph, ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mi>'</mml:mi></mml:math>](img/38.png)
    , such that ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi><mml:mo>(</mml:mo><mml:mi>G</mml:mi><mml:mi>'</mml:mi><mml:mo>)</mml:mo></mml:math>](img/39.png)
    is a subset of ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/40.png) and E(
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mi>'</mml:mi><mml:mo>)</mml:mo></mml:math>](img/41.png)
    is a subset of ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png) . Often,
    searching for subgraphs with useful properties such as being bipartite, or connected,
    is an important step for the bigger problem at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Centrality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Centrality** is a measure in graph theory that quantifies the importance
    or influence of a node within a network. Nodes with high centrality are more central
    to the network, playing a more significant role in its structure and dynamics.
    There are several centrality measures, each capturing different aspects of a node’s
    importance. Here are some common centrality measures:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Degree centrality** : The degree centrality of a node is the number of edges
    connected to it (that is, the number of neighbors it has). Nodes with a high degree
    of centrality are well-connected and may play a crucial role in spreading information
    or influence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closeness centrality** : Closeness centrality measures how close a node is
    to all other nodes in the network. It’s the reciprocal of the sum of the shortest
    path distances from a node to all other nodes. Nodes with high closeness centrality
    can quickly interact with other nodes and are often central in terms of communication
    efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Betweenness centrality** : Betweenness centrality quantifies the number of
    shortest paths that pass through a node. A node with high betweenness centrality
    has a significant influence on communication between other nodes. Nodes with high
    betweenness centrality act as bridges or gatekeepers in the network, controlling
    the flow of information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eigenvector centrality** : Eigenvector centrality considers not only the
    number of connections a node has but also the centrality of its neighbors. It’s
    based on the principle that connections to high-scoring nodes contribute more
    to a node’s centrality. Nodes with high eigenvector centrality are connected to
    other central nodes, making them important in the overall network structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PageRank** : PageRank is a centrality measure that’s used in web search algorithms
    (for example, Google’s PageRank). It assigns importance to a node based on both
    the number and quality of its incoming links. Nodes with high PageRank are considered
    influential as they are linked to other important nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centrality measures help identify key nodes in a network, which can be important
    for understanding information flow, identifying influential individuals, or targeting
    nodes for interventions in various applications such as social networks, transportation
    systems, and biological networks. Different centrality measures may be appropriate,
    depending on the specific context and goals of the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Community structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In terms of graphs, **community structure** refers to dividing a network or
    graph into groups or clusters of nodes that are densely connected internally but
    have fewer connections between groups. Nodes within a community are more likely
    to share similar properties, interests, or functions, and identifying community
    structure is a fundamental aspect of analyzing the organization and dynamics of
    complex networks. Detecting communities in a graph is crucial for understanding
    the modular organization of the system and can have applications in various fields,
    including social network analysis, biology, and information retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: Isomorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Isomorphism** is a concept in graph theory that deals with the structural
    similarity between two graphs. Two graphs are considered isomorphic if a one-to-one
    correspondence exists between their vertices such that the adjacency relationships
    are preserved. In other words, the graphs are essentially the same from a structural
    point of view, even if the vertex and edge labels may differ.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Graph isomorphism is a fundamental problem in computer science and has applications
    in various areas, such as chemistry, computer-aided design, and pattern recognition.
    Despite its practical importance, finding a fast algorithm for graph isomorphism
    has proven to be a challenging problem, and it remains an open question whether
    such an algorithm exists with polynomial time complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – G and H are isomorphic graphs. To understand this, notice the
    mapping: g1→h1, g2→h2, g3→h3, and so on](img/B22118_01_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6 – G and H are isomorphic graphs. To understand this, notice the
    mapping: g 1 →h 1 , g 2 →h 2 , g 3 →h 3 , and so on'
  prefs: []
  type: TYPE_NORMAL
- en: The properties of specialized graphs can be exploited to derive further insights
    into the scenarios represented by these graphs. Now, let’s take a look at how
    graphs can be fed into machines so that they can be read algorithmically.
  prefs: []
  type: TYPE_NORMAL
- en: Graph data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How should we feed graph data into computer programs so that we can apply graph-based
    algorithms to solve problems? This will be addressed in this section. Each representation
    has its advantages and disadvantages, and we’ll explore them from the perspective
    of the time complexity of determining whether an edge exists and updating the
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **adjacency matrix** aims to record the graph structure via a matrix. A
    matrix, say ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/43.png) , of size
    ![<mml:math  ><mml:mi>v</mml:mi><mml:mo>×</mml:mo><mml:mi>v</mml:mi></mml:math>](img/44.png)
    is created (where ![<mml:math  ><mml:mi>v</mml:mi></mml:math>](img/45.png) denotes
    the number of nodes, or mathematically, ![<mml:math  ><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:math>](img/46.png)
    ). We start with all entries of ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/47.png)
    being 0. Next, if ![<mml:math  ><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/48.png)
    , ![<mml:math  ><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:math>](img/49.png)
    , then element ![<mml:math  ><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:math>](img/50.png)
    of ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/47.png) is labeled * 1 * .
    If the graph is undirected, then if ![<mml:math  ><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/52.png)
    , ![<mml:math  ><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:math>](img/53.png)
    , then both elements of ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/43.png)
    , ![<mml:math  ><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:math>](img/55.png)
    , and ![<mml:math  ><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:math>](img/56.png)
    , are labeled * 1 * .
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity to check whether an edge exists in an adjacency matrix is
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/57.png)
    since it just involves checking a particular cell in the matrix. However, adding
    a new vertex to the graph would be difficult, and depending on the matrix implementation,
    it might need an entirely new initialization. Finally, the space complexity of
    the adjacency matrix is also large, in the order of ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/58.png)
    . Sparse matrix implementations exist, which might reduce the space required by
    the matrix in memory, but they come with their own set of drawbacks. Adjacency
    matrices are a good choice when the graph is fairly small and   static and   also
    requires frequent lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another popular data structure that’s used to store graph data is an **adjacency
    list** . It contains a dictionary that has keys as node names, and each entry
    contains a list of all nodes connected to the key node with an edge. Unlike adjacency
    matrices, whose space complexity is ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/59.png)
    , adjacency lists have a space complexity of ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo></mml:math>](img/60.png)
    ). However, adjacency lists are far more flexible with efficient time complexities
    for many data-related tasks. Inserting vertices and edges is ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/61.png)
    ; accessing neighbors takes ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/62.png)
    as well, while finding whether an edge exists or not can take ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>)</mml:mo></mml:math>](img/63.png)
    time. Adjacency lists are a good choice when the graph is inherently sparse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – For the given graph, G, M and L are the adjacency matrix and
    list, respectively](img/B22118_01_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – For the given graph, G, M and L are the adjacency matrix and list,
    respectively
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve talked about adjacency matrices and adjacency lists as the two
    most popular data structures that are used to represent graphs in algorithms.
    However, several other graph data structures can be used based on the problem
    statement. Each graph data structure has its own set of advantages and disadvantages,
    and this serves as a great domain on which further research can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional graph-based solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many computer scientists have etched their names in history by devising elegant
    solutions to seemingly complex problems involving graphs. However, graphs aren’t
    just confined to the algorithm books, and graph-based problems are common in the
    wild. Lots of business problems and scientific research can be boiled down to
    graph-based problems, on which existing solutions can be implemented to generate
    the required output. In this section, we’ll talk about the most popular problems
    in the domain of graphs, a few approaches to solving them, and where these problems
    are encountered in practical scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Searching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two fundamental approaches when performing a search over a graph:
    breadth-first and depth-first. Both are means to traverse a graph from a starting
    point to all nodes that can be reached from the initial node, but the differentiating
    factor is their approach.'
  prefs: []
  type: TYPE_NORMAL
- en: In BFS, the algorithm explores a graph level by level, starting from the source
    vertex and visiting all its neighbors before moving on to the next level. This
    approach ensures that nodes closer to the source are visited before deeper nodes.
    On the other hand, **depth-first search** ( **DFS** ) explores a graph by going
    as deep as possible along each branch before backtracking. It explores one branch
    of the graph until it reaches the end before moving on to the next branch.
  prefs: []
  type: TYPE_NORMAL
- en: BFS is well-suited for finding the shortest path in unweighted graphs and is
    commonly used in network routing protocols and social network analysis. DFS, with
    its deep exploration, is useful in topological sorting, cycle detection, and solving
    problems such as maze exploration and puzzle-solving.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of search algorithms, let’s look at another
    class of problems, called **partitioning** . The need to understand graph partitions
    occurs frequently in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In graph theory, partitioning refers to dividing the vertices or edges of a
    graph into disjoint subsets or components. The goal of partitioning is to group
    elements of the graph in such a way that certain properties are satisfied, or
    specific objectives are achieved. There are different types of graph partitioning,
    and the choice of partitioning criteria depends on the application or problem
    at hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex partitioning** : This involves dividing the set of vertices of a graph
    into disjoint subsets. Vertex partitioning is done to achieve balance in terms
    of the number of vertices in each subset. This is a problem that’s commonly encountered
    in load balancing in parallel computing, network design, and social network analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge partitioning** : As the name suggests, this involves dividing the set
    of edges of a graph into disjoint subsets. Just like vertex partitioning, the
    objective here is to balance the number of edges or the total weight of edges
    in each subset. Edge partitioning problems generally find application in communication
    optimization in distributed computing, minimizing inter-partition communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph cut** : This involves partitioning a graph by removing a minimum number
    of edges. This is done to minimize the cut size (total weight of removed edges)
    while achieving certain constraints. Applications include image segmentation and
    community detection in social networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**K-way partitioning** : This is a generalization of the aforementioned ideas
    and involves dividing the vertices or edges into ![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/64.png)
    disjoint subsets. We find k-way partitioning problems where we need to achieve
    balance in terms of the number of elements in each of the ![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/64.png)
    subsets, such as in domains such as ** very-large-scale integration ** ( ** VLSI
    ** ) design   and parallel computing. You can read more here: [ https://patterns.eecs.berkeley.edu/?page_id=571
    ](https://patterns.eecs.berkeley.edu/?page_id=571) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph partitioning problems are often NP-hard, meaning finding an optimal solution
    may be computationally intractable for large graphs. Therefore, various heuristics,
    approximation algorithms, and optimization techniques are employed to find good
    solutions in a reasonable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: Another important problem in the domain of graphs is path optimization, and
    a lot of supply chain businesses and network researchers have been traditionally
    interested in solutions to such problems.
  prefs: []
  type: TYPE_NORMAL
- en: Path optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two common problems in graph theory are finding the shortest path and finding
    the widest path between two nodes in a weighted graph. Their applications are
    obvious and involve route optimization in supply chains and social network analysis
    (the problem mentioned in the preceding case study can also be viewed as a shortest
    path problem between the two nodes, especially if a slight modification was made
    by needing the edges to be weighted).
  prefs: []
  type: TYPE_NORMAL
- en: 'The widest path problem is a variant of the shortest path problem. Formally,
    the problem is defined thus: given a weighted graph, the widest path problem seeks
    a path from a source vertex to a target vertex such that the minimum edge weight
    (bottleneck) along the path is maximized. This can be particularly relevant in
    network design or communication systems, where the goal is to maximize the capacity
    of the bottleneck link.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular solution to find the shortest path between two nodes is **Dijkstra’s
    algorithm** . While not diving too much into the details, here’s a short step-by-step
    summary of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start at the source vertex.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign a tentative distance of 0 to the source and infinity to all other vertices.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark all vertices as unvisited.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Iterative exploration** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the unvisited vertex with the smallest tentative distance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For the selected vertex, consider all its neighbors.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the tentative distance of each neighbor by adding the distance from the
    current vertex.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the updated distance is smaller than the current tentative distance, update
    it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark the current vertex as visited.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Termination** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the iterative process until the destination vertex is visited or all
    vertices have been visited.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The final assigned distances represent the shortest paths from the source to
    all other vertices.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reconstruct the shortest path by backtracking from the destination to the source
    using the information that was stored about the shortest distances.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In summary, Dijkstra’s algorithm explores the graph in a step-by-step manner,
    always choosing the vertex with the smallest tentative distance. It gradually
    builds up the shortest paths from the source to all other vertices while marking
    visited vertices. The final result is a set of shortest distances and paths from
    the source to all other vertices in the graph. The widest path problem can also
    be solved by the same algorithm, but instead of maintaining the smallest tentative
    distance per node, we maintain the bottleneck weight (or the maximum of the minimum
    weights across all paths). The time complexity of this algorithm depends heavily
    on the implementation used, and the complexity ranges from ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>*</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/66.png)
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>*</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/67.png)
    to ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/68.png)
    . Dijkstra’s algorithm fails when the edge weights are negative, however, and
    is also inefficient if the graph is nearly fully connected. In such scenarios,
    alternatives such as the ** Bellman-Ford ** ** algorithm ** can   be used.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of what kind of analytics are performed
    on graph data, let’s look at another powerful way of learning patterns within
    graph data. The core ideas of representation learning are described in the following
    section; we’ll learn how representation learning is an important first step for
    solving many complex problems involving graphs.
  prefs: []
  type: TYPE_NORMAL
- en: The need for representation learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we’ll introduce a new concept called **representation learning for graphs**
    . Let’s use a small analogy to understand what this means. A typical corporate
    organization has several entities: employees, IT equipment, offices, and so on.
    All these entities maintain different types of relationships with each other:
    employees can be related to each other based on organizational hierarchy; one
    employee may use several pieces of IT equipment; several pieces of equipment,
    such as servers, can be networked with each other; employees and equipment can
    report physically or be located in a particular office, respectively; and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A graph, quite rightly, seems like a natural way to represent this information,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – A graph showing the different entities in an organization interacting
    with each other](img/B22118_01_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – A graph showing the different entities in an organization interacting
    with each other
  prefs: []
  type: TYPE_NORMAL
- en: 'Graphs are very visually intuitive. However, performing algorithmic calculations
    on graphs isn’t trivial. Could we find a way to capture the characteristics as
    well as the relationship information of each entity as much as possible, but within
    some common fields? Consider a sort of unique ID card for each entity that contains
    the following fields: Name, Sub-Organization, Date of Initiation, Years in Industry,
    and Geographic Location. So, a few ID cards may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Examples of a few ID cards with the same fields for all entities](img/B22118_01_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Examples of a few ID cards with the same fields for all entities
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you’re presented with a set of ID cards of all entities and not the
    preceding graph, could you answer questions such as which employee reports to
    whom? Alternatively, which ID card is that of an employee, which of the office,
    and which of a piece of IT equipment? It’s not easy (or completely feasible) to
    determine the answers to such questions using just the information in the ID cards,
    but we can get close to the correct answer. To answer whether an employee is under
    some other employee in the hierarchy, we can check whether both employees have
    the same **Sub-Organization** and **Geographic-Location** values and whether the
    employee higher in the hierarchy has a higher **Years-in-Industry** value than
    the other. Guessing whether an ID card belongs to an office might simply mean
    checking whether the **Sub-Organization** value of the entity is blank, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: While this approach sounds non-intuitive at first, using such heuristics to
    try to answer these practical questions based simply on the ID cards, and not
    the graph, can be performed efficiently by computers and modern-day implementations.
    The ID card here tries to *represent* the characteristics of the entities and
    relationships in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: More formally, the ID cards in the preceding example are vector embeddings of
    a fixed dimension that’s associated with each node of the graph. A learning algorithm
    is applied that tries to capture as much information present in the graph structure
    within these embeddings. These sets of embeddings are then used to answer difficult
    questions regarding the graph, instead of relying on the original graph itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why should we try to learn representations? What benefits do working with embeddings
    present over working with the original graph in itself? Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability** : Traditional graph algorithms can become computationally expensive
    and impractical for large-scale graphs. Representation learning allows compact
    embeddings to be generated that capture essential graph information, enabling
    more scalable and efficient computations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task flexibility** : Representation learning produces embeddings that are
    task-agnostic, meaning they can be used for a variety of downstream tasks. Traditional
    graph algorithms are often designed for specific problems, and adapting them to
    different tasks might be challenging. Embeddings provide a more flexible and versatile
    way to approach diverse tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incorporating node and edge features** : Many real-world graphs come with
    additional features associated with nodes and edges. Representation learning methods
    can naturally incorporate these features into the learning process, allowing for
    a more comprehensive understanding of the graph’s characteristics. Traditional
    graph algorithms might not easily integrate external features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling dynamic graphs** : Representation learning is well-suited for dynamic
    graphs where the structure evolves. The learned embeddings can capture temporal
    patterns and changes, providing a more adaptive approach compared to traditional
    graph algorithms, which might not inherently address temporal aspects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generalization to unseen data** : Representation learning aims to generate
    embeddings that generalize well to unseen data. This is particularly useful in
    scenarios where the graph structure is not completely known or is subject to change.
    Traditional graph algorithms may not generalize as effectively to new or unseen
    graph instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Noise robustness** : Embeddings can be more robust to noisy or incomplete
    graph data. Traditional graph algorithms may be sensitive to noise, but representation
    learning methods can learn to ignore irrelevant information and focus on the most
    informative aspects of the graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with machine learning models** : Representation learning facilitates
    the integration of graph data with machine learning models. The learned embeddings
    can serve as input features for various machine learning tasks, allowing practitioners
    to leverage the power of both graph-based and non-graph-based algorithms in a
    unified framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By capturing essential information in compact embeddings, it becomes more feasible
    to apply machine learning techniques to graph-structured data and address a wide
    range of tasks efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: GNNs and the need for a separate vertical
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We won’t dive into the details of what GNNs do or how they differ from other
    popular neural network architectures in this chapter. Here, we’ll merely attempt
    to explain why there’s a need to study GNNs separately from other deep learning
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before talking about the differences, we must discuss the similarities. GNNs
    are an architecture choice that’s specialized for processing graph data and outputting
    representations or node embeddings. Similar to how convolutional networks are
    fundamental for reading pixel data, the set of architectures under GNNs are optimized
    for reading graph data. GNN-based learning tasks follow the same trajectory as
    other deep learning solutions: to iteratively optimize the parameters of the model
    so that a loss function can be minimized. In the case of GNNs, the loss function
    often tries to capture and preserve meaningful information about the graph structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s have a look at the differences, and why GNNs require special attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Irregular graph structures** : Graphs can have irregular and varying structures,
    with nodes having different numbers of neighbors. This irregularity poses challenges
    for traditional deep learning architectures, which often assume fixed input sizes.
    For example, in a social network, individuals may have varying numbers of connections
    (friends, followers, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permutation invariance** : The order of nodes in a graph shouldn’t affect
    the output of a GNN. Achieving permutation invariance is crucial to ensure that
    the model can generalize across different node orders. A good example of permutation
    invariance is in molecular graphs in chemistry. The properties of a molecule depend
    only on its structure, not the order in which the atoms are labeled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph isomorphism problem** : Determining whether two graphs are isomorphic
    is a computationally complex problem. GNNs need to be able to capture and differentiate
    between different graph structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node and graph classification** : GNNs often need to perform tasks such as
    node classification or graph classification. These tasks require the model to
    capture both local and global information from the graph, which can be challenging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling different types of edges** : Graphs may have different types of
    edges, each representing a different kind of relationship between nodes. GNNs
    need to be able to model and leverage this heterogeneity in edge types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pooling and aggregation** : Aggregating information from neighbors in a graph
    is a fundamental operation in GNNs. Designing effective pooling and aggregation
    strategies to capture important information while avoiding information loss or
    redundancy is a challenge. A good example is when recommendation systems pool
    information from the user’s friends’ preferences. The representations should capture
    this pooling idea as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capturing long-range dependencies** : GNNs need to capture long-range dependencies
    in graphs. Unlike sequential data in **recurrent neural networks** ( **RNNs**
    ), where dependencies are often local, graphs may have dependencies that span
    long distances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpretable representations** : Understanding and interpreting the learned
    representations in GNNs is crucial, especially in applications where interpretability
    is essential. Interpretability is crucial in medical diagnosis with electronic
    health records. GNNs can be used to analyze patient records where nodes represent
    different health parameters. Interpretable representations are crucial for healthcare
    professionals to understand and trust the model’s decision-making process in diagnosing
    diseases or predicting patient outcomes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNNs provide a lot of the benefits that machine learning approaches have in
    terms of boosting our capabilities with tabular data, but in terms of graph data.
    There are several important implications of using GNNs as an intermediary step
    to solve relevant problems related to graphs. We’ll explore more such topics in
    the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the foundational concepts in graph learning and
    representation. We began with motivating examples of how graph structures naturally
    capture relationships between entities, making them a powerful data representation.
    Then, formal definitions of graphs, common graph types, and key properties were
    discussed. We also looked at popular graph algorithms such as searching, partitioning,
    and path optimization, along with their real-world use cases.
  prefs: []
  type: TYPE_NORMAL
- en: A key idea presented here was the need for representation learning on graphs.
    Converting graph data into vector embeddings allows us to leverage the capabilities
    of machine learning models. Benefits such as scalability, flexibility, and robustness
    make graph embeddings an enabling technique.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we justified the need for specialized GNN architectures. Factors such
    as irregular structure, permutation invariance, and complex operations such as
    aggregation and pooling necessitate tailored solutions. GNNs open up new possibilities
    for learning from relational data across domains.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll discuss how graph learning is applied in practice.
    There are several levels to graph learning and representation, and all of them
    have business and academic significance. The topics covered here will act as a
    foundation for your understanding of the concepts in the chapters that follow.
  prefs: []
  type: TYPE_NORMAL
