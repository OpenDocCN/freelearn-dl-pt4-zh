- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: 'Expanding the LLM Toolkit for Coders: Beyond LLMs'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展编码者的LLM工具包：超越LLM
- en: In the rapidly changing world of software development, LLMs, such as OpenAI’s
    GPT series and OpenAI o1, Google’s Gemini, and Meta’s Llama 3 have garnered significant
    attention for their ability to assist with coding tasks. However, while LLMs are
    powerful tools, they are not the only game in town. There exists a plethora of
    non-LLM AI tools designed to complement the coding process, enhancing productivity
    and efficiency. This chapter explores these tools, discussing their capabilities,
    limitations, and how they can be integrated into a comprehensive coding toolkit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发这个快速变化的领域，像OpenAI的GPT系列和OpenAI o1、Google的Gemini以及Meta的Llama 3等LLM，因其在编码任务中的辅助能力而受到了广泛关注。然而，尽管LLM是强大的工具，但它们并不是唯一的选择。还有许多非LLM
    AI工具，旨在补充编码过程，提升生产力和效率。本章将探讨这些工具，讨论它们的能力、局限性，以及如何将它们集成到全面的编码工具包中。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下主题：
- en: Code completion and generation tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码补全和生成工具
- en: '**Static code analysis** ( **SCA** ) and code review tools'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态代码分析**（**SCA**）和代码审查工具'
- en: Testing and debugging tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和调试工具
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you’ll need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的工具：
- en: Access to a browser to get these AI code tools.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问浏览器以获取这些AI代码工具。
- en: A laptop or desktop to install the software.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台可安装软件的笔记本电脑或台式机。
- en: An **integrated development environment** ( **IDE** ) for Python, such as Visual
    Studio, Spyder, IDLE, PyCharm, or Atom.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于Python的**集成开发环境**（**IDE**），如Visual Studio、Spyder、IDLE、PyCharm或Atom。
- en: 'An IDE for Javascript, such as Visual Studio, Atom, or Brackets. An online
    interpreter will not be good enough here. Here are some examples:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款用于Javascript的IDE，如Visual Studio、Atom或Brackets。在线解释器在这里不够用。以下是一些示例：
- en: '[https://onecompiler.com/javascript](https://onecompiler.com/javascript)'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://onecompiler.com/javascript](https://onecompiler.com/javascript)'
- en: '[https://jipsen.github.io/js.html](https://jipsen.github.io/js.html)'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://jipsen.github.io/js.html](https://jipsen.github.io/js.html)'
- en: A Java IDE, such as IntelliJ IDEA, Eclipse, or NetBeans.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款Java集成开发环境（IDE），如IntelliJ IDEA、Eclipse或NetBeans。
- en: Some code examples require bash (basic shell) for Unix **operating** **systems**
    ( **OSs** ).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些代码示例需要在Unix **操作系统**（**OSs**）上使用bash（基础shell）。
- en: 'Get the code in this chapter here: [https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter10](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter10)
    .'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取本章的代码，请点击这里：[https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter10](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter10)。
- en: Now, let’s learn how to use non-LLM tools to make code generation, analysis,
    and testing much easier.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用非LLM工具使代码生成、分析和测试变得更加简单。
- en: Code completion and generation tools
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码补全和生成工具
- en: Code completion and generation tools are designed to assist developers in writing
    code more efficiently. These tools leverage various techniques, including syntax
    analysis, semantic understanding, and **machine learning** ( **ML** ) algorithms,
    to predict and suggest code snippets as developers type. The usefulness of these
    tools can’t be overstated, as they streamline the coding process, reduce errors,
    and enhance overall productivity. In this section, we will explore several code
    completion and generation tools, their features, and practical examples to give
    you a good understanding of how they can be integrated into your coding workflow.
    Let’s explore some of the most popular tools available, including Eclipse’s Content
    Assist, PyCharm’s code completion tool, NetBeans’ code completion tool, and **Visual
    Studio Code’s** ( **VS** **Code’s** ) IntelliSense.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 代码补全和生成工具旨在帮助开发人员更高效地编写代码。这些工具利用各种技术，包括语法分析、语义理解和**机器学习**（**ML**）算法，在开发人员输入代码时预测并建议代码片段。这些工具的实用性不容小觑，因为它们能简化编码过程，减少错误，并提升整体生产力。在本节中，我们将探讨几款代码补全和生成工具，介绍它们的特点和实际应用示例，帮助你更好地理解它们如何融入到你的编码工作流程中。让我们来看看一些最受欢迎的工具，包括Eclipse的内容辅助、PyCharm的代码补全工具、NetBeans的代码补全工具以及**Visual
    Studio Code**（**VS Code**）的IntelliSense。
- en: Overall, these tools help the developer improve code accuracy, speed up development,
    learn new syntax and APIs, and make code more readable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这些工具帮助开发人员提高代码准确性，加快开发速度，学习新语法和API，并使代码更具可读性。
- en: Eclipse’s Content Assist
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eclipse的内容辅助
- en: Eclipse, a versatile IDE, features a robust code completion plugin tool known
    as **Content Assist** . This tool enhances developer productivity by providing
    relevant suggestions as you type and analyzing the current context scope and prefix
    of your code to offer keywords, methods, variables, and more. This not only speeds
    up coding but also reduces errors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse 是一款多功能的 IDE，具有强大的代码补全插件工具 **内容助手**。该工具通过提供相关建议来提高开发者的工作效率，建议会基于你输入的内容，分析代码的当前上下文和前缀，提供关键字、方法、变量等。这不仅加快了编码速度，还减少了错误。
- en: One of Content Assist’s standout features is its seamless integration into the
    Eclipse IDE, requiring no additional installation. This built-in nature means
    developers can immediately benefit from its code completion capabilities without
    extra setup. The convenience of having such a tool readily available makes development
    life much easier.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 内容助手的一个显著特点是其与 Eclipse IDE 的无缝集成，无需额外安装。内置的特性意味着开发者可以立即受益于它的代码补全能力，无需额外的设置。拥有这样一个随时可用的工具使开发工作变得更加轻松。
- en: Content Assist is highly customizable, allowing users to tailor suggestions
    to their specific needs. Developers can configure the types of suggestions they
    want, such as method names, variable names, or entire code snippets. You can filter
    the suggestions for relevance, type, or accessibility. Also, users can adjust
    trigger settings, deciding whether Content Assist should activate automatically
    or manually. This flexibility ensures the tool adapts to various coding styles
    and preferences.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 内容助手具有高度的可定制性，允许用户根据自己的特定需求定制建议。开发者可以配置他们想要的建议类型，比如方法名称、变量名称或整个代码片段。你可以根据相关性、类型或可访问性来过滤建议。此外，用户还可以调整触发设置，决定内容助手是自动激活还是手动激活。这种灵活性确保了该工具能够适应不同的编码风格和偏好。
- en: 'Suggestions are based on the letters you’ve just entered; a list of suggestions
    and relevance appears in this order:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 建议是基于你刚输入的字母，建议列表会按照以下顺序出现并显示相关性：
- en: Fields
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段
- en: Variables
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Methods
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Functions
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Classes
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Structs
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Unions
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合体
- en: Namespaces
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Enumerations
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: 'You can trigger the code completion by hitting *Ctrl* + the space bar, but
    this is customizable, and it also triggers when you type any of the following:
    “ **."** , “ **->"** , or “ **::"** .'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按 *Ctrl* + 空格键来触发代码补全，但这一设置是可定制的，当你输入以下内容时，也会触发代码补全：“ **."** ”，“ **->"**
    ”或“ **::"** 。
- en: You can make templates for code you write often; if you enter *Ctrl* + the space
    bar, a list of your templates will appear, depending on scope, and you can insert
    the one you want.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为经常编写的代码创建模板；如果你按下 *Ctrl* + 空格键，依赖于作用域，会出现你的模板列表，你可以选择插入你需要的模板。
- en: 'Examples include a **do while** loop in C or C++, a main method in Java:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例包括 C 或 C++ 中的 **do while** 循环，Java 中的 main 方法：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, an **include guard** (a.k.a. a **macro guard** , **header guard** , or
    **file guard** ) in C++/C:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在 C++/C 中使用 **包含保护**（也叫 **宏保护**、**头文件保护** 或 **文件保护**）：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These stop you from accidentally including a library multiple times [Wiki_Include].
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些能防止你意外地多次包含一个库 [Wiki_Include]。
- en: 'In Java, you would use a **for loop** :'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，你会使用 **for 循环**：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Or, you would use a **try-catch block** .
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你会使用 **try-catch 块**。
- en: 'For Python, examples include a **function definition** :'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python，示例包括 **函数定义**：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'They also include a **class definition** :'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还包括 **类定义**：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[ Eclipse_Help, Gemini]'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[Eclipse_Help, Gemini]'
- en: Another significant advantage is its wide language support. Being in the Eclipse
    environment, Content Assist supports numerous programming languages, including
    Java, C++, Python, and PHP. This makes Content Assist a great tool for developers
    working in multi-language environments. Whether developing a web application in
    JavaScript, a desktop application in Java, or a script in Python, Content Assist
    provides relevant suggestions to speed up the coding process.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个显著的优点是其广泛的语言支持。由于在 Eclipse 环境中，内容助手支持众多编程语言，包括 Java、C++、Python 和 PHP。这使得内容助手成为多语言开发环境中开发者的好工具。无论是在
    JavaScript 中开发 Web 应用程序，在 Java 中开发桌面应用程序，还是在 Python 中编写脚本，内容助手都能提供相关建议，加快编码过程。
- en: There are some drawbacks, however. Performance can be an issue, especially with
    larger projects, where code completion suggestions might be slower compared to
    dedicated tools. This delay can disrupt the coding flow and reduce productivity.
    Also, while Content Assist provides useful suggestions, they may not always be
    as contextually relevant or advanced as those offered by specialized tools or
    those powered by ML models.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也有一些缺点。性能可能是一个问题，尤其是在大型项目中，代码补全建议可能比专用工具更慢。这种延迟可能打断编码流程并降低生产力。而且，虽然内容辅助提供有用的建议，但它们可能并不总是像专门工具或由机器学习模型驱动的工具那样上下文相关或先进。
- en: Despite these limitations, Eclipse’s Content Assist remains a valuable tool
    for many developers. Its integration with the Eclipse IDE, combined with customization
    options and wide language support, makes it a practical choice for various coding
    tasks. For developers prioritizing an IDE with robust multi-language support,
    Content Assist offers a balanced mix of convenience and functionality.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些限制，Eclipse 的内容辅助仍然是许多开发者的宝贵工具。它与 Eclipse IDE 的集成，再加上可定制选项和广泛的语言支持，使其成为多种编码任务的实用选择。对于那些优先考虑支持多语言的
    IDE 的开发者来说，内容辅助提供了一种便利与功能兼具的平衡。
- en: 'Here are some pros of using Content Assist:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用内容辅助的一些优点：
- en: No additional installation required
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要额外安装。
- en: It offers various settings to tailor suggestions to your needs
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了多种设置，以便根据你的需求调整建议。
- en: It supports a vast array of programming languages
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持广泛的编程语言。
- en: It is integrated directly into the Eclipse IDE
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它直接集成在 Eclipse IDE 中。
- en: It can be configured to activate automatically or manually
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以配置为自动或手动激活。
- en: 'Here are some cons of using Content Assist:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用内容辅助的一些缺点：
- en: It can sometimes be slower than dedicated code completion tools, especially
    with larger projects
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型项目中，它有时可能比专用的代码补全工具更慢。
- en: It may not always provide the most contextually relevant suggestions compared
    to specialized tools or those powered by ML models
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与专门的工具或由机器学习模型驱动的工具相比，它可能并不总是提供最具上下文相关性的建议。
- en: In summary, Eclipse’s Content Assist is a valuable tool for developers looking
    for an integrated, customizable, and versatile code completion feature. While
    it may not always match the performance or advanced capabilities of dedicated
    tools, its built-in nature and wide language support make it a solid choice for
    many coding environments. Whether you are a seasoned developer or just starting,
    Content Assist can help streamline your coding process and improve your overall
    productivity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Eclipse 的内容辅助是一个对开发者来说非常有价值的工具，适合寻找集成化、可定制且多功能的代码补全功能的开发者。尽管它可能并不总是与专门工具的性能或高级功能相匹配，但其内置特性和广泛的语言支持使其成为许多编码环境中的一个可靠选择。无论你是经验丰富的开发者还是刚刚起步，内容辅助都能帮助简化你的编码过程，提升整体生产力。
- en: 'For more detailed information about Content Assist, you can refer to the Eclipse
    Help documentation: [https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm](https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm)
    .'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有关内容辅助的更详细信息，你可以参考 Eclipse 帮助文档：[https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm](https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm)。
- en: PyCharm’s code completion
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyCharm 的代码补全。
- en: '**PyCharm** , developed by JetBrains, is a widely acclaimed IDE specifically
    designed for Python development. One of its standout features is its intelligent
    code completion, which significantly improves your coding experience by giving
    you context-aware suggestions that go beyond basic code completions. This feature
    can carry out static analysis and use ML to provide highly relevant recommendations,
    including method calls, variable names, and code snippets.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyCharm**，由 JetBrains 开发，是一款广受好评的专门为 Python 开发设计的 IDE。其突出特点之一是智能代码补全，它通过提供超越基本代码补全的上下文感知建议，显著提升了你的编码体验。该功能可以执行静态分析，并使用机器学习提供高度相关的推荐，包括方法调用、变量名称和代码片段。'
- en: PyCharm’s code completion tool is deeply integrated with Python, making it an
    excellent choice for Python developers. The IDE indexes your entire project upon
    startup, allowing it to provide accurate and contextually relevant suggestions
    as you type. This deep integration ensures that the code completion feature understands
    the nuances of Python syntax and semantics, offering suggestions that have correct
    syntax and are appropriate for the context.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 的代码补全工具与 Python 深度集成，是 Python 开发者的绝佳选择。IDE 在启动时会对整个项目进行索引，从而在你输入时提供准确且具有上下文相关性的建议。这种深度集成确保了代码补全功能能够理解
    Python 语法和语义的细微差别，提供具有正确语法且适用于当前上下文的建议。
- en: One of the key advantages of PyCharm’s code completion tool is its context-aware
    nature. The tool analyzes the current context as you code to provide the most
    relevant suggestions. For example, if you’re inside a class method, it will prioritize
    method names and variables that are accessible within that scope. This context-awareness
    extends to understanding the types of variables and suggesting methods and properties
    that are applicable to those types. This intelligent behavior helps reduce the
    amount of boilerplate code you need to write and minimizes the chances of errors.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 的代码补全工具的一个关键优势是其上下文感知特性。该工具在你编写代码时会分析当前上下文，提供最相关的建议。例如，如果你在一个类的方法中，它会优先显示该作用域内可访问的方法名称和变量。此上下文感知能力扩展到理解变量的类型，并建议适用于这些类型的方法和属性。这种智能行为有助于减少你需要编写的样板代码，并最小化错误的发生几率。
- en: In addition to basic code completion, PyCharm offers smart type-matching completion.
    This feature filters the suggestion list to show only the types that are applicable
    to the current context. For example, if you’re assigning a value to a variable,
    it will suggest only those values that match the variable’s type. This smart filtering
    helps in maintaining type safety and ensures that your code adheres to the expected
    type constraints.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的代码补全功能，PyCharm 还提供智能类型匹配补全。此功能会筛选建议列表，仅显示适用于当前上下文的类型。例如，如果你正在为一个变量赋值，它只会建议与该变量类型匹配的值。这个智能筛选有助于保持类型安全，并确保你的代码符合预期的类型约束。
- en: Here are some examples of using code completion.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些使用代码补全的示例。
- en: Start by typing a name in PyCharm, then hit *Ctrl* + the space bar. Alternatively,
    go to the menu and select **Code** | **Code Completion** , then you can choose
    the **Basic** version. For **Basic Completion** , you can do Methods, Method parameters,
    Dictionaries, Django templates, and File path completions [Python].
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PyCharm 中开始输入一个名称，然后按 *Ctrl* + 空格键。或者，你也可以进入菜单选择 **Code** | **Code Completion**，然后选择
    **Basic** 版本。对于 **Basic Completion**，你可以进行方法、方法参数、字典、Django 模板和文件路径的补全 [Python]。
- en: Pressing *Ctrl* + the space bar a second time or *Ctrl* + *Alt* + the space
    bar gives you the names of classes, functions, modules, and variables that start
    with the same letters you’ve written.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次按 *Ctrl* + 空格键或 *Ctrl* + *Alt* + 空格键，你将得到与你输入的字母开头相同的类、函数、模块和变量的名称。
- en: Other kinds of code completion are smart, hierarchical, chained, docstring,
    custom, live templates, postfix, and type hints [Jetbrains_Completion].
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的代码补全包括智能补全、层级补全、链式补全、文档字符串补全、自定义补全、实时模板补全、后缀补全和类型提示补全 [Jetbrains_Completion]。
- en: 'Smart type-matching completion gives you a list of relevant types from the
    current context (around the cursor). For example, exception types. If you hit
    *Ctrl* + *Shift* + the space bar, it’ll give you a list of the relevant types
    or you could use the menu: **Code** | **Code Completion** | **Type-Matching**
    .'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 智能类型匹配补全会根据当前上下文（光标周围）提供相关类型的列表。例如，异常类型。如果你按 *Ctrl* + *Shift* + 空格键，它会显示相关类型的列表，或者你也可以使用菜单：**Code**
    | **Code Completion** | **Type-Matching**。
- en: Refactoring
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构
- en: PyCharm can also do a great deal of refactoring. Its refactoring tools work
    alongside its code completion feature. These tools allow you to rename variables,
    extract methods, and perform other refactoring operations easily. The refactoring
    tools are context-aware and ensure that changes are propagated throughout your
    code base, maintaining consistency and reducing the risk of introducing errors.
    This deep integration of refactoring tools with code completion makes PyCharm
    a very useful IDE for maintaining and improving code quality.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm也可以进行大量的重构。它的重构工具与代码补全功能协同工作。这些工具允许你轻松地重命名变量、提取方法以及执行其他重构操作。重构工具是基于上下文的，确保变更在你的代码库中得以传播，保持一致性并减少引入错误的风险。重构工具与代码补全的深度集成，使PyCharm成为一个非常有用的IDE，用于维护和提升代码质量。
- en: 'There are PyCharm components: project view, structure tool window, editor,
    and UML class diagram. To get started with refactoring, there are two ways:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm包含一些组件：项目视图、结构工具窗口、编辑器和UML类图。要开始进行重构，有两种方法：
- en: Hover over some code.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在一些代码上。
- en: Select the code, and from the menu, select **Refactor** | **Refactor This**
    or press *Ctrl* + *Alt* + *Shift* + *T* .
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择代码，然后从菜单中选择**重构** | **重构此项**，或者按*Ctrl* + *Alt* + *Shift* + *T*。
- en: Then, select the refactoring option you’d like.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择你想要的重构选项。
- en: You’ll get a dialog box where you can enter the refactoring options, then you
    can click **OK** or **Refactor** [Jetbrains_refactoring].
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到一个对话框，你可以在其中输入重构选项，然后点击**确定**或**重构** [Jetbrains_refactoring]。
- en: 'There are many excellent things you can do with code completion, however, there
    are some drawbacks. PyCharm is a commercial tool, and while it offers a free Community
    edition, many of its advanced features, including some aspects of code completion,
    are available only in the Professional edition, which requires a license. This
    can be a limitation for developers or organizations with budget constraints. You
    can see the difference between the versions, along with a link to pricing, here:
    [https://www.jetbrains.com/pycharm/editions/](https://www.jetbrains.com/pycharm/editions/)
    .'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过代码自动补全做很多很棒的事情，但也有一些缺点。PyCharm是一个商业工具，虽然它提供了免费的社区版，但许多高级功能，包括一些代码补全功能，只在专业版中提供，专业版需要购买许可证。这对预算有限的开发者或组织来说可能是一个限制。你可以在这里看到不同版本之间的差异，并查看定价链接：[https://www.jetbrains.com/pycharm/editions/](https://www.jetbrains.com/pycharm/editions/)。
- en: Another consideration is that PyCharm can be resource-intensive, especially
    when working with large projects. The IDE’s comprehensive indexing and analysis
    capabilities need quite a lot of computational resources, which can lead to slower
    performance on less powerful machines. This resource intensity can sometimes result
    in delays in code completion suggestions, which can disrupt the coding flow.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的因素是，PyCharm可能会消耗大量资源，尤其是在处理大型项目时。IDE的全面索引和分析功能需要相当多的计算资源，这可能会导致在性能较差的机器上运行缓慢。这种资源密集型使用有时会导致代码补全建议的延迟，从而打断编码的流畅性。
- en: 'Despite these drawbacks, PyCharm’s code completion remains a highly valuable
    tool for Python developers. Its intelligent, context-aware suggestions, deep integration
    with Python, and powerful refactoring tools make it an excellent choice for both
    novice and experienced developers. The ability to customize the behavior of code
    completion means you can define how it helps to check and complete your code:
    you can tailor the tool to your specific preferences.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些缺点，PyCharm的代码补全仍然是Python开发者非常有价值的工具。它智能的、基于上下文的建议、与Python的深度集成以及强大的重构工具，使其成为初学者和经验丰富的开发者的优选。代码补全行为的可定制性意味着你可以定义它如何帮助检查和完成代码：你可以根据自己的具体偏好来调整这个工具。
- en: 'Here are some pros of using PyCharm’s code completion tool:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用PyCharm代码自动补全工具的一些优点：
- en: It offers highly relevant code completions based on your code’s context
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它根据你代码的上下文提供高度相关的代码补全。
- en: It provides a seamless Python development experience
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了无缝的Python开发体验。
- en: It includes excellent refactoring features to improve code quality
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括优秀的重构功能，可以提高代码质量。
- en: 'Here are some cons of using PyCharm’s code completion tool:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用PyCharm代码自动补全工具的一些缺点：
- en: It requires a paid license for full use
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全使用需要付费许可证。
- en: It can be resource-intensive, especially for large projects
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会消耗大量资源，特别是在大型项目中。
- en: In summary, PyCharm’s code completion is a robust and intelligent feature that
    significantly enhances the Python development experience. Its context-aware suggestions,
    deep integration with Python, and powerful refactoring tools make it a very good
    choice for Python developers. While it requires a license for full use and can
    be resource-intensive, the benefits it offers in terms of productivity and code
    quality make it a worthwhile investment for many developers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，PyCharm的代码自动完成是一个强大而智能的功能，大大提升了Python开发体验。它的上下文感知建议、与Python的深度集成以及强大的重构工具，使其成为Python开发者的极好选择。尽管完全使用该功能需要许可证，并且可能对资源要求较高，但它在提升生产力和代码质量方面的好处，使其对许多开发人员来说是值得投资的。
- en: 'You can find out more about PyCharm’s code completion tool here: [https://www.jetbrains.com/help/pycharm/auto-completing-code.html](https://www.jetbrains.com/help/pycharm/auto-completing-code.html)
    .'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于PyCharm代码自动完成功能的信息：[https://www.jetbrains.com/help/pycharm/auto-completing-code.html](https://www.jetbrains.com/help/pycharm/auto-completing-code.html)。
- en: NetBeans’ code completion
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NetBeans的代码自动完成
- en: NetBeans offers a full code completion feature. This feature is designed to
    enhance the coding experience by providing relevant suggestions for keywords,
    methods, variables, and more, across various programming languages. NetBeans’
    code completion tool is a valuable tool for you to increase your productivity
    and reduce your coding errors.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans提供了完整的代码自动完成功能。此功能旨在通过提供与关键字、方法、变量等相关的建议，提升编程体验，支持多种编程语言。NetBeans的代码自动完成功能是提高生产力和减少编码错误的宝贵工具。
- en: NetBeans’ code completion tool is pretty user-friendly. The design makes it
    easy for developers to use, regardless of their level of experience. The code
    completion feature is integrated into the editor, allowing suggestions to appear
    as you type. This integration helps streamline the coding process, making it faster
    and more efficient. The interface is designed to be straightforward, so even new
    users can quickly become familiar with the tool.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans的代码自动完成工具非常用户友好。其设计使得开发人员无论经验水平如何，都能轻松使用。代码自动完成功能集成在编辑器中，允许在你输入时自动出现建议。这种集成有助于简化编码过程，使其更加快捷高效。界面设计简单直观，即使是新用户也能快速熟悉该工具。
- en: 'NetBeans’ Editor Code Completion API has two classes, **CompletionItem** and
    **Completion** **Provider** . Code completion is also activated with *Ctrl* +
    the space bar or through the menus: in Windows, this is the pathway: **Tools**
    | **Options** | **Editor** | **Code Completion** . In macOS, this is the pathway:
    **NetBeans** | **Preferences…** | **Editor** | **Code Completion** . Similar to
    other tools, it will take what you have written and make a list of suggestions
    that shortens as you type, and the most relevant suggestions will be at the top
    of the list. You can specify the code completion trigger, but the default is.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans的编辑器代码自动完成API有两个类，**CompletionItem**和**Completion** **Provider**。代码自动完成同样可以通过*Ctrl*
    + 空格键或通过菜单激活：在Windows中，这个路径是：**工具** | **选项** | **编辑器** | **代码自动完成**；在macOS中，这个路径是：**NetBeans**
    | **偏好设置…** | **编辑器** | **代码自动完成**。与其他工具类似，它会根据你所写的内容生成一个建议列表，随着你输入，列表会缩短，最相关的建议会排在列表的顶部。你可以指定代码自动完成的触发方式，但默认情况下是这样的。
- en: There’s another version of code completion called **hippie completion** , which
    searches the current scope of your code, searching the current document and then
    other documents if the desired result is not found. It is activated with *Ctrl*
    + *K* in Windows or *cmd* + *K* in macOS.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种叫做**hippie completion**的代码自动完成版本，它会搜索当前代码的作用域，首先搜索当前文档，如果没有找到期望的结果，则继续搜索其他文档。Windows系统中使用*Ctrl*
    + *K*，在macOS系统中使用*cmd* + *K*来激活该功能。
- en: If you are declaring an object or a variable of a type, then pressing *Ctrl*
    + the space bar will suggest objects of that type, for example, if you’re declaring
    an **int** , then the first time you hit *Ctrl* + the space bar, it’ll give you
    ints. If you activate code completion again with the same keys, it’ll suggest
    all items, not just ints.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在声明一个对象或变量类型，按*Ctrl* + 空格键将建议该类型的对象，例如，如果你声明一个**int**，第一次按*Ctrl* + 空格键时，它会给你所有int类型的选项。如果你再次使用相同的快捷键激活代码自动完成，它会建议所有项，而不仅仅是int类型。
- en: 'If you use the *Tab* button, the tool will fill in the most commonly used prefixes
    and suggestions, for example, **print** ; if you type **System.out.p** , the following
    will appear:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用*Tab*键，该工具将填充最常用的前缀和建议，例如，**print**；如果你输入**System.out.p**，将出现以下内容：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use the *Tab* key to use the selected option.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Tab*键选择建议项。
- en: 'NetBeans’ code completion tool will also complete subwords. This is based on
    which letters you’ve typed in, but it’s everything relating to those letters,
    not just things starting with those letters. So, it still works if you’ve forgotten
    the initial letters for the item! An example of this is if you type in **Binding.prop**
    , it’ll give you the following suggestions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans 的代码自动完成工具还会自动完成子词。这取决于你输入的字母，但它会关联到这些字母相关的所有内容，而不仅仅是以这些字母开头的内容。因此，即使你忘记了项目的首字母，它仍然可以正常工作！举个例子，如果你输入
    **Binding.prop**，它会提供以下建议：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you need a chain of commands, press *Ctrl* + the space bar twice, and all
    available chains will be displayed. It looks for variables, fields, and methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一系列命令时，按 *Ctrl* + 空格键两次，所有可用的命令链都会显示出来。它会查找变量、字段和方法。
- en: 'For example, if you type in the string **bindName =** , the completion tool
    can display the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，当你输入字符串 **bindName =** 时，自动完成工具可以显示以下内容：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are even more ways that NetBeans’ code completion tool helps you code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans 的代码自动完成工具还以更多方式帮助你编码。
- en: 'Go here for a tutorial on how to implement the Editor Code Completion API in
    the context of HTML files: [https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)
    [ Netbeans_Completion, Netbeans_SmartCode].'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何在 HTML 文件的上下文中实现编辑器代码自动完成 API 的教程，请访问：[https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)
    [ Netbeans_Completion, Netbeans_SmartCode]。
- en: However, there are some drawbacks to NetBeans’ code completion tool. Performance
    can sometimes be an issue with NetBeans, especially when working with larger projects.
    The code completion feature might be slower compared to more specialized tools
    designed specifically for code completion. This can be particularly noticeable
    when dealing with large code bases or projects and all their dependencies. The
    delay in suggestions can disrupt the coding flow and reduce overall productivity.
    Also, NetBeans does have a comprehensive set of features, but it may not provide
    as many advanced capabilities as some commercial IDEs. For example, commercial
    tools often have ML models to offer more sophisticated and context-aware code
    completions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，NetBeans 的代码自动完成工具也存在一些缺点。在处理较大项目时，性能有时会成为问题。与专门设计用于代码自动完成的工具相比，NetBeans
    的代码自动完成功能可能会较慢。这在处理大型代码库或项目及其所有依赖项时尤为明显。建议的延迟可能会打乱编码流畅性，降低整体生产力。此外，尽管 NetBeans
    提供了一整套功能，但它可能不像一些商业 IDE 那样提供那么多高级功能。例如，商业工具通常拥有机器学习模型，能够提供更复杂和上下文感知的代码自动完成。
- en: These advanced tools can provide more accurate suggestions, especially in complex
    coding scenarios. NetBeans, while robust, might not have some of these cutting-edge
    features, which can be a limitation for developers looking for the most advanced
    tools around.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高级工具能够提供更准确的建议，尤其是在复杂的编码场景中。虽然 NetBeans 非常强大，但可能缺少一些这些前沿功能，这对寻找最先进工具的开发者来说是一个限制。
- en: Despite these limitations, NetBeans’ code completion remains a highly valuable
    tool for many developers. Its user-friendly interface, cross-platform compatibility,
    and open source nature make it an attractive option for a wide range of users.
    The ability to customize the behavior of code completion makes it even more useful
    for your coding, so you can tailor the tool, just like PyCharm’s tool [NetBeans_Completion].
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些局限性，NetBeans 的代码自动完成仍然是许多开发者高度重视的工具。其用户友好的界面、跨平台兼容性和开源特性，使其成为广泛用户的有吸引力选择。能够自定义代码自动完成的行为，使它对于你的编码更加有用，你可以像使用
    PyCharm 的工具一样定制它 [NetBeans_Completion]。
- en: 'Here are some pros of using NetBeans’ code completion feature:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NetBeans 代码自动完成功能的一些优点如下：
- en: It has an intuitive interface for easy use
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有直观的界面，易于使用
- en: It works on Windows, OSX, and Linux
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持 Windows、OSX 和 Linux 操作系统
- en: It is free and open source, making it accessible to all developers
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是免费的并且是开源的，使得所有开发者都能使用
- en: 'Here are some cons of using NetBeans’ code completion feature:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NetBeans 代码自动完成功能的一些缺点如下：
- en: It can sometimes be slower than more specialized code completion tools
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有时会比更专业的代码自动完成工具慢
- en: It may not offer as many advanced features as some commercial IDEs
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能不像一些商业 IDE 那样提供那么多高级功能
- en: In summary, NetBeans’ code completion feature is a robust, versatile tool that
    helps the development experience a lot. Its intuitive interface, cross-platform
    support, and open source accessibility make it an excellent choice for developers.
    While it may not always match the performance or advanced capabilities of specialized
    commercial tools, its comprehensive feature set and ease of use make it a solid
    choice for a lot of coding environments. So, if you’re an experienced developer
    or a newbie, NetBeans’ code completion can help streamline your coding process
    and improve your productivity. Let the tools do the heavy lifting. They say that
    a lazy coder is the best coder. Make and get tools that help you. Don’t do everything
    yourself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，NetBeans 的代码补全功能是一个强大且多功能的工具，可以极大地帮助开发体验。其直观的界面、跨平台支持以及开源可访问性，使其成为开发者的优秀选择。虽然它可能无法与专门的商业工具在性能或高级功能上相媲美，但其全面的功能集和易用性使其成为许多编码环境中的坚实选择。因此，无论你是经验丰富的开发者还是新手，NetBeans
    的代码补全都能帮助简化你的编码过程，提高你的工作效率。让工具帮你完成繁重的工作。人们常说，懒惰的程序员是最好的程序员。制作并获取能帮你提高效率的工具，不必事事亲力亲为。
- en: 'Learn more about NetBeans’ code completion tool right here: [https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)
    .'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于 NetBeans 代码补全工具的信息，请访问：[https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)。
- en: VS Code’s IntelliSense
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VS Code 的 IntelliSense
- en: VS Code is offered by Microsoft. One of its best features is IntelliSense. IntelliSense
    analyzes the context of your code to provide relevant suggestions, including method
    calls, variables, and keywords, making coding faster and reducing the likelihood
    of errors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 是由 Microsoft 提供的，其中一个最佳特性就是 IntelliSense。IntelliSense 会分析代码的上下文，提供相关的建议，包括方法调用、变量和关键字，从而加快编码速度并减少出错的可能性。
- en: One of the primary advantages of IntelliSense is its lightweight nature. Despite
    its powerful capabilities, VS Code remains fast and efficient, even when working
    with large projects. This performance efficiency is crucial for developers who
    need a responsive and reliable coding environment. The lightweight design ensures
    that IntelliSense can provide real-time suggestions without causing significant
    delays or performance issues, even in extensive code bases.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliSense 的主要优点之一是它的轻量化特性。尽管功能强大，VS Code 仍然保持着快速和高效的性能，即使在处理大型项目时也不例外。这种性能效率对于需要一个响应迅速且可靠的编码环境的开发者来说至关重要。轻量化的设计确保
    IntelliSense 能够提供实时建议，而不会导致显著的延迟或性能问题，即使是在庞大的代码库中也是如此。
- en: Like the tools from PyCharm and NetBeans, IntelliSense is also highly customizable,
    offering a wide range of options to tailor the tool to your specific needs. Developers
    can configure various aspects of IntelliSense, such as the types of suggestions
    it provides and the triggers for displaying these suggestions. This customization
    allows you to create a coding environment that aligns with your workflow and preferences.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PyCharm 和 NetBeans 的工具类似，IntelliSense 也是高度可定制的，提供广泛的选项来根据你的特定需求调整工具的设置。开发者可以配置
    IntelliSense 的各个方面，例如它提供的建议类型以及触发这些建议显示的条件。这种定制化允许你创建一个与你的工作流和偏好相匹配的编码环境。
- en: VS Code also allows user-defined snippets, enabling you to create and use custom
    code templates that can be quickly inserted into your code. This is now available
    in many IDEs but it’s a useful tool to have and make use of.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 还允许用户定义代码片段，使你能够创建并使用自定义代码模板，这些模板可以迅速插入到你的代码中。这项功能现在已经在许多集成开发环境（IDE）中提供，但它仍然是一个非常实用的工具。
- en: The Visual Studio Marketplace offers a vast array of plugins that can extend
    the functionality of IntelliSense and the editor as a whole. These plugins cover
    a wide range of programming languages, frameworks, and tools, allowing developers
    to enhance their coding environment with additional features and capabilities.
    Whether you need support for a specific language, integration with version control
    systems, or tools for debugging and testing, the marketplace has a plugin to meet
    your needs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Marketplace 提供了大量插件，可以扩展 IntelliSense 和整个编辑器的功能。这些插件覆盖了各种编程语言、框架和工具，允许开发者通过附加的功能和能力来增强他们的编码环境。无论你需要某个特定语言的支持，还是需要与版本控制系统集成，或是需要调试和测试的工具，市场上都能找到满足你需求的插件。
- en: Let’s look at the negatives.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下它的负面影响。
- en: One thing to think about is that while IntelliSense offers good code completion,
    it may not be as specialized for certain programming languages or frameworks as
    some dedicated IDEs. For example, an IDE specifically designed for Java development
    might offer more advanced and context-aware suggestions for Java code compared
    to VS Code. However, the large list of plugins helps mitigate this limitation
    by allowing you to add language-specific extensions that enhance IntelliSense’s
    capabilities for your preferred languages and frameworks.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using VS Code’s IntelliSense:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightweight** : It is fast and efficient, even for large projects'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Highly customizable** : It offers a wide range of customization options'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET support** : IntelliSense has strong support for .NET languages, such
    as C#, F#, and VB.NET, and it excels in these languages'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using VS Code’s IntelliSense:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**Variable performance** : IntelliSense’s accuracy and completeness depend
    on language and project setup. Less common languages and more complex projects
    can see IntelliSense underperform.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential performance overhead** : In complex projects, IntelliSense might
    consume more system resources than some alternative tools.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, VS Code’s IntelliSense is a really useful tool for developers. Its
    lightweight design, high customizability, and all those plugins make it a valuable
    choice for a lot of different coding tasks. You can tailor IntelliSense to how
    you like to work, so it can assist you in a way that fits in with how you enjoy
    working.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s more information about VS Code’s IntelliSense: https://code.visualstudio.com/docs/editor/intellisense
    .'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s get into the SCA and the code review tools.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: SCA tools help you to find issues before running code, analyze large code bases,
    and automate routine checks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Code review tools help experienced coders suggest improvements to code, help
    teams collaborate more, and also think about the wider environment of the code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: SCA and code review tools
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCA and code review tools have become indispensable in modern software development,
    playing a critical role in ensuring code quality and reliability before the code
    is executed. These tools meticulously analyze source code to identify potential
    bugs, security vulnerabilities, style inconsistencies, and other issues that could
    compromise the software. By catching these problems early in the development process,
    SCA tools help maintain high standards of software quality, reduce the risk of
    defects in production, and ultimately save time and resources.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary benefits of SCA tools is their ability to provide immediate
    feedback to developers. As code is written, these tools scan the source code and
    highlight potential issues, allowing developers to address them on the spot. This
    real-time feedback loop is invaluable for maintaining code quality and ensuring
    that best practices are followed consistently. Additionally, SCA tools often integrate
    seamlessly with popular IDEs and CI/CD pipelines, making them an integral part
    of the development workflow.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: There are several well-known SCA tools available, each with its own set of features
    and capabilities. For example, SonarQube is a widely used tool that supports multiple
    programming languages and provides comprehensive reports on code quality, security
    vulnerabilities, and technical debt. It offers detailed insights into code issues
    and suggests possible fixes, helping developers improve their code base over time.
    Another popular tool is ESLint, which is specifically designed for JavaScript
    and TypeScript. ESLint allows developers to enforce coding standards and catch
    common errors, making it an essential tool for frontend development.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SonarQube** is a widely used static analysis tool that supports multiple
    programming languages, including Java, C#, and JavaScript. It provides a platform
    for continuous inspection of code quality, enabling teams to detect bugs, vulnerabilities,
    and code smells. This tool is for maintaining high standards of software quality
    and making sure the code is reliable and secure before it gets to production.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube can detect bugs and vulnerabilities in code repositories. By scanning
    the source code, SonarQube finds potential issues that could lead to runtime errors
    or security breaches. This proactive approach allows developers to address problems
    early in the development process, reducing the risk of costly fixes later on.
    The tool provides detailed insights into what the bugs and vulnerabilities are,
    helping developers understand the root causes and think of the best solutions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube also has a lot of code metrics that are great for maintaining high-quality
    code. These metrics include code coverage, complexity, and duplication rates.
    Code coverage measures the extent to which the code base is tested by automated
    tests, providing an indication of the robustness of the testing process. Complexity
    metrics help identify overly complicated code that may be difficult to maintain
    or prone to errors. Duplication rates highlight areas of the code base where similar
    code is repeated, suggesting opportunities for refactoring to improve maintainability
    and reduce technical debt.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube’s integration with CI/CD pipelines is another significant advantage.
    By integrating SonarQube into the CI/CD process, teams can ensure that code quality
    checks are an integral part of the development workflow. This integration allows
    for automatic code analysis with every commit, providing immediate feedback to
    developers and preventing the introduction of new issues into the code base. The
    integration with popular CI/CD tools, such as Jenkins, Azure DevOps, and GitLab,
    makes it easy to incorporate SonarQube into existing development processes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Using SonarQube is straightforward. To analyze a project, developers can use
    the SonarQube scanner, a command-line tool that sends the code to the SonarQube
    server for analysis. For example, to analyze a Java project, you’d do the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'First, download it at the following link: [https://www.sonarsource.com/products/sonarqube/](https://www.sonarsource.com/products/sonarqube/)
    .'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install SonarScanner with [https://docs.sonarsource.com/sonarqube/9.7/analyzing-source-code/scanners/sonarscanner/](https://docs.sonarsource.com/sonarqube/9.7/analyzing-source-code/scanners/sonarscanner/)
    .
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure SonarScanner by creating a **sonar-project.properties** file in the
    root directory of the Java project:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Specify the project key, name, and source directories:'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, you would run the following command to analyze the project:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command specifies the project key and the source directory to be analyzed.
    The results of the analysis are then available on the SonarQube dashboard, where
    developers can review the findings and take appropriate action.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Despite its many advantages, SonarQube is not without its challenges. One potential
    negative is the possibility of false positives, where the tool flags an issue
    that is not actually a problem. This can lead to unnecessary work for developers
    and may cause frustration. Additionally, while SonarQube does a pretty comprehensive
    analysis, it may not catch all types of issues, particularly those related to
    the runtime behavior of the code. Therefore, it is important to use static analysis
    with other testing methods, such as unit testing and integration testing, to ensure
    comprehensive coverage.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using SonarQube:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube supports a wide range of programming languages, making it able to
    help in diverse projects
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides detailed reports on code quality, allowing teams to prioritize issues
    effectively
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A strong community and a variety of plugins enhance SonarQube’s functionality
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a free version and paid versions for more functionality
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using SonarQube:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube can sometimes produce false positives, which developers should review
    carefully
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running SonarQube can be resource-intensive, particularly for large code bases,
    which may require dedicated infrastructure
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, SonarQube is a useful tool for SCA and continuous inspection
    of code quality. Its ability to detect bugs, vulnerabilities, and code smells,
    combined with its comprehensive code metrics and seamless integration with CI/CD
    pipelines, makes it an invaluable asset for development teams. By incorporating
    SonarQube into the development process, teams can maintain high standards of software
    quality, reduce the risk of defects, and deliver reliable and secure software
    solutions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'More information can be found at SonarQube’s site: [https://www.sonarsource.com/products/sonarqube/](https://www.sonarsource.com/products/sonarqube/)
    .'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: ESLint
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ESLint** is a static analysis tool specifically for JavaScript and JSX. (JSX
    is an XML-like extension for Javascript.) ESLint plays an important role in modern
    web development by helping developers keep to coding standards and identify problematic
    patterns in their code. This tool is helpful for maintaining code quality and
    consistency across projects, making it a favorite among developers working with
    JavaScript.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Like the code completion tools, ESLint has customizable rules. ESLint allows
    users to define their own rules and share configurations across teams, promoting
    consistency in coding practices. This flexibility ensures that teams can stick
    to their specific coding standards, no matter what the project’s requirements
    are. For instance, you can create rules that enforce the use of single quotes
    for strings or require semicolons at the end of statements. You can also specify
    indentation style, variable naming conventions, function length, and even code
    complexity. This level of customization helps maintain a uniform code style, which
    is particularly beneficial in large teams or open source projects where multiple
    contributors are involved.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Another feature ESLint has is its easy integration with CI/CD pipelines. By
    integrating ESLint into the CI/CD process, developers can ensure that code quality
    checks are performed automatically before deployment. This integration helps catch
    issues early in the development cycle, reducing the risk of bugs and inconsistencies
    making it into production. Popular CI/CD tools, such as Jenkins, Travis CI, and
    GitHub Actions, support ESLint, making it easy to incorporate into existing workflows.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: ESLint also offers robust fixing capabilities. Many of the issues detected by
    ESLint can be automatically fixed, saving you time and effort in your development.
    For example, if ESLint detects a missing semicolon or an incorrect quote style,
    it can automatically correct these issues based on the defined rules. This auto-fix
    feature is particularly useful for addressing minor code style violations, allowing
    developers to focus on more complex tasks.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Using ESLint is straightforward. Developers can configure ESLint by creating
    a configuration file, typically named **.eslintrc.js** , which defines the environment,
    extends configurations, and specifies the rules. Here is an example of an ESLint
    configuration:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**env** : This specifies the environment in which the code will be run. In
    this case, it’s configured for both browser and ES6 environments.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**extends** : This setting extends the recommended ESLint ruleset, providing
    a good starting point for enforcing common coding standards.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rules** : This section allows you to customize specific rules. Here, you’ve
    enforced the use of semicolons and single quotes.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite its many advantages, ESLint does have some issues. One possible challenge
    is the initial setup. Configuring ESLint to fit a team’s specific needs requires
    lots of time, especially for new users who may find the extensive configuration
    options overwhelming. However, once set up, ESLint provides significant long-term
    benefits in terms of code quality and consistency.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to think about is the learning curve associated with ESLint. While
    the tool is highly configurable, new users may need time to become familiar with
    its features and how to customize it effectively. Fortunately, ESLint has an active
    community that contributes to a wealth of plugins and shared configurations, providing
    ample resources and support for new users.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using ESLint:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**Highly configurable** : ESLint’s flexibility allows teams to enforce their
    coding standards effectively'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active community** : A large community contributes to a wealth of plugins
    and shared configurations'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using ESLint:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup time** : ESLint requires an initial investment of time to configure
    rules that fit a team’s needs.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**False positives** : Similar to some other tools in this chapter, ESLint may
    sometimes flag issues that are not actual errors or violations of coding standards;
    these are false positives. This can be frustrating and can mean you have to make
    extra code changes for no benefit.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ESLint can be restrictive, enforcing strict rules that may not always be appropriate
    for certain code styles or use cases.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, ESLint is a very helpful tool for JavaScript and JSX development.
    Its customizable rules, integration with CI/CD pipelines, and automatic fixing
    capabilities make it a powerful ally in sticking to high code quality and consistency.
    While it may require an initial investment of time to configure and a learning
    curve for new users, the benefits it offers in terms of productivity and code
    reliability make it well worth the effort. Whether you are working on a small
    project or a large-scale application, ESLint can help ensure that your code adheres
    to best practices and remains maintainable over time. As you may have seen in
    previous chapters, code standards can be rather stringent and detailed, so having
    tools to keep to these can be a great help.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'More information can be found at ESLint’s official site: [https://eslint.org/](https://eslint.org/)
    .'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: PMD
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PMD** is an open source SCA tool that is helpful for developers to identify
    potential issues in their code. It supports a few programming languages, including
    Java, JavaScript, and XML (with some support for C, C++, C#, Python, and PHP).
    PMD is mainly for Java. It focuses on finding common programming flaws, such as
    unused variables, empty catch blocks, and unnecessary object creation. This makes
    PMD a great tool for maintaining high standards of code quality and ensuring that
    software is reliable and efficient, especially in Java.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: One of the features of PMD is its rule-based analysis. PMD uses a set of predefined
    rules to analyze code and identify potential issues. These rules cover a wide
    range of common programming mistakes and best practices, helping developers catch
    errors early in the development process. The predefined rules are comprehensive
    and cover various aspects of coding, from syntax errors to more complex logical
    issues. This thorough analysis helps in maintaining a clean and efficient code
    base.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: In addition to its predefined rules, PMD allows you, as a developer, to create
    custom rules tailored to your desired coding standards and practices. This customizability
    is one of PMD’s best features, as it enables teams to enforce their unique coding
    guidelines and ensure consistency across projects. Custom rules can be written
    in Java or using XPath queries, providing flexibility in how they are defined
    and implemented. This ability to tailor the tool to specific needs makes PMD highly
    adaptable to different development environments and requirements.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'PMD also integrates with popular build tools, such as Maven and Gradle (the
    PMD Maven plugin is available at [https://github.com/apache/maven-pmd-plugin](https://github.com/apache/maven-pmd-plugin)
    and the PMD Gradle plugin is available at [https://docs.gradle.org/current/userguide/pmd_plugin.html](https://docs.gradle.org/current/userguide/pmd_plugin.html)
    ), making it easy to incorporate into existing workflows. This integration ensures
    that code quality checks are an integral part of the build process, providing
    continuous feedback to developers and preventing the introduction of new issues
    into the code base. By running PMD as part of the build process, teams can catch
    and address issues early, reducing the risk of defects in production. For example,
    to run PMD on a Java project using Maven, you would use the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run this in bash. This command triggers PMD to analyze the project and generate
    a report on any issues found, allowing developers to review and address them promptly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Despite its many advantages, PMD does have some limitations. One potential thing
    is its limited language support. While PMD supports several languages, its primary
    focus is on Java, which may not suit all projects. This can be a limitation for
    teams working with a diverse set of programming languages. However, PMD does support
    other languages, such as JavaScript, Salesforce Apex, and more, which can still
    be beneficial for many projects.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration is the complexity of configuring PMD with custom rules.
    Setting up PMD to enforce specific coding standards can be complex, especially
    for new users who may not be familiar with the tool’s configuration options. This
    is similar to some other tools in this chapter. This initial setup requires an
    investment of time and effort, but the long-term benefits of having a tailored
    static analysis tool can be significant. You’ll most likely find that the one-time
    time investment is really worth it for all the repeated help every day.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using PMD:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: PMD is free to use, making it accessible for developers and teams of all sizes
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to create custom rules allows teams to enforce their specific coding
    standards
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using PMD:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: While PMD supports several languages, its primary focus is on Java, which may
    not suit all projects
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up PMD with custom rules can be complex for new users
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, PMD is a SCA tool for Java and other languages that helps developers
    maintain high standards of code quality. Its rule-based analysis, customizability,
    and integration with build tools make it a good tool for many development teams.
    While it may have some limitations in terms of language support and configuration
    complexity, the benefits it offers in terms of identifying potential issues and
    enforcing coding standards make it a valuable asset in the software development
    process. By incorporating PMD into their workflows, your teams can ensure that
    your code is reliable, efficient, and adheres to best practices, ultimately leading
    to higher-quality software.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'More information can be found at PMD’s site: [https://pmd.github.io/](https://pmd.github.io/)
    .'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Checkstyle for Java
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve already gone through a few tools, I shall make this brief.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkstyle** is a valuable tool for ensuring Java code adheres to predefined
    coding standards. By automating code checks, it maintains consistency and quality
    across projects, making code easier to read, understand, and maintain.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of its key features:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: It checks code against customizable rules for naming conventions, formatting,
    design patterns, and more
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It seamlessly integrates with Eclipse and IntelliJ IDEA for real-time feedback
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to define your own rules to match specific coding practices
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how it works:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Configure Checkstyle in your build tool (e.g., Maven, Gradle) to specify your
    desired ruleset.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checkstyle analyzes your Java code against these rules.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It generates reports highlighting violations and provides suggestions for improvement.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is an example (Maven).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'This is XML code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here are some of the pros of using Checkstyle:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus on Java** : Checkstyle is specifically designed for Java, making it
    highly effective for Java projects'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time feedback** : Integration with IDEs allows developers to receive
    immediate feedback on coding standards'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some of the cons of using Checkstyle:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**Java only** : Checkstyle is limited to Java, which may not be suitable for
    multi-language projects'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration overhead** : Setting up and maintaining Checkstyle configurations
    can be time-consuming'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using Checkstyle, you can ensure your Java code meets high-quality standards,
    promoting readability, maintainability, and team collaboration.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '**Source** : [https://github.com/jvalentino/jenkins-agent-maven](https://github.com/jvalentino/jenkins-agent-maven)
    .'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information here: [https://checkstyle.sourceforge.io/](https://checkstyle.sourceforge.io/)
    .'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Fortify Static Code Analyzer
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Fortify** , developed by OpenText, is a commercial static analysis tool that
    excels at identifying security vulnerabilities in source code. It supports a wide
    range of programming languages, making it a versatile choice for diverse development
    teams.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key features of Fortify:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Fortify’s deep analysis capabilities uncover a broad spectrum of security risks
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can generate actionable reports with remediation guidance to address identified
    vulnerabilities effectively
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can integrate Fortify into your CI/CD pipeline for continuous security checks
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how it works:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Run Fortify on your code to identify vulnerabilities.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review detailed reports for insights and remediation guidance.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrate Fortify into your development workflow for continuous security checks.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are some pros of using Fortify:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: It is ideal for large-scale projects and organizations
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It detects a wide range of vulnerabilities
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides clear guidance for remediation
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using Fortify:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: It requires a commercial license
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial setup and configuration can be involved
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, Fortify is a valuable tool for organizations looking to strengthen
    their software security posture. While it requires an investment, the benefits
    in terms of vulnerability detection and risk mitigation can be substantial. By
    incorporating Fortify into your development process, you can ensure that your
    code meets the highest security standards.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortify’s official site gives more information: [https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview](https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview)
    .'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more sources:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.microfocus.com/documentation/fortify-static-code-analyzer-and-tools/2310/](https://www.microfocus.com/documentation/fortify-static-code-analyzer-and-tools/2310/)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.opentext.com/products/fortify-static-code-analyzer](https://www.opentext.com/products/fortify-static-code-analyzer)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://bing.com/search?q=Fortify+Static+Code+Analyzer+summary](https://bing.com/search?q=Fortify+Static+Code+Analyzer+summary)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.microfocus.com/media/data-sheet/fortify_static_code_analyzer_static_application_security_testing_ds.pdf](https://www.microfocus.com/media/data-sheet/fortify_static_code_analyzer_static_application_security_testing_ds.pdf)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://gemini.google.com/](https://gemini.google.com/)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://copilot.microsoft.com/](https://copilot.microsoft.com/)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeSonar
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CodeSonar** , a static analysis tool from GrammaTech, also called a **static
    application security testing** ( **SAST** ) tool, is an excellent tool for ensuring
    code quality and safety, especially in critical industries, such as automotive,
    aerospace, and medical devices.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of its key features:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: It uncovers a wide range of issues, from memory leaks to concurrency problems
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It works smoothly with popular IDEs and build systems
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps you understand complex code structures with visual aids
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how it works:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: CodeSonar scans your code for potential issues.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detailed reports highlight vulnerabilities and provide insights.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Easily integrate CodeSonar into your development workflow.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the pros of using CodeSonar:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: It catches bugs before they become costly problems
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It ensures high-quality, safe code
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It understands your code’s structure and dependencies
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the cons of using CodeSonar:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: It may require a license
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can take time to master its features
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial setup might require effort
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, CodeSonar is a valuable tool for maintaining code quality and
    safety. While it may have a learning curve and require an investment, the benefits
    it offers in terms of preventing costly errors and ensuring reliable software
    make it a worthwhile consideration for many development teams.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn more about it at CodeSonar’s site: https://codesecure.com/our-products/codesonar/
    .'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Coverity
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Coverity** , by Synopsys, is a static analysis tool that empowers development
    teams in enterprise environments to identify and fix defects early in the software
    development life cycle.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are its key features:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Coverity scans code for a wide range of issues, providing detailed reports and
    remediation guidance
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It integrates seamlessly with popular CI/CD tools for automated code quality
    checks
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can monitor code health metrics and track progress over time with customizable
    dashboards
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the pros of using Coverity:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: It proactively detects defects and vulnerabilities, strengthening code health
    and security
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It catches issues early, reducing costly bug fixes later in the development
    process
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can gain insights into code quality through customizable dashboards
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the cons of using Coverity:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: It requires a commercial license, which may not be feasible for small teams
    or individual developers
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial setup can be complex and require dedicated resources
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensive features and configuration options have a learning curve for new users
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, for large-scale projects, Coverity’s comprehensive defect detection,
    CI/CD integration, and customizable dashboards make it a valuable tool for maintaining
    high code quality and security. While there’s a cost and learning curve, the long-term
    benefits outweigh them for many development teams.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Popular CI/CD tools, such as Jenkins ( [https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/](https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/)
    ), GitLab, and Azure DevOps, support Coverity, making it easy to integrate into
    existing development processes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'See the Coverity site for more information: [https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html](https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html)
    .'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the sources: [https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/](https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/)
    , [https://www.trustradius.com/products/synopsys-coverity-static-application-security-testing-sast/reviews?qs=pros-and-cons](https://www.trustradius.com/products/synopsys-coverity-static-application-security-testing-sast/reviews?qs=pros-and-cons)
    , [https://www.gartner.com/reviews/market/application-security-testing/vendor/synopsys/product/coverity-static-application-security-testing](https://www.gartner.com/reviews/market/application-security-testing/vendor/synopsys/product/coverity-static-application-security-testing)
    , [https://stackshare.io/coverity-scan](https://stackshare.io/coverity-scan) ,
    [https://www.softwareadvice.com/app-development/coverity-static-analysis-profile/](https://www.softwareadvice.com/app-development/coverity-static-analysis-profile/)
    , [https://en.wikipedia.org/wiki/Coverity](https://en.wikipedia.org/wiki/Coverity)
    , [https://gemini.google.com/](https://gemini.google.com/) , [https://copilot.microsoft.com/](https://copilot.microsoft.com/)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: FindBugs/SpotBugs
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SpotBugs** , which succeeded FindBugs, is a specialized static analysis tool
    designed for Java that excels at detecting potential bugs in Java code. By leveraging
    a comprehensive set of bug patterns, it identifies common coding mistakes, ensuring
    higher code quality and reliability. SpotBugs operates by analyzing Java bytecode,
    which allows it to uncover potential issues based on a predefined set of patterns.
    This method of analysis is particularly effective in pinpointing bugs that might
    not be immediately apparent through manual code reviews.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: One of the best features of SpotBugs is its great integration with popular build
    tools, such as Maven and Gradle. This integration facilitates its inclusion in
    existing development workflows, making it a convenient choice for CI/CD pipelines.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: SpotBugs is known for its user-friendly setup and ease of use, which makes it
    accessible to developers of all skill levels. Whether you are a novice developer
    or an experienced professional, SpotBugs provides a straightforward way to enhance
    your code’s robustness. Its ability to integrate smoothly into various development
    environments and its ease of use make it a valuable tool for maintaining high
    standards of code quality in Java projects.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, run this in bash:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are the pros of using SpotBugs:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '**Free and open source** : SpotBugs is free to use, making it accessible for
    developers and teams'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Focus on Java** : Its specialization in Java means it provides highly relevant
    analyses for Java projects'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the cons of using SpotBugs:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Limited language support** : SpotBugs is specifically for Java, which may
    limit its usability for multi-language projects.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**False positives** : Like many static analysis tools, it can produce false
    positives that require manual review.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, SpotBugs is a static analysis tool for Java developers, offering
    a robust solution for identifying and rectifying potential bugs. Its ease of integration
    with build tools and user-friendly setup make it accessible to developers at all
    levels, ensuring that high standards of code quality are maintained across projects.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information can be found on the SpotBugs site: [https://spotbugs.github.io/](https://spotbugs.github.io/)
    .'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bandit
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Bandit** is an SCA, or rather a SAST, tool that helps you identify security
    vulnerabilities in Python code. It scans for common issues, such as hardcoded
    passwords and insecure API usage, ensuring your Python applications remain secure.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are its key features:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '**Comprehensive vulnerability detection** : It identifies a wide range of security
    risks'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customizable rules** : Tailor Bandit to your specific needs'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CI/CD integration** : Automate security checks for continuous monitoring'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a usage example, run this in bash:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here are the pros of using Bandit:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '**Python-specific** : Bandit is tailored for Python, making it highly effective
    for identifying security issues in Python code'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open source** : As an open source tool, Bandit is free to use and accessible
    to all developers'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the cons of using Bandit:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited to Python** : Bandit is specifically designed for Python, so it may
    not be suitable for projects that use multiple languages'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**False positives** : Like many static analysis tools, Bandit can generate
    false positives that require manual review'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, Bandit is a valuable tool for Python developers focused on security.
    Its ability to detect a wide range of security vulnerabilities, coupled with customizable
    rules and seamless CI/CD integration, makes it an essential asset for maintaining
    secure code bases. By incorporating Bandit into their development workflows, developers
    can proactively address security risks and ensure that their applications remain
    secure against potential threats.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out Bandit’s site: [https://bandit.readthedocs.io/](https://bandit.readthedocs.io/)
    .'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: HoundCI
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**HoundCI** is a GitHub-integrated tool that enforces code quality standards.
    It provides real-time feedback on pull requests, ensuring clean, consistent code.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are its key features:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: It identifies style violations and issues during pull requests
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It tailors HoundCI to your specific coding standards
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It works with various programming languages
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the pros of using HoundCI:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: HoundCI provides immediate feedback on code style issues, helping teams maintain
    consistent coding practices
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The seamless integration with GitHub makes it easy to incorporate into existing
    workflows
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the cons of using HoundCI:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: HoundCI focuses primarily on style and best practices, which may not cover deeper
    static analysis needs
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is specifically designed for GitHub repositories, limiting its usability
    for teams using other version control systems
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See more at HoundCI’s official site: [https://houndci.com/](https://houndci.com/)
    .'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the sources: [https://github.com/houndci/hound](https://github.com/houndci/hound)
    , [https://github.com/marketplace/hound](https://github.com/marketplace/hound)
    , [https://www.houndci.com/configuration](https://www.houndci.com/configuration)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at testing and debugging tools. Testing and debugging tools
    are also essential for ensuring the quality and reliability of software. They
    help identify and fix errors early in the development process, preventing potential
    issues from affecting end users and saving time and resources.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Testing and debugging tools
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing and debugging tools are also critical components in the software development
    life cycle, ensuring that code functions correctly and meets quality standards.
    These tools help identify issues early in the development process, ultimately
    saving time and resources by addressing potential problems before they escalate.
    In this section, we will explore various testing and debugging tools and their
    features, advantages, and limitations, with a focus on how they can enhance your
    development workflow.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Jest
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Jest** is a widely used testing framework developed by Christoph Nakazawa,
    now Meta, but is an open source project with many developers. It’s particularly
    popular among JavaScript developers. It provides a comprehensive testing solution
    for JavaScript applications, focusing on simplicity and ease of use. Jest is especially
    favored for testing React applications, but it can also be used with other frameworks
    and libraries.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: One good feature of Jest is its snapshot testing capability. This allows developers
    to capture snapshots of component output, making it easy to verify that changes
    to the code do not introduce unintended side effects. When a component renders,
    Jest compares the output to a previously saved snapshot. If there are differences,
    Jest alerts the developer, enabling them to review the changes and ensure everything
    is functioning as expected. Jest also comes equipped with robust mocking capabilities,
    which allow developers to isolate components during testing. This is particularly
    useful when testing components that rely on external services or APIs. By mocking
    these dependencies, developers can focus on testing the component’s logic without
    concerning themselves with the behavior of external resources.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example with JavaScript code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While Jest is a powerful tool, it is essential to recognize that it may not
    be suitable for every testing scenario. For instance, in complex applications
    that require more specialized testing strategies, such as end-to-end testing or
    performance testing, developers may need to complement Jest with additional tools
    designed specifically for those purposes.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, Jest stands out as an excellent framework for unit and integration
    testing, helping developers maintain high-quality code throughout their projects.
    If you’d like more details and resources, you can visit Jest’s official site:
    [https://jestjs.io/](https://jestjs.io/) .'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Postman** is a leading tool for testing APIs, providing developers with a
    user-friendly interface to send requests and analyze responses. It simplifies
    the process of interacting with APIs, making it accessible for both seasoned developers
    and newcomers alike.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: One of Postman’s key features is its ability to create automated tests. Users
    can write test scripts that run automatically after sending requests, verifying
    that the API behaves as expected. This feature is invaluable for ensuring that
    API endpoints return the correct status codes, headers, and response bodies. By
    automating these tests, developers can quickly identify issues and maintain the
    integrity of their APIs as they evolve.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Postman also offers a collection runner, which allows users to group requests
    into collections and execute them in sequence. This is particularly useful for
    testing workflows that involve multiple API calls. For example, if an application
    requires a user to be authenticated before accessing certain endpoints, a developer
    can create a collection that first sends a login request and then proceeds to
    call protected endpoints. This sequential testing capability helps simulate real-world
    scenarios and ensures that the entire flow works as intended.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example in JavaScript:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Although Postman is feature-rich and widely regarded as an essential tool for
    API testing, it does come with a learning curve for those unfamiliar with API
    testing concepts. New users may need time to familiarize themselves with Postman’s
    interface and capabilities, but the investment is often well worth it.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'As a tool that supports collaboration among development teams, Postman enhances
    communication and streamlines the process of API development and testing. You
    can visit Postman’s official site for more information: [https://www.postman.com/](https://www.postman.com/)
    .'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Cypress
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Cypress** is an end-to-end testing framework designed specifically for modern
    web applications. It provides a powerful and easy-to-use platform for writing
    tests that simulate user interactions, allowing developers to ensure that their
    applications function correctly from the user’s perspective.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: One of the notable features of Cypress is its real-time reloading capability.
    This means that as developers write tests, they can immediately see the results
    in the browser without needing to refresh manually. This instant feedback loop
    accelerates the development process and makes it easier to catch issues early.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Cypress also offers an intuitive time travel feature, which allows developers
    to pause test execution and inspect the application at any point in time. This
    is particularly useful for debugging failures, as developers can see exactly what
    the application looked like when a test failed, making it easier to identify the
    root cause of issues.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Also, Cypress integrates well with popular CI/CD tools, enabling automated testing
    in the development pipeline. This integration helps ensure that new code changes
    do not break existing functionality, maintaining the overall quality of the application.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of testing with Cypress is as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Cypress bash: **npm install** **cypress –save-dev** .'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open with bash: **npx** **cypress open** .'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the test:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the test suite you created (in this case, **My App** ).
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cypress will automatically run the test and display the results in the Test
    Runner UI.
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: While Cypress is a robust testing tool, it is primarily focused on web applications.
    Developers working with mobile applications or other environments may need to
    seek additional testing solutions. Additionally, the learning curve for new users
    can be steep, especially for those unfamiliar with JavaScript and asynchronous
    programming.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'For further details on Cypress, you can visit Cypress’s official site: [https://www.cypress.io/](https://www.cypress.io/)
    .'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Selenium
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Selenium** is a well-established open source testing framework that allows
    developers to automate browsers for testing web applications. It supports multiple
    programming languages, including Java, C#, Python, and Ruby, making it a versatile
    choice for testing across different platforms.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: One of the strengths of Selenium is its ability to simulate user interactions
    with a web application. Developers can write scripts that automate tasks, such
    as clicking buttons, filling out forms, and navigating between pages. This capability
    makes Selenium particularly useful for end-to-end testing, where the goal is to
    verify that all components of an application work together as intended.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Selenium also supports a variety of browsers, enabling developers to perform
    cross-browser testing. This is important for ensuring that applications behave
    consistently across different web browsers and OSs. With the rise of mobile devices,
    Selenium has also expanded its capabilities to include mobile browser testing
    through tools such as Appium.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Despite its strengths, Selenium does have a few negatives. Setting up and maintaining
    Selenium tests can be complex, especially for larger applications, similar to
    other tools here. Additionally, tests can sometimes be brittle, meaning they may
    fail due to minor changes in the application’s UI or behavior rather than actual
    bugs. Developers need to invest time in creating robust tests and managing the
    associated maintenance.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out Selenium’s website here: [https://www.selenium.dev/](https://www.selenium.dev/)
    .'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Mocha
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Mocha** is a flexible testing framework for JavaScript that runs on Node.js
    and in the browser. It is designed to do asynchronous testing, making it easier
    to test applications that rely on callbacks or promises.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: One of Mocha’s defining features is its simple syntax, which allows developers
    to write clear and expressive tests. This simplicity is particularly beneficial
    for teams that prioritize readability and maintainability in their test code.
    Mocha supports various assertion libraries, giving developers the freedom to choose
    the one that best fits their needs. Popular choices include Chai, Should.js, and
    Assert.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Mocha also provides a variety of reporting options, allowing developers to view
    test results in different formats. This flexibility makes it easier to integrate
    Mocha into existing development workflows and CI/CD pipelines.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'While Mocha is a good and efficient testing tool, one can note that it primarily
    focuses on unit testing. As a result, developers may need to complement Mocha
    with other tools for end-to-end or integration testing. Additionally, configuring
    Mocha can require some upfront effort, particularly for teams that are new to
    testing in JavaScript. For further details on Mocha, see here: [https://mochajs.org/](https://mochajs.org/)
    .'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Charles Proxy
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Charles Proxy** is a web debugging tool that allows developers to view all
    of the HTTP and SSL/HTTPS traffic between their computers and the internet. It
    acts as a proxy server, enabling developers to inspect and analyze requests and
    responses in real time.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary uses of Charles Proxy is for API testing and debugging. By
    capturing network traffic, developers can easily identify issues such as incorrect
    request parameters, unexpected response formats, or authentication problems. This
    visibility is invaluable when working with APIs, as it allows developers to troubleshoot
    problems quickly and effectively.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Charles Proxy also supports features such as request modification and response
    simulation. This means that developers can modify requests on the fly, allowing
    them to test various scenarios without making changes to the actual application
    code.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Charles Proxy can simulate different network conditions, enabling
    you to see how your application behaves under various circumstances.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Get the tool from [https://www.charlesproxy.com/](https://www.charlesproxy.com/)
    .
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure Charles Proxy:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If necessary, configure your system or browser to use Charles Proxy as the HTTP
    proxy. This usually involves setting the proxy settings in your browser or OS.
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open your application:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the web application you want to test.
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Intercept requests:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Charles Proxy, enable the **Breakpoints** feature.
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the **Tools** menu and select **Breakpoints** .
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the **Enable** **breakpoints** option.
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test your application:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform actions in your application that trigger HTTP requests. Charles Proxy
    will intercept these requests and pause them at the breakpoint.
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inspect and modify the request:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Charles Proxy, examine the intercepted request details, including the URL,
    headers, and request body.
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can modify the request parameters, headers, or body to simulate different
    scenarios.
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Continue the request:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To continue the request with the modified parameters, click the **Execute**
    button in Charles Proxy.
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing authentication** : Intercept the login request, modify the username
    or password, and observe the application’s response'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simulating network conditions** : Modify the request headers to simulate
    slow network speeds or different network types'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging API calls** : Inspect the request and response to identify issues
    or errors in API interactions'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While Charles Proxy is a great debugging tool, it may not be suitable for all
    use cases. Developers working on large-scale applications may find that the volume
    of traffic can become overwhelming, making it challenging to pinpoint specific
    issues. Furthermore, there can be a learning curve for new users, particularly
    when it comes to navigating the interface and configuring settings. Most of these
    tools take a lot of work to get into, but they’re worth it.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want more information about Charles Proxy, you can visit Charles Proxy’s
    official site: [https://www.charlesproxy.com/](https://www.charlesproxy.com/)
    .'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter sets the foundation for understanding the diverse range of non-LLM
    AI tools available to developers. By exploring their functionalities and best
    practices, you can better equip yourself with the knowledge to enhance your coding
    toolkit and workflow. For further reading and exploration of the tools discussed,
    please refer to the official websites linked throughout the chapter.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we delved into a diverse array of non-LLM AI tools for coding,
    highlighting their functionalities, capabilities, and limitations.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: We began by examining code completion and generation tools, such as Content
    Assist and PyCharm and NetBeans’ code completion tools, which significantly enhance
    coding efficiency by providing real-time suggestions and automating repetitive
    tasks.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we explored static analysis tools, such as SonarQube and ESLint,
    which play a crucial role in maintaining code quality and identifying potential
    issues early in the development process.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed testing and debugging tools, such as Jest and Postman,
    emphasizing their importance in ensuring that applications function correctly
    and meet user expectations.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: The integration of these tools into your coding workflow creates a robust toolkit
    that enhances various aspects of the software development process. While LLMs
    offer valuable assistance, leveraging non-LLM tools can maximize productivity
    and ensure that your code is not only functional but also clean, maintainable,
    and efficient. By utilizing a combination of these tools, developers can effectively
    tackle challenges, streamline their workflows, and improve overall code quality.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: This chapter helps developers without this knowledge begin to understand the
    extensive range of non-LLM AI tools available to developers. By exploring their
    functionalities and best practices, you can equip yourself with the knowledge
    necessary to enhance your coding toolkit and workflow.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Getting into and mastering these tools will empower you to elevate your development
    practices, leading to a more productive and effective coding experience.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'You.com is a good source of information on the software tools in this chapter:
    [https://you.com](https://you.com) [You.com].'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 11*](B21009_11.xhtml#_idTextAnchor279) , we’ll be looking at how
    to leverage LLMs to help other people and ultimately maximize your career: why
    you should mentor others, more ways to share your work, networking, and some fresh
    approaches to using LLMs.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Bibliography
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Aside from the sources mentioned earlier, here are some more:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '*Copilot* : Microsoft, [https://copilot.microsoft.com/](https://copilot.microsoft.com/)
    , [https://copilot.cloud.microsoft/en-GB/prompts](https://copilot.cloud.microsoft/en-GB/prompts)'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Eclipse_Help* : “Content Assist”, Eclipse, [https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm](https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm)'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Gemini* : [https://gemini.google.com/](https://gemini.google.com/)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jetbrains_Completion* : “Code completion”, JetBrains, [https://www.jetbrains.com/help/pycharm/auto-completing-code.html](https://www.jetbrains.com/help/pycharm/auto-completing-code.html)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jetbrains_refactoring* : “Refactor code”, JetBrains, [https://www.jetbrains.com/help/pycharm/refactoring-source-code.html](https://www.jetbrains.com/help/pycharm/refactoring-source-code.html)'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NetBeans_Completion* : “NetBeans Code Completion Tutorial”, Apache, [https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Netbeans_SmartCode* : “Code Assistance in the NetBeans IDE Java Editor: A
    Reference Guide: Smart Code Completion”, Apache: [https://netbeans.apache.org/tutorial/main/kb/docs/java/editor-codereference/#_smart_code_completion](https://netbeans.apache.org/tutorial/main/kb/docs/java/editor-codereference/#_smart_code_completion)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wiki_Include* : “include guard”, various, [https://en.wikipedia.org/wiki/Include_guard](https://en.wikipedia.org/wiki/Include_guard)'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*You.com* : [https://you.com](https://you.com)'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 4: Maximizing Your Potential with LLMs: Beyond the Basics'
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section explores ways to leverage LLMs for personal and professional growth.
    We will check out various AI tools that can amplify the capabilities of LLMs,
    creating a very robust AI toolkit. We will cover strategies for mentorship, community
    involvement, and also advancing your career in the field of LLM-powered coding.
    Lastly, we will see the various emerging trends and technological advancements
    and the long-term impact of LLMs on software development.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'This section covers the following chapters:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21009_11.xhtml#_idTextAnchor279) *,* *Helping Others and Maximizing
    Your Career with LLMs*'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B21009_12.xhtml#_idTextAnchor308) *,* *The Future of LLMs in
    Software Development*'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
