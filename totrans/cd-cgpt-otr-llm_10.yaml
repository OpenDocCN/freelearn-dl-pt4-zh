- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Expanding the LLM Toolkit for Coders: Beyond LLMs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the rapidly changing world of software development, LLMs, such as OpenAI’s
    GPT series and OpenAI o1, Google’s Gemini, and Meta’s Llama 3 have garnered significant
    attention for their ability to assist with coding tasks. However, while LLMs are
    powerful tools, they are not the only game in town. There exists a plethora of
    non-LLM AI tools designed to complement the coding process, enhancing productivity
    and efficiency. This chapter explores these tools, discussing their capabilities,
    limitations, and how they can be integrated into a comprehensive coding toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Code completion and generation tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static code analysis** ( **SCA** ) and code review tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and debugging tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to a browser to get these AI code tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A laptop or desktop to install the software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **integrated development environment** ( **IDE** ) for Python, such as Visual
    Studio, Spyder, IDLE, PyCharm, or Atom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An IDE for Javascript, such as Visual Studio, Atom, or Brackets. An online
    interpreter will not be good enough here. Here are some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://onecompiler.com/javascript](https://onecompiler.com/javascript)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://jipsen.github.io/js.html](https://jipsen.github.io/js.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A Java IDE, such as IntelliJ IDEA, Eclipse, or NetBeans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some code examples require bash (basic shell) for Unix **operating** **systems**
    ( **OSs** ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get the code in this chapter here: [https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter10](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter10)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s learn how to use non-LLM tools to make code generation, analysis,
    and testing much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Code completion and generation tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code completion and generation tools are designed to assist developers in writing
    code more efficiently. These tools leverage various techniques, including syntax
    analysis, semantic understanding, and **machine learning** ( **ML** ) algorithms,
    to predict and suggest code snippets as developers type. The usefulness of these
    tools can’t be overstated, as they streamline the coding process, reduce errors,
    and enhance overall productivity. In this section, we will explore several code
    completion and generation tools, their features, and practical examples to give
    you a good understanding of how they can be integrated into your coding workflow.
    Let’s explore some of the most popular tools available, including Eclipse’s Content
    Assist, PyCharm’s code completion tool, NetBeans’ code completion tool, and **Visual
    Studio Code’s** ( **VS** **Code’s** ) IntelliSense.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, these tools help the developer improve code accuracy, speed up development,
    learn new syntax and APIs, and make code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse’s Content Assist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eclipse, a versatile IDE, features a robust code completion plugin tool known
    as **Content Assist** . This tool enhances developer productivity by providing
    relevant suggestions as you type and analyzing the current context scope and prefix
    of your code to offer keywords, methods, variables, and more. This not only speeds
    up coding but also reduces errors.
  prefs: []
  type: TYPE_NORMAL
- en: One of Content Assist’s standout features is its seamless integration into the
    Eclipse IDE, requiring no additional installation. This built-in nature means
    developers can immediately benefit from its code completion capabilities without
    extra setup. The convenience of having such a tool readily available makes development
    life much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Content Assist is highly customizable, allowing users to tailor suggestions
    to their specific needs. Developers can configure the types of suggestions they
    want, such as method names, variable names, or entire code snippets. You can filter
    the suggestions for relevance, type, or accessibility. Also, users can adjust
    trigger settings, deciding whether Content Assist should activate automatically
    or manually. This flexibility ensures the tool adapts to various coding styles
    and preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suggestions are based on the letters you’ve just entered; a list of suggestions
    and relevance appears in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can trigger the code completion by hitting *Ctrl* + the space bar, but
    this is customizable, and it also triggers when you type any of the following:
    “ **."** , “ **->"** , or “ **::"** .'
  prefs: []
  type: TYPE_NORMAL
- en: You can make templates for code you write often; if you enter *Ctrl* + the space
    bar, a list of your templates will appear, depending on scope, and you can insert
    the one you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples include a **do while** loop in C or C++, a main method in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, an **include guard** (a.k.a. a **macro guard** , **header guard** , or
    **file guard** ) in C++/C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These stop you from accidentally including a library multiple times [Wiki_Include].
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, you would use a **for loop** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Or, you would use a **try-catch block** .
  prefs: []
  type: TYPE_NORMAL
- en: 'For Python, examples include a **function definition** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'They also include a **class definition** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[ Eclipse_Help, Gemini]'
  prefs: []
  type: TYPE_NORMAL
- en: Another significant advantage is its wide language support. Being in the Eclipse
    environment, Content Assist supports numerous programming languages, including
    Java, C++, Python, and PHP. This makes Content Assist a great tool for developers
    working in multi-language environments. Whether developing a web application in
    JavaScript, a desktop application in Java, or a script in Python, Content Assist
    provides relevant suggestions to speed up the coding process.
  prefs: []
  type: TYPE_NORMAL
- en: There are some drawbacks, however. Performance can be an issue, especially with
    larger projects, where code completion suggestions might be slower compared to
    dedicated tools. This delay can disrupt the coding flow and reduce productivity.
    Also, while Content Assist provides useful suggestions, they may not always be
    as contextually relevant or advanced as those offered by specialized tools or
    those powered by ML models.
  prefs: []
  type: TYPE_NORMAL
- en: Despite these limitations, Eclipse’s Content Assist remains a valuable tool
    for many developers. Its integration with the Eclipse IDE, combined with customization
    options and wide language support, makes it a practical choice for various coding
    tasks. For developers prioritizing an IDE with robust multi-language support,
    Content Assist offers a balanced mix of convenience and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using Content Assist:'
  prefs: []
  type: TYPE_NORMAL
- en: No additional installation required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers various settings to tailor suggestions to your needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports a vast array of programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is integrated directly into the Eclipse IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be configured to activate automatically or manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using Content Assist:'
  prefs: []
  type: TYPE_NORMAL
- en: It can sometimes be slower than dedicated code completion tools, especially
    with larger projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may not always provide the most contextually relevant suggestions compared
    to specialized tools or those powered by ML models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, Eclipse’s Content Assist is a valuable tool for developers looking
    for an integrated, customizable, and versatile code completion feature. While
    it may not always match the performance or advanced capabilities of dedicated
    tools, its built-in nature and wide language support make it a solid choice for
    many coding environments. Whether you are a seasoned developer or just starting,
    Content Assist can help streamline your coding process and improve your overall
    productivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more detailed information about Content Assist, you can refer to the Eclipse
    Help documentation: [https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm](https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm’s code completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PyCharm** , developed by JetBrains, is a widely acclaimed IDE specifically
    designed for Python development. One of its standout features is its intelligent
    code completion, which significantly improves your coding experience by giving
    you context-aware suggestions that go beyond basic code completions. This feature
    can carry out static analysis and use ML to provide highly relevant recommendations,
    including method calls, variable names, and code snippets.'
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm’s code completion tool is deeply integrated with Python, making it an
    excellent choice for Python developers. The IDE indexes your entire project upon
    startup, allowing it to provide accurate and contextually relevant suggestions
    as you type. This deep integration ensures that the code completion feature understands
    the nuances of Python syntax and semantics, offering suggestions that have correct
    syntax and are appropriate for the context.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key advantages of PyCharm’s code completion tool is its context-aware
    nature. The tool analyzes the current context as you code to provide the most
    relevant suggestions. For example, if you’re inside a class method, it will prioritize
    method names and variables that are accessible within that scope. This context-awareness
    extends to understanding the types of variables and suggesting methods and properties
    that are applicable to those types. This intelligent behavior helps reduce the
    amount of boilerplate code you need to write and minimizes the chances of errors.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to basic code completion, PyCharm offers smart type-matching completion.
    This feature filters the suggestion list to show only the types that are applicable
    to the current context. For example, if you’re assigning a value to a variable,
    it will suggest only those values that match the variable’s type. This smart filtering
    helps in maintaining type safety and ensures that your code adheres to the expected
    type constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some examples of using code completion.
  prefs: []
  type: TYPE_NORMAL
- en: Start by typing a name in PyCharm, then hit *Ctrl* + the space bar. Alternatively,
    go to the menu and select **Code** | **Code Completion** , then you can choose
    the **Basic** version. For **Basic Completion** , you can do Methods, Method parameters,
    Dictionaries, Django templates, and File path completions [Python].
  prefs: []
  type: TYPE_NORMAL
- en: Pressing *Ctrl* + the space bar a second time or *Ctrl* + *Alt* + the space
    bar gives you the names of classes, functions, modules, and variables that start
    with the same letters you’ve written.
  prefs: []
  type: TYPE_NORMAL
- en: Other kinds of code completion are smart, hierarchical, chained, docstring,
    custom, live templates, postfix, and type hints [Jetbrains_Completion].
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart type-matching completion gives you a list of relevant types from the
    current context (around the cursor). For example, exception types. If you hit
    *Ctrl* + *Shift* + the space bar, it’ll give you a list of the relevant types
    or you could use the menu: **Code** | **Code Completion** | **Type-Matching**
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PyCharm can also do a great deal of refactoring. Its refactoring tools work
    alongside its code completion feature. These tools allow you to rename variables,
    extract methods, and perform other refactoring operations easily. The refactoring
    tools are context-aware and ensure that changes are propagated throughout your
    code base, maintaining consistency and reducing the risk of introducing errors.
    This deep integration of refactoring tools with code completion makes PyCharm
    a very useful IDE for maintaining and improving code quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are PyCharm components: project view, structure tool window, editor,
    and UML class diagram. To get started with refactoring, there are two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Hover over some code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the code, and from the menu, select **Refactor** | **Refactor This**
    or press *Ctrl* + *Alt* + *Shift* + *T* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select the refactoring option you’d like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll get a dialog box where you can enter the refactoring options, then you
    can click **OK** or **Refactor** [Jetbrains_refactoring].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are many excellent things you can do with code completion, however, there
    are some drawbacks. PyCharm is a commercial tool, and while it offers a free Community
    edition, many of its advanced features, including some aspects of code completion,
    are available only in the Professional edition, which requires a license. This
    can be a limitation for developers or organizations with budget constraints. You
    can see the difference between the versions, along with a link to pricing, here:
    [https://www.jetbrains.com/pycharm/editions/](https://www.jetbrains.com/pycharm/editions/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration is that PyCharm can be resource-intensive, especially
    when working with large projects. The IDE’s comprehensive indexing and analysis
    capabilities need quite a lot of computational resources, which can lead to slower
    performance on less powerful machines. This resource intensity can sometimes result
    in delays in code completion suggestions, which can disrupt the coding flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite these drawbacks, PyCharm’s code completion remains a highly valuable
    tool for Python developers. Its intelligent, context-aware suggestions, deep integration
    with Python, and powerful refactoring tools make it an excellent choice for both
    novice and experienced developers. The ability to customize the behavior of code
    completion means you can define how it helps to check and complete your code:
    you can tailor the tool to your specific preferences.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using PyCharm’s code completion tool:'
  prefs: []
  type: TYPE_NORMAL
- en: It offers highly relevant code completions based on your code’s context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a seamless Python development experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes excellent refactoring features to improve code quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using PyCharm’s code completion tool:'
  prefs: []
  type: TYPE_NORMAL
- en: It requires a paid license for full use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be resource-intensive, especially for large projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, PyCharm’s code completion is a robust and intelligent feature that
    significantly enhances the Python development experience. Its context-aware suggestions,
    deep integration with Python, and powerful refactoring tools make it a very good
    choice for Python developers. While it requires a license for full use and can
    be resource-intensive, the benefits it offers in terms of productivity and code
    quality make it a worthwhile investment for many developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out more about PyCharm’s code completion tool here: [https://www.jetbrains.com/help/pycharm/auto-completing-code.html](https://www.jetbrains.com/help/pycharm/auto-completing-code.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: NetBeans’ code completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NetBeans offers a full code completion feature. This feature is designed to
    enhance the coding experience by providing relevant suggestions for keywords,
    methods, variables, and more, across various programming languages. NetBeans’
    code completion tool is a valuable tool for you to increase your productivity
    and reduce your coding errors.
  prefs: []
  type: TYPE_NORMAL
- en: NetBeans’ code completion tool is pretty user-friendly. The design makes it
    easy for developers to use, regardless of their level of experience. The code
    completion feature is integrated into the editor, allowing suggestions to appear
    as you type. This integration helps streamline the coding process, making it faster
    and more efficient. The interface is designed to be straightforward, so even new
    users can quickly become familiar with the tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'NetBeans’ Editor Code Completion API has two classes, **CompletionItem** and
    **Completion** **Provider** . Code completion is also activated with *Ctrl* +
    the space bar or through the menus: in Windows, this is the pathway: **Tools**
    | **Options** | **Editor** | **Code Completion** . In macOS, this is the pathway:
    **NetBeans** | **Preferences…** | **Editor** | **Code Completion** . Similar to
    other tools, it will take what you have written and make a list of suggestions
    that shortens as you type, and the most relevant suggestions will be at the top
    of the list. You can specify the code completion trigger, but the default is.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another version of code completion called **hippie completion** , which
    searches the current scope of your code, searching the current document and then
    other documents if the desired result is not found. It is activated with *Ctrl*
    + *K* in Windows or *cmd* + *K* in macOS.
  prefs: []
  type: TYPE_NORMAL
- en: If you are declaring an object or a variable of a type, then pressing *Ctrl*
    + the space bar will suggest objects of that type, for example, if you’re declaring
    an **int** , then the first time you hit *Ctrl* + the space bar, it’ll give you
    ints. If you activate code completion again with the same keys, it’ll suggest
    all items, not just ints.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the *Tab* button, the tool will fill in the most commonly used prefixes
    and suggestions, for example, **print** ; if you type **System.out.p** , the following
    will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Use the *Tab* key to use the selected option.
  prefs: []
  type: TYPE_NORMAL
- en: 'NetBeans’ code completion tool will also complete subwords. This is based on
    which letters you’ve typed in, but it’s everything relating to those letters,
    not just things starting with those letters. So, it still works if you’ve forgotten
    the initial letters for the item! An example of this is if you type in **Binding.prop**
    , it’ll give you the following suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you need a chain of commands, press *Ctrl* + the space bar twice, and all
    available chains will be displayed. It looks for variables, fields, and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you type in the string **bindName =** , the completion tool
    can display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There are even more ways that NetBeans’ code completion tool helps you code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go here for a tutorial on how to implement the Editor Code Completion API in
    the context of HTML files: [https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)
    [ Netbeans_Completion, Netbeans_SmartCode].'
  prefs: []
  type: TYPE_NORMAL
- en: However, there are some drawbacks to NetBeans’ code completion tool. Performance
    can sometimes be an issue with NetBeans, especially when working with larger projects.
    The code completion feature might be slower compared to more specialized tools
    designed specifically for code completion. This can be particularly noticeable
    when dealing with large code bases or projects and all their dependencies. The
    delay in suggestions can disrupt the coding flow and reduce overall productivity.
    Also, NetBeans does have a comprehensive set of features, but it may not provide
    as many advanced capabilities as some commercial IDEs. For example, commercial
    tools often have ML models to offer more sophisticated and context-aware code
    completions.
  prefs: []
  type: TYPE_NORMAL
- en: These advanced tools can provide more accurate suggestions, especially in complex
    coding scenarios. NetBeans, while robust, might not have some of these cutting-edge
    features, which can be a limitation for developers looking for the most advanced
    tools around.
  prefs: []
  type: TYPE_NORMAL
- en: Despite these limitations, NetBeans’ code completion remains a highly valuable
    tool for many developers. Its user-friendly interface, cross-platform compatibility,
    and open source nature make it an attractive option for a wide range of users.
    The ability to customize the behavior of code completion makes it even more useful
    for your coding, so you can tailor the tool, just like PyCharm’s tool [NetBeans_Completion].
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using NetBeans’ code completion feature:'
  prefs: []
  type: TYPE_NORMAL
- en: It has an intuitive interface for easy use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It works on Windows, OSX, and Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is free and open source, making it accessible to all developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using NetBeans’ code completion feature:'
  prefs: []
  type: TYPE_NORMAL
- en: It can sometimes be slower than more specialized code completion tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may not offer as many advanced features as some commercial IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, NetBeans’ code completion feature is a robust, versatile tool that
    helps the development experience a lot. Its intuitive interface, cross-platform
    support, and open source accessibility make it an excellent choice for developers.
    While it may not always match the performance or advanced capabilities of specialized
    commercial tools, its comprehensive feature set and ease of use make it a solid
    choice for a lot of coding environments. So, if you’re an experienced developer
    or a newbie, NetBeans’ code completion can help streamline your coding process
    and improve your productivity. Let the tools do the heavy lifting. They say that
    a lazy coder is the best coder. Make and get tools that help you. Don’t do everything
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn more about NetBeans’ code completion tool right here: [https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: VS Code’s IntelliSense
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: VS Code is offered by Microsoft. One of its best features is IntelliSense. IntelliSense
    analyzes the context of your code to provide relevant suggestions, including method
    calls, variables, and keywords, making coding faster and reducing the likelihood
    of errors.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary advantages of IntelliSense is its lightweight nature. Despite
    its powerful capabilities, VS Code remains fast and efficient, even when working
    with large projects. This performance efficiency is crucial for developers who
    need a responsive and reliable coding environment. The lightweight design ensures
    that IntelliSense can provide real-time suggestions without causing significant
    delays or performance issues, even in extensive code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Like the tools from PyCharm and NetBeans, IntelliSense is also highly customizable,
    offering a wide range of options to tailor the tool to your specific needs. Developers
    can configure various aspects of IntelliSense, such as the types of suggestions
    it provides and the triggers for displaying these suggestions. This customization
    allows you to create a coding environment that aligns with your workflow and preferences.
  prefs: []
  type: TYPE_NORMAL
- en: VS Code also allows user-defined snippets, enabling you to create and use custom
    code templates that can be quickly inserted into your code. This is now available
    in many IDEs but it’s a useful tool to have and make use of.
  prefs: []
  type: TYPE_NORMAL
- en: The Visual Studio Marketplace offers a vast array of plugins that can extend
    the functionality of IntelliSense and the editor as a whole. These plugins cover
    a wide range of programming languages, frameworks, and tools, allowing developers
    to enhance their coding environment with additional features and capabilities.
    Whether you need support for a specific language, integration with version control
    systems, or tools for debugging and testing, the marketplace has a plugin to meet
    your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the negatives.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to think about is that while IntelliSense offers good code completion,
    it may not be as specialized for certain programming languages or frameworks as
    some dedicated IDEs. For example, an IDE specifically designed for Java development
    might offer more advanced and context-aware suggestions for Java code compared
    to VS Code. However, the large list of plugins helps mitigate this limitation
    by allowing you to add language-specific extensions that enhance IntelliSense’s
    capabilities for your preferred languages and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using VS Code’s IntelliSense:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightweight** : It is fast and efficient, even for large projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Highly customizable** : It offers a wide range of customization options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET support** : IntelliSense has strong support for .NET languages, such
    as C#, F#, and VB.NET, and it excels in these languages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using VS Code’s IntelliSense:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variable performance** : IntelliSense’s accuracy and completeness depend
    on language and project setup. Less common languages and more complex projects
    can see IntelliSense underperform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential performance overhead** : In complex projects, IntelliSense might
    consume more system resources than some alternative tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, VS Code’s IntelliSense is a really useful tool for developers. Its
    lightweight design, high customizability, and all those plugins make it a valuable
    choice for a lot of different coding tasks. You can tailor IntelliSense to how
    you like to work, so it can assist you in a way that fits in with how you enjoy
    working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s more information about VS Code’s IntelliSense: https://code.visualstudio.com/docs/editor/intellisense
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s get into the SCA and the code review tools.
  prefs: []
  type: TYPE_NORMAL
- en: SCA tools help you to find issues before running code, analyze large code bases,
    and automate routine checks.
  prefs: []
  type: TYPE_NORMAL
- en: Code review tools help experienced coders suggest improvements to code, help
    teams collaborate more, and also think about the wider environment of the code.
  prefs: []
  type: TYPE_NORMAL
- en: SCA and code review tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCA and code review tools have become indispensable in modern software development,
    playing a critical role in ensuring code quality and reliability before the code
    is executed. These tools meticulously analyze source code to identify potential
    bugs, security vulnerabilities, style inconsistencies, and other issues that could
    compromise the software. By catching these problems early in the development process,
    SCA tools help maintain high standards of software quality, reduce the risk of
    defects in production, and ultimately save time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary benefits of SCA tools is their ability to provide immediate
    feedback to developers. As code is written, these tools scan the source code and
    highlight potential issues, allowing developers to address them on the spot. This
    real-time feedback loop is invaluable for maintaining code quality and ensuring
    that best practices are followed consistently. Additionally, SCA tools often integrate
    seamlessly with popular IDEs and CI/CD pipelines, making them an integral part
    of the development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: There are several well-known SCA tools available, each with its own set of features
    and capabilities. For example, SonarQube is a widely used tool that supports multiple
    programming languages and provides comprehensive reports on code quality, security
    vulnerabilities, and technical debt. It offers detailed insights into code issues
    and suggests possible fixes, helping developers improve their code base over time.
    Another popular tool is ESLint, which is specifically designed for JavaScript
    and TypeScript. ESLint allows developers to enforce coding standards and catch
    common errors, making it an essential tool for frontend development.
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SonarQube** is a widely used static analysis tool that supports multiple
    programming languages, including Java, C#, and JavaScript. It provides a platform
    for continuous inspection of code quality, enabling teams to detect bugs, vulnerabilities,
    and code smells. This tool is for maintaining high standards of software quality
    and making sure the code is reliable and secure before it gets to production.'
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube can detect bugs and vulnerabilities in code repositories. By scanning
    the source code, SonarQube finds potential issues that could lead to runtime errors
    or security breaches. This proactive approach allows developers to address problems
    early in the development process, reducing the risk of costly fixes later on.
    The tool provides detailed insights into what the bugs and vulnerabilities are,
    helping developers understand the root causes and think of the best solutions.
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube also has a lot of code metrics that are great for maintaining high-quality
    code. These metrics include code coverage, complexity, and duplication rates.
    Code coverage measures the extent to which the code base is tested by automated
    tests, providing an indication of the robustness of the testing process. Complexity
    metrics help identify overly complicated code that may be difficult to maintain
    or prone to errors. Duplication rates highlight areas of the code base where similar
    code is repeated, suggesting opportunities for refactoring to improve maintainability
    and reduce technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube’s integration with CI/CD pipelines is another significant advantage.
    By integrating SonarQube into the CI/CD process, teams can ensure that code quality
    checks are an integral part of the development workflow. This integration allows
    for automatic code analysis with every commit, providing immediate feedback to
    developers and preventing the introduction of new issues into the code base. The
    integration with popular CI/CD tools, such as Jenkins, Azure DevOps, and GitLab,
    makes it easy to incorporate SonarQube into existing development processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using SonarQube is straightforward. To analyze a project, developers can use
    the SonarQube scanner, a command-line tool that sends the code to the SonarQube
    server for analysis. For example, to analyze a Java project, you’d do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, download it at the following link: [https://www.sonarsource.com/products/sonarqube/](https://www.sonarsource.com/products/sonarqube/)
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install SonarScanner with [https://docs.sonarsource.com/sonarqube/9.7/analyzing-source-code/scanners/sonarscanner/](https://docs.sonarsource.com/sonarqube/9.7/analyzing-source-code/scanners/sonarscanner/)
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure SonarScanner by creating a **sonar-project.properties** file in the
    root directory of the Java project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Specify the project key, name, and source directories:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you would run the following command to analyze the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command specifies the project key and the source directory to be analyzed.
    The results of the analysis are then available on the SonarQube dashboard, where
    developers can review the findings and take appropriate action.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its many advantages, SonarQube is not without its challenges. One potential
    negative is the possibility of false positives, where the tool flags an issue
    that is not actually a problem. This can lead to unnecessary work for developers
    and may cause frustration. Additionally, while SonarQube does a pretty comprehensive
    analysis, it may not catch all types of issues, particularly those related to
    the runtime behavior of the code. Therefore, it is important to use static analysis
    with other testing methods, such as unit testing and integration testing, to ensure
    comprehensive coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using SonarQube:'
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube supports a wide range of programming languages, making it able to
    help in diverse projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides detailed reports on code quality, allowing teams to prioritize issues
    effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A strong community and a variety of plugins enhance SonarQube’s functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a free version and paid versions for more functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using SonarQube:'
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube can sometimes produce false positives, which developers should review
    carefully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running SonarQube can be resource-intensive, particularly for large code bases,
    which may require dedicated infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, SonarQube is a useful tool for SCA and continuous inspection
    of code quality. Its ability to detect bugs, vulnerabilities, and code smells,
    combined with its comprehensive code metrics and seamless integration with CI/CD
    pipelines, makes it an invaluable asset for development teams. By incorporating
    SonarQube into the development process, teams can maintain high standards of software
    quality, reduce the risk of defects, and deliver reliable and secure software
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information can be found at SonarQube’s site: [https://www.sonarsource.com/products/sonarqube/](https://www.sonarsource.com/products/sonarqube/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: ESLint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ESLint** is a static analysis tool specifically for JavaScript and JSX. (JSX
    is an XML-like extension for Javascript.) ESLint plays an important role in modern
    web development by helping developers keep to coding standards and identify problematic
    patterns in their code. This tool is helpful for maintaining code quality and
    consistency across projects, making it a favorite among developers working with
    JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Like the code completion tools, ESLint has customizable rules. ESLint allows
    users to define their own rules and share configurations across teams, promoting
    consistency in coding practices. This flexibility ensures that teams can stick
    to their specific coding standards, no matter what the project’s requirements
    are. For instance, you can create rules that enforce the use of single quotes
    for strings or require semicolons at the end of statements. You can also specify
    indentation style, variable naming conventions, function length, and even code
    complexity. This level of customization helps maintain a uniform code style, which
    is particularly beneficial in large teams or open source projects where multiple
    contributors are involved.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature ESLint has is its easy integration with CI/CD pipelines. By
    integrating ESLint into the CI/CD process, developers can ensure that code quality
    checks are performed automatically before deployment. This integration helps catch
    issues early in the development cycle, reducing the risk of bugs and inconsistencies
    making it into production. Popular CI/CD tools, such as Jenkins, Travis CI, and
    GitHub Actions, support ESLint, making it easy to incorporate into existing workflows.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint also offers robust fixing capabilities. Many of the issues detected by
    ESLint can be automatically fixed, saving you time and effort in your development.
    For example, if ESLint detects a missing semicolon or an incorrect quote style,
    it can automatically correct these issues based on the defined rules. This auto-fix
    feature is particularly useful for addressing minor code style violations, allowing
    developers to focus on more complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using ESLint is straightforward. Developers can configure ESLint by creating
    a configuration file, typically named **.eslintrc.js** , which defines the environment,
    extends configurations, and specifies the rules. Here is an example of an ESLint
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**env** : This specifies the environment in which the code will be run. In
    this case, it’s configured for both browser and ES6 environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**extends** : This setting extends the recommended ESLint ruleset, providing
    a good starting point for enforcing common coding standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rules** : This section allows you to customize specific rules. Here, you’ve
    enforced the use of semicolons and single quotes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite its many advantages, ESLint does have some issues. One possible challenge
    is the initial setup. Configuring ESLint to fit a team’s specific needs requires
    lots of time, especially for new users who may find the extensive configuration
    options overwhelming. However, once set up, ESLint provides significant long-term
    benefits in terms of code quality and consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to think about is the learning curve associated with ESLint. While
    the tool is highly configurable, new users may need time to become familiar with
    its features and how to customize it effectively. Fortunately, ESLint has an active
    community that contributes to a wealth of plugins and shared configurations, providing
    ample resources and support for new users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using ESLint:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Highly configurable** : ESLint’s flexibility allows teams to enforce their
    coding standards effectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active community** : A large community contributes to a wealth of plugins
    and shared configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using ESLint:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup time** : ESLint requires an initial investment of time to configure
    rules that fit a team’s needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**False positives** : Similar to some other tools in this chapter, ESLint may
    sometimes flag issues that are not actual errors or violations of coding standards;
    these are false positives. This can be frustrating and can mean you have to make
    extra code changes for no benefit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ESLint can be restrictive, enforcing strict rules that may not always be appropriate
    for certain code styles or use cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, ESLint is a very helpful tool for JavaScript and JSX development.
    Its customizable rules, integration with CI/CD pipelines, and automatic fixing
    capabilities make it a powerful ally in sticking to high code quality and consistency.
    While it may require an initial investment of time to configure and a learning
    curve for new users, the benefits it offers in terms of productivity and code
    reliability make it well worth the effort. Whether you are working on a small
    project or a large-scale application, ESLint can help ensure that your code adheres
    to best practices and remains maintainable over time. As you may have seen in
    previous chapters, code standards can be rather stringent and detailed, so having
    tools to keep to these can be a great help.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information can be found at ESLint’s official site: [https://eslint.org/](https://eslint.org/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: PMD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PMD** is an open source SCA tool that is helpful for developers to identify
    potential issues in their code. It supports a few programming languages, including
    Java, JavaScript, and XML (with some support for C, C++, C#, Python, and PHP).
    PMD is mainly for Java. It focuses on finding common programming flaws, such as
    unused variables, empty catch blocks, and unnecessary object creation. This makes
    PMD a great tool for maintaining high standards of code quality and ensuring that
    software is reliable and efficient, especially in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the features of PMD is its rule-based analysis. PMD uses a set of predefined
    rules to analyze code and identify potential issues. These rules cover a wide
    range of common programming mistakes and best practices, helping developers catch
    errors early in the development process. The predefined rules are comprehensive
    and cover various aspects of coding, from syntax errors to more complex logical
    issues. This thorough analysis helps in maintaining a clean and efficient code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to its predefined rules, PMD allows you, as a developer, to create
    custom rules tailored to your desired coding standards and practices. This customizability
    is one of PMD’s best features, as it enables teams to enforce their unique coding
    guidelines and ensure consistency across projects. Custom rules can be written
    in Java or using XPath queries, providing flexibility in how they are defined
    and implemented. This ability to tailor the tool to specific needs makes PMD highly
    adaptable to different development environments and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'PMD also integrates with popular build tools, such as Maven and Gradle (the
    PMD Maven plugin is available at [https://github.com/apache/maven-pmd-plugin](https://github.com/apache/maven-pmd-plugin)
    and the PMD Gradle plugin is available at [https://docs.gradle.org/current/userguide/pmd_plugin.html](https://docs.gradle.org/current/userguide/pmd_plugin.html)
    ), making it easy to incorporate into existing workflows. This integration ensures
    that code quality checks are an integral part of the build process, providing
    continuous feedback to developers and preventing the introduction of new issues
    into the code base. By running PMD as part of the build process, teams can catch
    and address issues early, reducing the risk of defects in production. For example,
    to run PMD on a Java project using Maven, you would use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run this in bash. This command triggers PMD to analyze the project and generate
    a report on any issues found, allowing developers to review and address them promptly.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its many advantages, PMD does have some limitations. One potential thing
    is its limited language support. While PMD supports several languages, its primary
    focus is on Java, which may not suit all projects. This can be a limitation for
    teams working with a diverse set of programming languages. However, PMD does support
    other languages, such as JavaScript, Salesforce Apex, and more, which can still
    be beneficial for many projects.
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration is the complexity of configuring PMD with custom rules.
    Setting up PMD to enforce specific coding standards can be complex, especially
    for new users who may not be familiar with the tool’s configuration options. This
    is similar to some other tools in this chapter. This initial setup requires an
    investment of time and effort, but the long-term benefits of having a tailored
    static analysis tool can be significant. You’ll most likely find that the one-time
    time investment is really worth it for all the repeated help every day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using PMD:'
  prefs: []
  type: TYPE_NORMAL
- en: PMD is free to use, making it accessible for developers and teams of all sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to create custom rules allows teams to enforce their specific coding
    standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using PMD:'
  prefs: []
  type: TYPE_NORMAL
- en: While PMD supports several languages, its primary focus is on Java, which may
    not suit all projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up PMD with custom rules can be complex for new users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, PMD is a SCA tool for Java and other languages that helps developers
    maintain high standards of code quality. Its rule-based analysis, customizability,
    and integration with build tools make it a good tool for many development teams.
    While it may have some limitations in terms of language support and configuration
    complexity, the benefits it offers in terms of identifying potential issues and
    enforcing coding standards make it a valuable asset in the software development
    process. By incorporating PMD into their workflows, your teams can ensure that
    your code is reliable, efficient, and adheres to best practices, ultimately leading
    to higher-quality software.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information can be found at PMD’s site: [https://pmd.github.io/](https://pmd.github.io/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Checkstyle for Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve already gone through a few tools, I shall make this brief.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkstyle** is a valuable tool for ensuring Java code adheres to predefined
    coding standards. By automating code checks, it maintains consistency and quality
    across projects, making code easier to read, understand, and maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of its key features:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks code against customizable rules for naming conventions, formatting,
    design patterns, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It seamlessly integrates with Eclipse and IntelliJ IDEA for real-time feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to define your own rules to match specific coding practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure Checkstyle in your build tool (e.g., Maven, Gradle) to specify your
    desired ruleset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checkstyle analyzes your Java code against these rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It generates reports highlighting violations and provides suggestions for improvement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is an example (Maven).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is XML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some of the pros of using Checkstyle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus on Java** : Checkstyle is specifically designed for Java, making it
    highly effective for Java projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time feedback** : Integration with IDEs allows developers to receive
    immediate feedback on coding standards'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some of the cons of using Checkstyle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java only** : Checkstyle is limited to Java, which may not be suitable for
    multi-language projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration overhead** : Setting up and maintaining Checkstyle configurations
    can be time-consuming'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using Checkstyle, you can ensure your Java code meets high-quality standards,
    promoting readability, maintainability, and team collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: '**Source** : [https://github.com/jvalentino/jenkins-agent-maven](https://github.com/jvalentino/jenkins-agent-maven)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information here: [https://checkstyle.sourceforge.io/](https://checkstyle.sourceforge.io/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Fortify Static Code Analyzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Fortify** , developed by OpenText, is a commercial static analysis tool that
    excels at identifying security vulnerabilities in source code. It supports a wide
    range of programming languages, making it a versatile choice for diverse development
    teams.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key features of Fortify:'
  prefs: []
  type: TYPE_NORMAL
- en: Fortify’s deep analysis capabilities uncover a broad spectrum of security risks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can generate actionable reports with remediation guidance to address identified
    vulnerabilities effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can integrate Fortify into your CI/CD pipeline for continuous security checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Run Fortify on your code to identify vulnerabilities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review detailed reports for insights and remediation guidance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrate Fortify into your development workflow for continuous security checks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are some pros of using Fortify:'
  prefs: []
  type: TYPE_NORMAL
- en: It is ideal for large-scale projects and organizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It detects a wide range of vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides clear guidance for remediation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of using Fortify:'
  prefs: []
  type: TYPE_NORMAL
- en: It requires a commercial license
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial setup and configuration can be involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, Fortify is a valuable tool for organizations looking to strengthen
    their software security posture. While it requires an investment, the benefits
    in terms of vulnerability detection and risk mitigation can be substantial. By
    incorporating Fortify into your development process, you can ensure that your
    code meets the highest security standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortify’s official site gives more information: [https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview](https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.microfocus.com/documentation/fortify-static-code-analyzer-and-tools/2310/](https://www.microfocus.com/documentation/fortify-static-code-analyzer-and-tools/2310/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.opentext.com/products/fortify-static-code-analyzer](https://www.opentext.com/products/fortify-static-code-analyzer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://bing.com/search?q=Fortify+Static+Code+Analyzer+summary](https://bing.com/search?q=Fortify+Static+Code+Analyzer+summary)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.microfocus.com/media/data-sheet/fortify_static_code_analyzer_static_application_security_testing_ds.pdf](https://www.microfocus.com/media/data-sheet/fortify_static_code_analyzer_static_application_security_testing_ds.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://gemini.google.com/](https://gemini.google.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://copilot.microsoft.com/](https://copilot.microsoft.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeSonar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CodeSonar** , a static analysis tool from GrammaTech, also called a **static
    application security testing** ( **SAST** ) tool, is an excellent tool for ensuring
    code quality and safety, especially in critical industries, such as automotive,
    aerospace, and medical devices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of its key features:'
  prefs: []
  type: TYPE_NORMAL
- en: It uncovers a wide range of issues, from memory leaks to concurrency problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It works smoothly with popular IDEs and build systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps you understand complex code structures with visual aids
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: CodeSonar scans your code for potential issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detailed reports highlight vulnerabilities and provide insights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Easily integrate CodeSonar into your development workflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the pros of using CodeSonar:'
  prefs: []
  type: TYPE_NORMAL
- en: It catches bugs before they become costly problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It ensures high-quality, safe code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It understands your code’s structure and dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the cons of using CodeSonar:'
  prefs: []
  type: TYPE_NORMAL
- en: It may require a license
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can take time to master its features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial setup might require effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, CodeSonar is a valuable tool for maintaining code quality and
    safety. While it may have a learning curve and require an investment, the benefits
    it offers in terms of preventing costly errors and ensuring reliable software
    make it a worthwhile consideration for many development teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn more about it at CodeSonar’s site: https://codesecure.com/our-products/codesonar/
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Coverity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Coverity** , by Synopsys, is a static analysis tool that empowers development
    teams in enterprise environments to identify and fix defects early in the software
    development life cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are its key features:'
  prefs: []
  type: TYPE_NORMAL
- en: Coverity scans code for a wide range of issues, providing detailed reports and
    remediation guidance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It integrates seamlessly with popular CI/CD tools for automated code quality
    checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can monitor code health metrics and track progress over time with customizable
    dashboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the pros of using Coverity:'
  prefs: []
  type: TYPE_NORMAL
- en: It proactively detects defects and vulnerabilities, strengthening code health
    and security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It catches issues early, reducing costly bug fixes later in the development
    process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can gain insights into code quality through customizable dashboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the cons of using Coverity:'
  prefs: []
  type: TYPE_NORMAL
- en: It requires a commercial license, which may not be feasible for small teams
    or individual developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial setup can be complex and require dedicated resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensive features and configuration options have a learning curve for new users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, for large-scale projects, Coverity’s comprehensive defect detection,
    CI/CD integration, and customizable dashboards make it a valuable tool for maintaining
    high code quality and security. While there’s a cost and learning curve, the long-term
    benefits outweigh them for many development teams.
  prefs: []
  type: TYPE_NORMAL
- en: Popular CI/CD tools, such as Jenkins ( [https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/](https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/)
    ), GitLab, and Azure DevOps, support Coverity, making it easy to integrate into
    existing development processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the Coverity site for more information: [https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html](https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the sources: [https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/](https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/)
    , [https://www.trustradius.com/products/synopsys-coverity-static-application-security-testing-sast/reviews?qs=pros-and-cons](https://www.trustradius.com/products/synopsys-coverity-static-application-security-testing-sast/reviews?qs=pros-and-cons)
    , [https://www.gartner.com/reviews/market/application-security-testing/vendor/synopsys/product/coverity-static-application-security-testing](https://www.gartner.com/reviews/market/application-security-testing/vendor/synopsys/product/coverity-static-application-security-testing)
    , [https://stackshare.io/coverity-scan](https://stackshare.io/coverity-scan) ,
    [https://www.softwareadvice.com/app-development/coverity-static-analysis-profile/](https://www.softwareadvice.com/app-development/coverity-static-analysis-profile/)
    , [https://en.wikipedia.org/wiki/Coverity](https://en.wikipedia.org/wiki/Coverity)
    , [https://gemini.google.com/](https://gemini.google.com/) , [https://copilot.microsoft.com/](https://copilot.microsoft.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: FindBugs/SpotBugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SpotBugs** , which succeeded FindBugs, is a specialized static analysis tool
    designed for Java that excels at detecting potential bugs in Java code. By leveraging
    a comprehensive set of bug patterns, it identifies common coding mistakes, ensuring
    higher code quality and reliability. SpotBugs operates by analyzing Java bytecode,
    which allows it to uncover potential issues based on a predefined set of patterns.
    This method of analysis is particularly effective in pinpointing bugs that might
    not be immediately apparent through manual code reviews.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the best features of SpotBugs is its great integration with popular build
    tools, such as Maven and Gradle. This integration facilitates its inclusion in
    existing development workflows, making it a convenient choice for CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: SpotBugs is known for its user-friendly setup and ease of use, which makes it
    accessible to developers of all skill levels. Whether you are a novice developer
    or an experienced professional, SpotBugs provides a straightforward way to enhance
    your code’s robustness. Its ability to integrate smoothly into various development
    environments and its ease of use make it a valuable tool for maintaining high
    standards of code quality in Java projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, run this in bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the pros of using SpotBugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Free and open source** : SpotBugs is free to use, making it accessible for
    developers and teams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Focus on Java** : Its specialization in Java means it provides highly relevant
    analyses for Java projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the cons of using SpotBugs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Limited language support** : SpotBugs is specifically for Java, which may
    limit its usability for multi-language projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**False positives** : Like many static analysis tools, it can produce false
    positives that require manual review.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, SpotBugs is a static analysis tool for Java developers, offering
    a robust solution for identifying and rectifying potential bugs. Its ease of integration
    with build tools and user-friendly setup make it accessible to developers at all
    levels, ensuring that high standards of code quality are maintained across projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information can be found on the SpotBugs site: [https://spotbugs.github.io/](https://spotbugs.github.io/)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bandit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Bandit** is an SCA, or rather a SAST, tool that helps you identify security
    vulnerabilities in Python code. It scans for common issues, such as hardcoded
    passwords and insecure API usage, ensuring your Python applications remain secure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are its key features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Comprehensive vulnerability detection** : It identifies a wide range of security
    risks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customizable rules** : Tailor Bandit to your specific needs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CI/CD integration** : Automate security checks for continuous monitoring'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a usage example, run this in bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the pros of using Bandit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python-specific** : Bandit is tailored for Python, making it highly effective
    for identifying security issues in Python code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open source** : As an open source tool, Bandit is free to use and accessible
    to all developers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the cons of using Bandit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited to Python** : Bandit is specifically designed for Python, so it may
    not be suitable for projects that use multiple languages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**False positives** : Like many static analysis tools, Bandit can generate
    false positives that require manual review'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, Bandit is a valuable tool for Python developers focused on security.
    Its ability to detect a wide range of security vulnerabilities, coupled with customizable
    rules and seamless CI/CD integration, makes it an essential asset for maintaining
    secure code bases. By incorporating Bandit into their development workflows, developers
    can proactively address security risks and ensure that their applications remain
    secure against potential threats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out Bandit’s site: [https://bandit.readthedocs.io/](https://bandit.readthedocs.io/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: HoundCI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**HoundCI** is a GitHub-integrated tool that enforces code quality standards.
    It provides real-time feedback on pull requests, ensuring clean, consistent code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are its key features:'
  prefs: []
  type: TYPE_NORMAL
- en: It identifies style violations and issues during pull requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It tailors HoundCI to your specific coding standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It works with various programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the pros of using HoundCI:'
  prefs: []
  type: TYPE_NORMAL
- en: HoundCI provides immediate feedback on code style issues, helping teams maintain
    consistent coding practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The seamless integration with GitHub makes it easy to incorporate into existing
    workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the cons of using HoundCI:'
  prefs: []
  type: TYPE_NORMAL
- en: HoundCI focuses primarily on style and best practices, which may not cover deeper
    static analysis needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is specifically designed for GitHub repositories, limiting its usability
    for teams using other version control systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See more at HoundCI’s official site: [https://houndci.com/](https://houndci.com/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the sources: [https://github.com/houndci/hound](https://github.com/houndci/hound)
    , [https://github.com/marketplace/hound](https://github.com/marketplace/hound)
    , [https://www.houndci.com/configuration](https://www.houndci.com/configuration)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at testing and debugging tools. Testing and debugging tools
    are also essential for ensuring the quality and reliability of software. They
    help identify and fix errors early in the development process, preventing potential
    issues from affecting end users and saving time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and debugging tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing and debugging tools are also critical components in the software development
    life cycle, ensuring that code functions correctly and meets quality standards.
    These tools help identify issues early in the development process, ultimately
    saving time and resources by addressing potential problems before they escalate.
    In this section, we will explore various testing and debugging tools and their
    features, advantages, and limitations, with a focus on how they can enhance your
    development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Jest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Jest** is a widely used testing framework developed by Christoph Nakazawa,
    now Meta, but is an open source project with many developers. It’s particularly
    popular among JavaScript developers. It provides a comprehensive testing solution
    for JavaScript applications, focusing on simplicity and ease of use. Jest is especially
    favored for testing React applications, but it can also be used with other frameworks
    and libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: One good feature of Jest is its snapshot testing capability. This allows developers
    to capture snapshots of component output, making it easy to verify that changes
    to the code do not introduce unintended side effects. When a component renders,
    Jest compares the output to a previously saved snapshot. If there are differences,
    Jest alerts the developer, enabling them to review the changes and ensure everything
    is functioning as expected. Jest also comes equipped with robust mocking capabilities,
    which allow developers to isolate components during testing. This is particularly
    useful when testing components that rely on external services or APIs. By mocking
    these dependencies, developers can focus on testing the component’s logic without
    concerning themselves with the behavior of external resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example with JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: While Jest is a powerful tool, it is essential to recognize that it may not
    be suitable for every testing scenario. For instance, in complex applications
    that require more specialized testing strategies, such as end-to-end testing or
    performance testing, developers may need to complement Jest with additional tools
    designed specifically for those purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, Jest stands out as an excellent framework for unit and integration
    testing, helping developers maintain high-quality code throughout their projects.
    If you’d like more details and resources, you can visit Jest’s official site:
    [https://jestjs.io/](https://jestjs.io/) .'
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Postman** is a leading tool for testing APIs, providing developers with a
    user-friendly interface to send requests and analyze responses. It simplifies
    the process of interacting with APIs, making it accessible for both seasoned developers
    and newcomers alike.'
  prefs: []
  type: TYPE_NORMAL
- en: One of Postman’s key features is its ability to create automated tests. Users
    can write test scripts that run automatically after sending requests, verifying
    that the API behaves as expected. This feature is invaluable for ensuring that
    API endpoints return the correct status codes, headers, and response bodies. By
    automating these tests, developers can quickly identify issues and maintain the
    integrity of their APIs as they evolve.
  prefs: []
  type: TYPE_NORMAL
- en: Postman also offers a collection runner, which allows users to group requests
    into collections and execute them in sequence. This is particularly useful for
    testing workflows that involve multiple API calls. For example, if an application
    requires a user to be authenticated before accessing certain endpoints, a developer
    can create a collection that first sends a login request and then proceeds to
    call protected endpoints. This sequential testing capability helps simulate real-world
    scenarios and ensures that the entire flow works as intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Although Postman is feature-rich and widely regarded as an essential tool for
    API testing, it does come with a learning curve for those unfamiliar with API
    testing concepts. New users may need time to familiarize themselves with Postman’s
    interface and capabilities, but the investment is often well worth it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a tool that supports collaboration among development teams, Postman enhances
    communication and streamlines the process of API development and testing. You
    can visit Postman’s official site for more information: [https://www.postman.com/](https://www.postman.com/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Cypress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Cypress** is an end-to-end testing framework designed specifically for modern
    web applications. It provides a powerful and easy-to-use platform for writing
    tests that simulate user interactions, allowing developers to ensure that their
    applications function correctly from the user’s perspective.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the notable features of Cypress is its real-time reloading capability.
    This means that as developers write tests, they can immediately see the results
    in the browser without needing to refresh manually. This instant feedback loop
    accelerates the development process and makes it easier to catch issues early.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress also offers an intuitive time travel feature, which allows developers
    to pause test execution and inspect the application at any point in time. This
    is particularly useful for debugging failures, as developers can see exactly what
    the application looked like when a test failed, making it easier to identify the
    root cause of issues.
  prefs: []
  type: TYPE_NORMAL
- en: Also, Cypress integrates well with popular CI/CD tools, enabling automated testing
    in the development pipeline. This integration helps ensure that new code changes
    do not break existing functionality, maintaining the overall quality of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of testing with Cypress is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Cypress bash: **npm install** **cypress –save-dev** .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open with bash: **npx** **cypress open** .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the test suite you created (in this case, **My App** ).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cypress will automatically run the test and display the results in the Test
    Runner UI.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: While Cypress is a robust testing tool, it is primarily focused on web applications.
    Developers working with mobile applications or other environments may need to
    seek additional testing solutions. Additionally, the learning curve for new users
    can be steep, especially for those unfamiliar with JavaScript and asynchronous
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'For further details on Cypress, you can visit Cypress’s official site: [https://www.cypress.io/](https://www.cypress.io/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Selenium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Selenium** is a well-established open source testing framework that allows
    developers to automate browsers for testing web applications. It supports multiple
    programming languages, including Java, C#, Python, and Ruby, making it a versatile
    choice for testing across different platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the strengths of Selenium is its ability to simulate user interactions
    with a web application. Developers can write scripts that automate tasks, such
    as clicking buttons, filling out forms, and navigating between pages. This capability
    makes Selenium particularly useful for end-to-end testing, where the goal is to
    verify that all components of an application work together as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium also supports a variety of browsers, enabling developers to perform
    cross-browser testing. This is important for ensuring that applications behave
    consistently across different web browsers and OSs. With the rise of mobile devices,
    Selenium has also expanded its capabilities to include mobile browser testing
    through tools such as Appium.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its strengths, Selenium does have a few negatives. Setting up and maintaining
    Selenium tests can be complex, especially for larger applications, similar to
    other tools here. Additionally, tests can sometimes be brittle, meaning they may
    fail due to minor changes in the application’s UI or behavior rather than actual
    bugs. Developers need to invest time in creating robust tests and managing the
    associated maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out Selenium’s website here: [https://www.selenium.dev/](https://www.selenium.dev/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Mocha
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Mocha** is a flexible testing framework for JavaScript that runs on Node.js
    and in the browser. It is designed to do asynchronous testing, making it easier
    to test applications that rely on callbacks or promises.'
  prefs: []
  type: TYPE_NORMAL
- en: One of Mocha’s defining features is its simple syntax, which allows developers
    to write clear and expressive tests. This simplicity is particularly beneficial
    for teams that prioritize readability and maintainability in their test code.
    Mocha supports various assertion libraries, giving developers the freedom to choose
    the one that best fits their needs. Popular choices include Chai, Should.js, and
    Assert.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha also provides a variety of reporting options, allowing developers to view
    test results in different formats. This flexibility makes it easier to integrate
    Mocha into existing development workflows and CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Mocha is a good and efficient testing tool, one can note that it primarily
    focuses on unit testing. As a result, developers may need to complement Mocha
    with other tools for end-to-end or integration testing. Additionally, configuring
    Mocha can require some upfront effort, particularly for teams that are new to
    testing in JavaScript. For further details on Mocha, see here: [https://mochajs.org/](https://mochajs.org/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Charles Proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Charles Proxy** is a web debugging tool that allows developers to view all
    of the HTTP and SSL/HTTPS traffic between their computers and the internet. It
    acts as a proxy server, enabling developers to inspect and analyze requests and
    responses in real time.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary uses of Charles Proxy is for API testing and debugging. By
    capturing network traffic, developers can easily identify issues such as incorrect
    request parameters, unexpected response formats, or authentication problems. This
    visibility is invaluable when working with APIs, as it allows developers to troubleshoot
    problems quickly and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Charles Proxy also supports features such as request modification and response
    simulation. This means that developers can modify requests on the fly, allowing
    them to test various scenarios without making changes to the actual application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Charles Proxy can simulate different network conditions, enabling
    you to see how your application behaves under various circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Get the tool from [https://www.charlesproxy.com/](https://www.charlesproxy.com/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure Charles Proxy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If necessary, configure your system or browser to use Charles Proxy as the HTTP
    proxy. This usually involves setting the proxy settings in your browser or OS.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the web application you want to test.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Intercept requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Charles Proxy, enable the **Breakpoints** feature.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the **Tools** menu and select **Breakpoints** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the **Enable** **breakpoints** option.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform actions in your application that trigger HTTP requests. Charles Proxy
    will intercept these requests and pause them at the breakpoint.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inspect and modify the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Charles Proxy, examine the intercepted request details, including the URL,
    headers, and request body.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can modify the request parameters, headers, or body to simulate different
    scenarios.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Continue the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To continue the request with the modified parameters, click the **Execute**
    button in Charles Proxy.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing authentication** : Intercept the login request, modify the username
    or password, and observe the application’s response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simulating network conditions** : Modify the request headers to simulate
    slow network speeds or different network types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging API calls** : Inspect the request and response to identify issues
    or errors in API interactions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While Charles Proxy is a great debugging tool, it may not be suitable for all
    use cases. Developers working on large-scale applications may find that the volume
    of traffic can become overwhelming, making it challenging to pinpoint specific
    issues. Furthermore, there can be a learning curve for new users, particularly
    when it comes to navigating the interface and configuring settings. Most of these
    tools take a lot of work to get into, but they’re worth it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want more information about Charles Proxy, you can visit Charles Proxy’s
    official site: [https://www.charlesproxy.com/](https://www.charlesproxy.com/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter sets the foundation for understanding the diverse range of non-LLM
    AI tools available to developers. By exploring their functionalities and best
    practices, you can better equip yourself with the knowledge to enhance your coding
    toolkit and workflow. For further reading and exploration of the tools discussed,
    please refer to the official websites linked throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we delved into a diverse array of non-LLM AI tools for coding,
    highlighting their functionalities, capabilities, and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: We began by examining code completion and generation tools, such as Content
    Assist and PyCharm and NetBeans’ code completion tools, which significantly enhance
    coding efficiency by providing real-time suggestions and automating repetitive
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we explored static analysis tools, such as SonarQube and ESLint,
    which play a crucial role in maintaining code quality and identifying potential
    issues early in the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed testing and debugging tools, such as Jest and Postman,
    emphasizing their importance in ensuring that applications function correctly
    and meet user expectations.
  prefs: []
  type: TYPE_NORMAL
- en: The integration of these tools into your coding workflow creates a robust toolkit
    that enhances various aspects of the software development process. While LLMs
    offer valuable assistance, leveraging non-LLM tools can maximize productivity
    and ensure that your code is not only functional but also clean, maintainable,
    and efficient. By utilizing a combination of these tools, developers can effectively
    tackle challenges, streamline their workflows, and improve overall code quality.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter helps developers without this knowledge begin to understand the
    extensive range of non-LLM AI tools available to developers. By exploring their
    functionalities and best practices, you can equip yourself with the knowledge
    necessary to enhance your coding toolkit and workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Getting into and mastering these tools will empower you to elevate your development
    practices, leading to a more productive and effective coding experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'You.com is a good source of information on the software tools in this chapter:
    [https://you.com](https://you.com) [You.com].'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 11*](B21009_11.xhtml#_idTextAnchor279) , we’ll be looking at how
    to leverage LLMs to help other people and ultimately maximize your career: why
    you should mentor others, more ways to share your work, networking, and some fresh
    approaches to using LLMs.'
  prefs: []
  type: TYPE_NORMAL
- en: Bibliography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Aside from the sources mentioned earlier, here are some more:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Copilot* : Microsoft, [https://copilot.microsoft.com/](https://copilot.microsoft.com/)
    , [https://copilot.cloud.microsoft/en-GB/prompts](https://copilot.cloud.microsoft/en-GB/prompts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Eclipse_Help* : “Content Assist”, Eclipse, [https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm](https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Gemini* : [https://gemini.google.com/](https://gemini.google.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jetbrains_Completion* : “Code completion”, JetBrains, [https://www.jetbrains.com/help/pycharm/auto-completing-code.html](https://www.jetbrains.com/help/pycharm/auto-completing-code.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jetbrains_refactoring* : “Refactor code”, JetBrains, [https://www.jetbrains.com/help/pycharm/refactoring-source-code.html](https://www.jetbrains.com/help/pycharm/refactoring-source-code.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NetBeans_Completion* : “NetBeans Code Completion Tutorial”, Apache, [https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Netbeans_SmartCode* : “Code Assistance in the NetBeans IDE Java Editor: A
    Reference Guide: Smart Code Completion”, Apache: [https://netbeans.apache.org/tutorial/main/kb/docs/java/editor-codereference/#_smart_code_completion](https://netbeans.apache.org/tutorial/main/kb/docs/java/editor-codereference/#_smart_code_completion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wiki_Include* : “include guard”, various, [https://en.wikipedia.org/wiki/Include_guard](https://en.wikipedia.org/wiki/Include_guard)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*You.com* : [https://you.com](https://you.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 4: Maximizing Your Potential with LLMs: Beyond the Basics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section explores ways to leverage LLMs for personal and professional growth.
    We will check out various AI tools that can amplify the capabilities of LLMs,
    creating a very robust AI toolkit. We will cover strategies for mentorship, community
    involvement, and also advancing your career in the field of LLM-powered coding.
    Lastly, we will see the various emerging trends and technological advancements
    and the long-term impact of LLMs on software development.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section covers the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21009_11.xhtml#_idTextAnchor279) *,* *Helping Others and Maximizing
    Your Career with LLMs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B21009_12.xhtml#_idTextAnchor308) *,* *The Future of LLMs in
    Software Development*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
