["```py\nfrom io import BytesIO\nfrom urllib.request import urlopen\nfrom zipfile import ZipFile\nurl = 'https://github.com/VeritasYin/STGCN_IJCAI-18/raw/master/data_loader/PeMSD7_Full.zip'\nwith urlopen(url) as zurl:\n    with ZipFile(BytesIO(zurl.read())) as zfile:\n        zfile.extractall('.')\n```", "```py\nimport pandas as pd\nspeeds = pd.read_csv('PeMSD7_V_228.csv', names=range(0,228))\ndistances = pd.read_csv('PeMSD7_W_228.csv.csv', names=range(0,228))\n```", "```py\n    import numpy as np\n    import matplotlib.pyplot as plt\n    ```", "```py\n    plt.figure(figsize=(10,5))\n    plt.plot(speeds)\n    plt.grid(linestyle=':')\n    plt.xlabel('Time (5 min)')\n    plt.ylabel('Traffic speed')\n    ```", "```py\n    mean = speeds.mean(axis=1)\n    std = speeds.std(axis=1)\n    ```", "```py\n    plt.plot(mean, 'k-')\n    ```", "```py\n    plt.fill_between(mean.index, mean-std, mean+std, color='r', alpha=0.1)\n    plt.grid(linestyle=':')\n    plt.xlabel('Time (5 min)')\n    plt.ylabel('Traffic speed')\n    ```", "```py\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 8))\n    fig.tight_layout(pad=3.0)\n    ```", "```py\n    ax1.matshow(distances)\n    ax1.set_xlabel(\"Sensor station\")\n    ax1.set_ylabel(\"Sensor station\")\n    ax1.title.set_text(\"Distance matrix\")\n    ```", "```py\n    ax2.matshow(-np.corrcoef(speeds.T))\n    ax2.set_xlabel(\"Sensor station\")\n    ax2.set_ylabel(\"Sensor station\")\n    ax2.title.set_text(\"Correlation matrix\")\n    ```", "```py\n    def compute_adj(distances, sigma2=0.1, epsilon=0.5):\n        d = distances.to_numpy() / 10000.\n        d2 = d * d\n    ```", "```py\n        n = distances.shape[0]\n        w_mask = np.ones([n, n]) - np.identity(n)\n        return np.exp(-d2 / sigma2) * (np.exp(-d2 / sigma2) >= epsilon) * w_mask\n    ```", "```py\n    adj = compute_adj(distances)\n    adj[0]\n    array([0.       , 0.       , 0.        , 0.       , 0.  ,\n           0.       , 0.       , 0.61266012, 0.       , ...\n    ```", "```py\n    plt.figure(figsize=(8, 8))\n    cax = plt.matshow(adj, False)\n    plt.colorbar(cax)\n    plt.xlabel(\"Sensor station\")\n    plt.ylabel(\"Sensor station\")\n    ```", "```py\n    import networkx as nx\n    def plot_graph(adj):\n        plt.figure(figsize=(10,5))\n        rows, cols = np.where(adj > 0)\n        edges = zip(rows.tolist(), cols.tolist())\n        G = nx.Graph()\n        G.add_edges_from(edges)\n        nx.draw(G, with_labels=True)\n        plt.show()\n    ```", "```py\n    plot_graph(adj)\n    ```", "```py\n    def zscore(x, mean, std):\n        return (x - mean) / std\n    ```", "```py\n    speeds_norm = zscore(speeds, speeds.mean(axis=0), speeds.std(axis=0))\n    ```", "```py\n    speeds_norm.head(1)\n    ```", "```py\n    lags = 24\n    horizon = 48\n    xs = []\n    ys = []\n    ```", "```py\n    for i in range(lags, speeds_norm.shape[0]-horizon):\n        xs.append(speeds_norm.to_numpy()[i-lags:i].T)\n        ys.append(speeds_norm.to_numpy()[i+horizon-1])\n    ```", "```py\n    from torch_geometric_temporal.signal import StaticGraphTemporalSignal\n    edge_index = (np.array(adj) > 0).nonzero()\n    edge_weight = adj[adj > 0]\n    dataset = StaticGraphTemporalSignal(edge_index, adj[adj > 0], xs, ys)\n    ```", "```py\n    dataset[0]\n    Data(x=[228, 12], edge_index=[2, 1664], edge_attr=[1664], y=[228])\n    ```", "```py\n    from torch_geometric_temporal.signal import temporal_signal_split\n    train_dataset, test_dataset = temporal_signal_split(dataset, train_ratio=0.8)\n    ```", "```py\n    import torch\n    from torch_geometric_temporal.nn.recurrent import A3TGCN\n    ```", "```py\n    class TemporalGNN(torch.nn.Module):\n        def __init__(self, dim_in, periods):\n            super().__init__()\n            self.tgnn = A3TGCN(in_channels=dim_in, out_channels=32, periods=periods)\n            self.linear = torch.nn.Linear(32, periods)\n        def forward(self, x, edge_index, edge_attr):\n            h = self.tgnn(x, edge_index, edge_attr).relu()\n            h = self.linear(h)\n            return h\n    ```", "```py\n    model = TemporalGNN(lags, 1).to('cpu')\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.005)\n    ```", "```py\n    model.train()\n    for epoch in range(30):\n        loss = 0\n        step = 0\n        for i, snapshot in enumerate(train_dataset):\n            y_pred = model(snapshot.x.unsqueeze(2), snapshot.edge_index, snapshot.edge_attr)\n            loss += torch.mean((y_pred-snapshot.y)**2)\n            step += 1\n        loss = loss / (step + 1)\n        loss.backward()\n        optimizer.step()\n        optimizer.zero_grad()\n        if epoch % 10 == 0:\n            print(f\"Epoch {epoch+1:>2} | Train MSE: {loss:.4f}\")\n    ```", "```py\n    Epoch  1 | Train MSE: 1.0209\n    Epoch 10 | Train MSE: 0.9625\n    Epoch 20 | Train MSE: 0.9143\n    Epoch 30 | Train MSE: 0.8905\n    ```", "```py\n    def inverse_zscore(x, mean, std):\n        return x * std + mean\n    ```", "```py\n    y_test = []\n    for snapshot in test_dataset:\n        y_hat = snapshot.y.numpy()\n        y_hat = inverse_zscore(y_hat, speeds.mean(axis=0), speeds.std(axis=0))\n        y_test = np.append(y_test, y_hat)\n    ```", "```py\n    gnn_pred = []\n    model.eval()\n    for snapshot in test_dataset:\n        y_hat = model(snapshot.x.unsqueeze(2), snapshot.edge_index, snapshot.edge_weight).squeeze().detach().numpy()\n        y_hat = inverse_zscore(y_hat, speeds.mean(axis=0), speeds.std(axis=0))\n        gnn_pred = np.append(gnn_pred, y_hat)\n    ```", "```py\n    rw_pred = []\n    for snapshot in test_dataset:\n        y_hat = snapshot.x[:,-1].squeeze().detach().numpy()\n        y_hat = inverse_zscore(y_hat, speeds.mean(axis=0), speeds.std(axis=0))\n        rw_pred = np.append(rw_pred, y_hat)\n    ha_pred = []\n    for i in range(lags, speeds_norm.shape[0]-horizon):\n        y_hat = speeds_norm.to_numpy()[i-lags:i].T.mean(axis=1)\n        y_hat = inverse_zscore(y_hat, speeds.mean(axis=0), speeds.std(axis=0))\n        ha_pred.append(y_hat)\n    ha_pred = np.array(ha_pred).flatten()[-len(y_test):]\n    ```", "```py\n    def MAE(real, pred):\n        return np.mean(np.abs(pred - real))\n    def RMSE(real, pred):\n        return np.sqrt(np.mean((pred - real) ** 2))\n    def MAPE(real, pred):\n        return np.mean(np.abs(pred - real) / (real + 1e-5))\n    ```", "```py\n    print(f'GNN MAE  = {MAE(gnn_pred, y_test):.4f}')\n    print(f'GNN RMSE = {RMSE(gnn_pred, y_test):.4f}')\n    print(f'GNN MAPE = {MAPE(gnn_pred, y_test):.4f}')\n    ```", "```py\n    y_preds = [inverse_zscore(model(snapshot.x.unsqueeze(2), snapshot.edge_index, snapshot.edge_weight).squeeze().detach().numpy(), speeds.mean(axis=0), speeds.std(axis=0)).mean() for snapshot in test_dataset]\n    ```", "```py\n    mean = speeds.mean(axis=1)\n    std = speeds.std(axis=1)\n    ```", "```py\n    plt.figure(figsize=(10,5), dpi=300)\n    plt.plot(mean, 'k-', label='Mean')\n    plt.plot(range(len(speeds)-len(y_preds), len(speeds)), y_preds, 'r-', label='Prediction')\n    plt.grid(linestyle=':')\n    plt.fill_between(mean.index, mean-std, mean+std, color='r', alpha=0.1)\n    plt.axvline(x=len(speeds)-len(y_preds), color='b', linestyle='--')\n    plt.xlabel('Time (5 min)')\n    plt.ylabel('Traffic speed to predict')\n    plt.legend(loc='upper right')\n    ```"]