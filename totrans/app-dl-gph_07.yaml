- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph Deep Learning in Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having explored the theoretical aspects of graph deep learning in the previous
    chapters, now is a good time to get our hands dirty by diving into its practical
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Social networks have become an integral part of our digital lives, generating
    vast amounts of data that can provide valuable insights into human behavior, relationships,
    and social dynamics. Graph deep learning offers powerful tools to analyze and
    extract meaningful information from these complex networks. In this chapter, we
    will explore practical applications of graph deep learning techniques to social
    network analysis using **PyTorch** **Geometric** ( **PyG** ).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will focus on a hypothetical dataset representing a social network
    of university students. This example will demonstrate how graph-based machine
    learning can be applied to real-world scenarios, such as predicting user interests,
    recommending new connections, and identifying community structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our dataset consists of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nodes** : Each node represents a student in the university.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edges** : Edges between nodes represent friendships or connections between
    students.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node features** : Each student (node) has associated features, including
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Age
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Year of study
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Academic major (encoded as a one-hot vector)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node labels** : Each student is assigned to one of five interest groups,
    which we’ll use for our node classification task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we will tackle two main tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node classification** : We’ll predict student interests based on their features
    and connections within the network. This task demonstrates how **graph neural
    networks** ( **GNNs** ) can leverage both node attributes and network structure
    to make predictions about individual nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Link prediction** : We’ll develop a model to recommend new friendships by
    predicting potential edges in the graph. This showcases how graph deep learning
    can be used for recommendation systems and network growth prediction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll implement these tasks using state-of-the-art GNN architectures. Additionally,
    we’ll visualize our results to gain intuitive insights into the network structure
    and our model’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have a practical understanding of how to
    apply graph deep learning techniques to social network data, interpret the results,
    and adapt these methods to your own projects. While we use a synthetic dataset
    for demonstration, the techniques covered here can be readily applied to real-world
    social network data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin our journey into the practical world of graph deep learning for
    social network analysis! We will be exploring the following topics at length:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the graph dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node classification – predicting student interests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Link prediction – recommending new friendships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the implementation of our graph deep learning models, it’s
    crucial to set up our development environment with the necessary libraries and
    tools. In this section, we’ll cover the essential imports and explain their roles
    in our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s start by importing the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down these imports and their purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**torch** : The core PyTorch library used for tensor operations and building
    neural networks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**torch_geometric** : PyG, an extension library to PyTorch for deep learning
    on graphs and other irregular structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**torch_geometric.data.Data** : A class used to create graph data objects in
    PyG that hold node features, edge indices, and labels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**torch_geometric.nn.GCNConv** : The **graph convolutional network** ( **GCN**
    ) layer, used for node classification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**torch_geometric.nn.GAE** : The **graph autoencoder** ( **GAE** ), used for
    link prediction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**torch_geometric.utils.train_test_split_edges** : A utility function that
    helps split the graph data for link prediction tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**torch_geometric.transforms.RandomLinkSplit** : A transform used to prepare
    the data for link prediction by splitting it into train, validation, and test
    sets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sklearn.manifold.TSNE** : **t-Distributed Stochastic Neighbor Embedding**
    ( **t-SNE** ), used for dimensionality reduction when visualizing node embeddings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sklearn.cluster.KMeans** : Used for clustering node embeddings to identify
    social groups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**matplotlib.pyplot** : A library used for creating visualizations of graphs
    and results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**networkx** : A library providing additional tools for working with graphs,
    used for some visualizations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make sure you have all these libraries installed in your Python environment.
    You can install them using **pip** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the installation of PyG ( **torch_geometric** ) might require additional
    steps depending on your system and CUDA version. Please refer to the official
    documentation for detailed installation instructions: [https://pytorch-geometric.readthedocs.io/en/latest/](https://pytorch-geometric.readthedocs.io/en/latest/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: With these libraries imported, we’re now ready to start working with our social
    network data and implementing our graph deep learning models.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the graph dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to create a synthetic social network dataset to demonstrate
    our graph deep learning techniques. While real-world data would be ideal, using
    synthetic data allows us to focus on the implementation and understanding of the
    algorithms without the complexities of data acquisition and preprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will create a social network dataset representing university students.
    The complete code can be found at [https://github.com/PacktPublishing/Applied-Deep-Learning-on-Graphs](https://github.com/PacktPublishing/Applied-Deep-Learning-on-Graphs)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break down this code and explain each part.
  prefs: []
  type: TYPE_NORMAL
- en: 'We set a random seed for reproducibility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This ensures that we generate the same “random” data each time we run the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We define our dataset parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**num_nodes** is the number of students (nodes) in our network.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**num_features** is the number of features for each student. We’re using 10
    features to represent age, year of study, and 8 possible academic majors.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**num_classes** is the number of different interest groups, which will be our
    target for node classification.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We create node features ( **x** ) using **torch.randn()** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This generates a tensor of size **(num_nodes, num_features)** filled with random
    values from a standard normal distribution. In a real dataset, these features
    would be actual attributes of the students.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We create edges ( **edge_index** ) using **torch.randint()** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This generates 5,000 random edges between nodes. The **edge_index** tensor has
    the shape **(2, 5000)** , where each column represents an edge with **[** **source_node,
    target_node]** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We create node labels ( **y** ) using **torch.randint()** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This assigns each node (student) to one of the five interest groups randomly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We create a PyG **Data** object, which efficiently holds our graph data. We
    pass in our node features ( **x** ), edge indices ( **edge_index** ), and node
    labels ( **y** ):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we print some information about our dataset to verify its structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This synthetic dataset now represents a social network:'
  prefs: []
  type: TYPE_NORMAL
- en: Each *node* is a student with 10 features (representing attributes such as age,
    year, and major).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Edges* represent friendships between students.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each student belongs to one of five interest groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In a real-world scenario, you would typically load your data from files or databases
    and preprocess it to fit this structure. The **Data** object we’ve created is
    now ready to be used with PyG’s GNN models.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we’ll use this dataset to perform node classification,
    link prediction, and graph clustering tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Node classification – predicting student interests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll implement a GCN to predict student interests based on
    their features and connections in the social network. This task demonstrates how
    GNNs can leverage both node attributes and network structure to make predictions
    about individual nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining our GCN model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our GCN model consists of two graph convolutional layers. The
    first layer takes the input features and produces hidden representations, while
    the second layer produces the final class predictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s train the model. You can view the complete code at [https://github.com/PacktPublishing/Applied-Deep-Learning-on-Graphs](https://github.com/PacktPublishing/Applied-Deep-Learning-on-Graphs)
    . Let’s break down the training process here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define an optimizer ( **Adam** ) and a loss function ( **CrossEntropyLoss**
    ) for training our model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The **train()** function performs one step of training:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It sets the model to training mode.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It computes the forward pass of the model.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It calculates the loss between predictions and true labels.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It performs backpropagation and updates the model parameters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **test()** function evaluates the model’s performance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It sets the model to evaluation mode.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It computes the forward pass.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It calculates the accuracy of predictions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We train the model for **200** epochs, printing the loss and accuracy every
    **10** epochs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we evaluate the model one last time to get the final accuracy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To visualize how well our model is performing, let’s create a function to plot
    the predicted versus true interest groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This function creates two scatter plots: one showing the true interest groups
    and another showing the predicted interest groups.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Model performance: true versus predicted interests](img/B22118_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Model performance: true versus predicted interests'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7* *.1* , each point represents a student, positioned based on their
    first two features. The visualization consists of two scatter plots labeled **True
    Interests** and **Predicted Interests** . Each point in these plots represents
    one of the students. The colors in both plots, ranging from purple ( **0.0** )
    to yellow ( **4.0** ), indicate different interest groups. The left plot shows
    the actual or “true” interest groups of the students, while the right plot displays
    the model’s predictions of these interest groups. The similarity between the distributions
    conveys the effectiveness of graph learning techniques in such predictions.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world application, this node classification task could be used to
    predict student interests based on their profile information and social connections.
    This could be valuable for personalized content recommendations, targeted advertising,
    or improving student engagement in university activities.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that while our synthetic dataset provides a clean example, real-world
    data often requires more preprocessing, handling of missing values, and careful
    consideration of privacy and ethical concerns when working with personal data.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of graph learning is the task of link prediction. This comes
    up in a lot of real-world scenarios, especially ones where we are trying to predict
    certain connections.
  prefs: []
  type: TYPE_NORMAL
- en: Link prediction – recommending new friendships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll implement a GAE for link prediction. This task aims to
    predict potential new connections in the network, which can be used to recommend
    new friendships among students.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s define our GAE model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our **LinkPredictor** model uses a GCN layer for encoding node features into
    embeddings, and a simple dot product operation for decoding ( predicting links).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s prepare our data for link prediction using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The **RandomLinkSplit** transform splits our graph into training, validation,
    and test sets for link prediction. It removes some edges for validation and testing
    and generates negative samples ( non-existent edges).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s define our training and evaluation functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the training process, prepare the optimizer, and encode the input
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define positive edges and generate negative edges for training:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Combine positive and negative edges and create corresponding labels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The model makes predictions, calculates the loss, performs backpropagation,
    and updates the model parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This begins the testing function, setting the model to evaluation mode and
    making predictions without gradient calculation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we convert the predictions to NumPy arrays and calculate the **Area
    Under the Receiver Operating Characteristic Curve** ( **ROC AUC)** score to evaluate
    the model’s performance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s write the training and prediction modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We train the model for **100** epochs, printing the loss and validation AUC
    every **10** epochs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **train_link_predictor()** function encodes the node features, predicts
    links for both positive and negative samples, and computes the binary cross-entropy
    loss.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **test_link_predictor()** function evaluates the model’s performance using
    the AUC metric:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we evaluate the model on the test set to get the final AUC score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the code output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To demonstrate how we can use this model to recommend new friendships, let’s
    create a function that predicts the most likely new connections for a given student:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the function, set the model to evaluation mode, and encode the graph
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we create an edge index for all possible connections between the given
    student and other students:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code predicts scores for all possible connections and selects the top
    *k* recommendations based on these scores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the function returns the recommended friends and their corresponding
    scores, as you can see in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This **recommend_friends** function takes a student ID and returns the top *k*
    recommended new connections based on the link prediction model.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world application, this link prediction model could be used to power
    a friend recommendation system in a university’s social network platform. It could
    help students expand their social circles based on shared characteristics and
    network structure.
  prefs: []
  type: TYPE_NORMAL
- en: The link prediction model’s applications extend far beyond just university social
    networks, encompassing diverse domains such as professional networking platforms
    such as LinkedIn for career connections and business collaborations, academic
    research networks for finding potential co-authors and research partners, business
    applications for supply chain partner matching and B2B networking, healthcare
    networks for patient referrals and provider collaborations, community building
    through interest-based group recommendations and event participant matching, and
    content recommendation systems for discovering similar resources and expert-content
    matching. These applications demonstrate the model’s versatility in enhancing
    connectivity and collaboration opportunities across various sectors and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when implementing such systems with real user data, it’s crucial
    to consider privacy implications and potentially incorporate additional factors
    (such as user preferences or mutual friends) into the recommendation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the practical applications of graph deep learning
    in social network analysis using PyG. We focused on a hypothetical dataset representing
    a university student social network, demonstrating how graph-based machine learning
    can be applied to real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Together, we achieved two main tasks: node classification for predicting user
    interests and link prediction for recommending new connections. By following step-by-step
    instructions, you learned how to create a synthetic dataset, implement GCNs for
    node classification, and use GAEs for link prediction. We broke down our code
    into snippets in relation to data preparation, model training, evaluation, and
    visualization, allowing you to understand the practical aspects of applying graph
    deep learning techniques to social network data.'
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, we will explore how graph deep learning is being applied
    to various domains, starting with natural language processing.
  prefs: []
  type: TYPE_NORMAL
